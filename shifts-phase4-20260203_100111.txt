NACHO GYM - SHIFTS PHASE 4 EXPORT 20260203_100111


### SERVICES ###


=== services/shifts.service.ts ===

// services/shifts.service.ts
import { prisma } from "@/lib/db";
import { mapPaymentMethod } from "./enum-mappers";
import type {
  CorteResponse,
  CorteConVentasResponse,
  EstadisticasCortesResponse,
  ResumenVentasPorProducto,
  ResumenPorFormaPago,
} from "@/types/api/shifts";

export interface OpenShiftInput {
  cashierId: string;
  initialCash: number;
  notes?: string;
}

export interface CloseShiftInput {
  shiftId: number;
  totalWithdrawals?: number;
  withdrawalsConcept?: string;
  totalCash: number;
  notes?: string;
}

function serializeShift(shift: {
  id: number;
  folio: string;
  cashierId: string;
  openingDate: Date;
  closingDate: Date | null;
  initialCash: import("@prisma/client/runtime/library").Decimal;
  ticketCount: number;
  membershipSales: import("@prisma/client/runtime/library").Decimal;
  productSales0Tax: import("@prisma/client/runtime/library").Decimal;
  productSales16Tax: import("@prisma/client/runtime/library").Decimal;
  subtotal: import("@prisma/client/runtime/library").Decimal;
  tax: import("@prisma/client/runtime/library").Decimal;
  totalSales: import("@prisma/client/runtime/library").Decimal;
  cashAmount: import("@prisma/client/runtime/library").Decimal;
  debitCardAmount: import("@prisma/client/runtime/library").Decimal;
  creditCardAmount: import("@prisma/client/runtime/library").Decimal;
  totalVoucher: import("@prisma/client/runtime/library").Decimal;
  totalWithdrawals: import("@prisma/client/runtime/library").Decimal;
  withdrawalsConcept: string | null;
  cancelledSales: import("@prisma/client/runtime/library").Decimal;
  totalCash: import("@prisma/client/runtime/library").Decimal;
  difference: import("@prisma/client/runtime/library").Decimal;
  notes: string | null;
  createdAt: Date;
  updatedAt: Date;
  cashier: { id: string; name: string; email: string };
}): CorteResponse {
  return {
    id: shift.id,
    folio: shift.folio,
    cashierId: shift.cashierId,
    openingDate: shift.openingDate,
    closingDate: shift.closingDate ?? undefined,
    initialCash: Number(shift.initialCash),
    ticketCount: shift.ticketCount,
    membershipSales: Number(shift.membershipSales),
    productSales0Tax: Number(shift.productSales0Tax),
    productSales16Tax: Number(shift.productSales16Tax),
    subtotal: Number(shift.subtotal),
    tax: Number(shift.tax),
    totalSales: Number(shift.totalSales),
    cashAmount: Number(shift.cashAmount),
    debitCardAmount: Number(shift.debitCardAmount),
    creditCardAmount: Number(shift.creditCardAmount),
    totalVoucher: Number(shift.totalVoucher),
    totalWithdrawals: Number(shift.totalWithdrawals),
    withdrawalsConcept: shift.withdrawalsConcept ?? undefined,
    cancelledSales: Number(shift.cancelledSales),
    totalCash: Number(shift.totalCash),
    difference: Number(shift.difference),
    notes: shift.notes ?? undefined,
    createdAt: shift.createdAt,
    updatedAt: shift.updatedAt,
    cashier: shift.cashier,
  };
}

async function validateNoOpenShift(cashierId: string): Promise<void> {
  const openShift = await prisma.shift.findFirst({
    where: {
      cashierId,
      closingDate: null,
    },
  });

  if (openShift) {
    throw new Error("Ya tienes un corte abierto");
  }
}

async function validateNoSystemOpenShift(): Promise<void> {
  const openShift = await prisma.shift.findFirst({
    where: {
      closingDate: null,
    },
  });

  if (openShift) {
    throw new Error("Ya existe un corte abierto en el sistema");
  }
}

export async function openShift(data: OpenShiftInput): Promise<CorteResponse> {
  await validateNoOpenShift(data.cashierId);
  await validateNoSystemOpenShift();

  const lastShift = await prisma.shift.findFirst({
    orderBy: { createdAt: "desc" },
  });

  let newFolio = "FN-1";
  if (lastShift) {
    const currentNumber = parseInt(lastShift.folio.split("-")[1]) || 0;
    newFolio = `FN-${currentNumber + 1}`;
  }

  const shift = await prisma.shift.create({
    data: {
      folio: newFolio,
      cashierId: data.cashierId,
      openingDate: new Date(),
      initialCash: data.initialCash,
      notes: data.notes,
    },
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  return serializeShift(shift);
}

export async function closeShift(
  data: CloseShiftInput,
): Promise<CorteResponse> {
  const shift = await prisma.shift.findUnique({
    where: { id: data.shiftId },
    include: {
      inventoryMovements: {
        where: {
          type: "SALE",
          isCancelled: false,
        },
      },
    },
  });

  if (!shift) {
    throw new Error("Corte no encontrado");
  }

  if (shift.closingDate) {
    throw new Error("El corte ya está cerrado");
  }

  const tickets = new Set(shift.inventoryMovements.map((i) => i.ticket)).size;

  let membershipSales = 0;
  let productSales0Tax = 0;
  const productSales16Tax = 0;
  let cashAmount = 0;
  let debitCardAmount = 0;
  let creditCardAmount = 0;

  const membershipProducts = await prisma.product.findMany({
    where: {
      OR: [
        { name: { contains: "EFECTIVO", mode: "insensitive" } },
        { name: { contains: "VISITA", mode: "insensitive" } },
      ],
    },
  });
  const membershipIds = membershipProducts.map((p) => p.id);

  for (const sale of shift.inventoryMovements) {
    const total = Number(sale.total || 0);

    if (membershipIds.includes(sale.productId)) {
      membershipSales += total;
    } else {
      productSales0Tax += total;
    }

    switch (sale.paymentMethod) {
      case "CASH":
        cashAmount += total;
        break;
      case "DEBIT_CARD":
        debitCardAmount += total;
        break;
      case "CREDIT_CARD":
        creditCardAmount += total;
        break;
    }
  }

  const subtotal = membershipSales + productSales0Tax + productSales16Tax;
  const tax = productSales16Tax * 0.16;
  const totalSales = subtotal + tax;
  const totalVoucher = debitCardAmount + creditCardAmount;
  const totalWithdrawals = data.totalWithdrawals || 0;
  const totalCash = data.totalCash;
  const expectedCash =
    Number(shift.initialCash) + cashAmount - totalWithdrawals;
  const difference = totalCash - expectedCash;

  const updatedShift = await prisma.shift.update({
    where: { id: data.shiftId },
    data: {
      closingDate: new Date(),
      ticketCount: tickets,
      membershipSales,
      productSales0Tax,
      productSales16Tax,
      subtotal,
      tax,
      totalSales,
      cashAmount,
      debitCardAmount,
      creditCardAmount,
      totalVoucher,
      totalWithdrawals,
      withdrawalsConcept: data.withdrawalsConcept,
      totalCash,
      difference,
      notes: data.notes || shift.notes,
    },
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  return serializeShift(updatedShift);
}

export async function getActiveShift(): Promise<CorteConVentasResponse | null> {
  const shift = await prisma.shift.findFirst({
    where: { closingDate: null },
    include: {
      cashier: {
        select: { id: true, name: true, email: true },
      },
      inventoryMovements: {
        where: { type: "SALE", isCancelled: false },
        include: {
          product: { select: { name: true } },
          member: { select: { memberNumber: true, name: true } },
        },
        orderBy: { date: "desc" },
      },
    },
  });

  if (!shift) return null;

  const tickets = new Set(shift.inventoryMovements.map((i) => i.ticket)).size;
  let cashAmount = 0;
  let debitCardAmount = 0;
  let creditCardAmount = 0;
  let totalSales = 0;

  shift.inventoryMovements.forEach((sale) => {
    const total = Number(sale.total || 0);
    totalSales += total;

    switch (sale.paymentMethod) {
      case "CASH":
        cashAmount += total;
        break;
      case "DEBIT_CARD":
        debitCardAmount += total;
        break;
      case "CREDIT_CARD":
        creditCardAmount += total;
        break;
    }
  });

  const baseShift = serializeShift(shift);

  return {
    ...baseShift,
    ticketCount: tickets,
    cashAmount,
    debitCardAmount,
    creditCardAmount,
    totalSales,
    inventoryMovements: shift.inventoryMovements.map((m) => ({
      id: m.id,
      type: m.type,
      quantity: m.quantity,
      ticket: m.ticket ?? undefined,
      total: Number(m.total || 0),
      paymentMethod: m.paymentMethod
        ? mapPaymentMethod(m.paymentMethod)
        : undefined,
      date: m.date,
      product: {
        name: m.product.name,
      },
      member: m.member
        ? {
            memberNumber: m.member.memberNumber,
            name: m.member.name ?? undefined,
          }
        : undefined,
    })),
  };
}

export async function getShiftById(
  id: number,
): Promise<CorteConVentasResponse> {
  const shift = await prisma.shift.findUnique({
    where: { id },
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
      inventoryMovements: {
        where: {
          type: "SALE",
        },
        include: {
          product: {
            select: {
              name: true,
            },
          },
          member: {
            select: {
              memberNumber: true,
              name: true,
            },
          },
        },
        orderBy: { date: "asc" },
      },
    },
  });

  if (!shift) {
    throw new Error("Corte no encontrado");
  }

  return {
    ...serializeShift(shift),
    inventoryMovements: shift.inventoryMovements.map((m) => ({
      id: m.id,
      type: m.type,
      quantity: m.quantity,
      ticket: m.ticket ?? undefined,
      total: Number(m.total || 0),
      paymentMethod: m.paymentMethod
        ? mapPaymentMethod(m.paymentMethod)
        : undefined,
      date: m.date,
      product: {
        name: m.product.name,
      },
      member: m.member
        ? {
            memberNumber: m.member.memberNumber,
            name: m.member.name ?? undefined,
          }
        : undefined,
    })),
  };
}

export async function getAllShifts(limit?: number): Promise<CorteResponse[]> {
  const shifts = await prisma.shift.findMany({
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
    orderBy: { openingDate: "desc" },
    take: limit,
  });

  return shifts.map(serializeShift);
}

export async function getShiftsBetweenDates(
  startDate: Date,
  endDate: Date,
): Promise<CorteResponse[]> {
  const shifts = await prisma.shift.findMany({
    where: {
      openingDate: {
        gte: startDate,
        lte: endDate,
      },
    },
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
    orderBy: { openingDate: "desc" },
  });

  return shifts.map(serializeShift);
}

export async function getShiftsByCashier(
  cashierId: string,
  limit?: number,
): Promise<CorteResponse[]> {
  const shifts = await prisma.shift.findMany({
    where: { cashierId },
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
    orderBy: { openingDate: "desc" },
    take: limit,
  });

  return shifts.map(serializeShift);
}

export async function getSalesSummaryByShift(
  shiftId: number,
): Promise<ResumenVentasPorProducto[]> {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      shiftId,
      type: "SALE",
      isCancelled: false,
    },
    include: {
      product: {
        select: {
          name: true,
        },
      },
    },
  });

  const summaryByProduct = sales.reduce(
    (acc, sale) => {
      const name = sale.product.name;
      if (!acc[name]) {
        acc[name] = {
          product: name,
          quantity: 0,
          total: 0,
        };
      }
      acc[name].quantity += Math.abs(sale.quantity);
      acc[name].total += Number(sale.total || 0);
      return acc;
    },
    {} as Record<string, { product: string; quantity: number; total: number }>,
  );

  return Object.values(summaryByProduct);
}

export async function getPaymentMethodSummary(
  shiftId: number,
): Promise<ResumenPorFormaPago> {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      shiftId,
      type: "SALE",
      isCancelled: false,
    },
  });

  const summary = sales.reduce(
    (acc, sale) => {
      const total = Number(sale.total || 0);
      const method = sale.paymentMethod || "CASH";
      acc[method] += total;
      return acc;
    },
    {
      CASH: 0,
      DEBIT_CARD: 0,
      CREDIT_CARD: 0,
      TRANSFER: 0,
    },
  );

  return summary;
}

export async function getShiftsStatistics(
  startDate?: Date,
  endDate?: Date,
): Promise<EstadisticasCortesResponse> {
  const where: { openingDate?: { gte: Date; lte: Date } } = {};

  if (startDate && endDate) {
    where.openingDate = {
      gte: startDate,
      lte: endDate,
    };
  }

  const shifts = await prisma.shift.findMany({
    where,
  });

  const totalShifts = shifts.length;
  const totalSales = shifts.reduce((sum, s) => sum + Number(s.totalSales), 0);
  const averageSales = totalShifts > 0 ? totalSales / totalShifts : 0;
  const totalDifferences = shifts.reduce(
    (sum, s) => sum + Math.abs(Number(s.difference)),
    0,
  );

  return {
    totalShifts,
    totalSales,
    averageSales,
    totalDifferences,
  };
}

export async function cancelShift(
  shiftId: number,
  userRole: string,
): Promise<{ success: boolean; message: string }> {
  if (userRole !== "ADMIN") {
    throw new Error("Solo un administrador puede cancelar un corte");
  }

  const shift = await prisma.shift.findUnique({
    where: { id: shiftId },
  });

  if (!shift) {
    throw new Error("Corte no encontrado");
  }

  if (!shift.closingDate) {
    throw new Error("No se puede cancelar un corte abierto");
  }

  await prisma.shift.delete({
    where: { id: shiftId },
  });

  return { success: true, message: "Corte cancelado exitosamente" };
}



=== services/utils.ts ===

import { Decimal } from "@prisma/client/runtime/library";
import { MembershipType } from "@prisma/client";

export function serializeDecimal(value: unknown): unknown {
  return JSON.parse(
    JSON.stringify(value, (_key, val) => {
      if (val instanceof Decimal) {
        return Number(val.toString());
      }
      if (val instanceof Date) {
        return val.toISOString();
      }
      return val;
    }),
  );
}

/**
 * Parse ISO date string to Date object
 */
export function parseISODate(dateString: string | undefined): Date | undefined {
  if (!dateString) return undefined;
  return new Date(dateString);
}

/**
 * Parse boolean from query string
 */
export function parseBooleanQuery(
  value: string | undefined,
): boolean | undefined {
  if (value === "true") return true;
  if (value === "false") return false;
  return undefined;
}

/**
 * Parse and validate integer parameter (e.g., from URL params)
 */
export function parseIntParam(value: string, paramName: string = "ID"): number {
  const parsed = parseInt(value, 10);
  if (isNaN(parsed)) {
    throw new Error(`${paramName} inválido`);
  }
  return parsed;
}

/**
 * Calculate end date based on membership type
 */
function calculateEndDate(
  startDate: Date,
  membershipType: MembershipType,
): Date {
  const date = new Date(startDate);

  switch (membershipType) {
    case "VISIT":
      return date;
    case "WEEK":
      date.setDate(date.getDate() + 7);
      break;
    case "MONTH_STUDENT":
    case "MONTH_GENERAL":
      date.setMonth(date.getMonth() + 1);
      break;
    case "QUARTER_STUDENT":
    case "QUARTER_GENERAL":
      date.setMonth(date.getMonth() + 3);
      break;
    case "ANNUAL_STUDENT":
    case "ANNUAL_GENERAL":
      date.setFullYear(date.getFullYear() + 1);
      break;
    case "PROMOTION":
    case "REBIRTH":
    case "NUTRITION_CONSULTATION":
      date.setMonth(date.getMonth() + 1);
      break;
  }

  return date;
}

/**
 * Calculate membership start and end dates
 */
export function calculateMembershipDates(
  membershipType: MembershipType,
  startDate?: Date,
): { startDate: Date; endDate: Date } {
  const start = startDate || new Date();
  const end = calculateEndDate(start, membershipType);

  return {
    startDate: start,
    endDate: end,
  };
}




### API SHIFTS ###


=== app/api/shifts/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { ShiftsService } from "@/services";
import { headers } from "next/headers";
import { auth } from "@/lib/auth";
import { prisma } from "@/lib/db";
import { serializeDecimal } from "@/services/utils";

export async function POST(request: NextRequest) {
  try {
    const session = await auth.api.getSession({
      headers: await headers(),
    });

    if (!session) {
      return NextResponse.json({ error: "No autorizado" }, { status: 401 });
    }

    const body = await request.json();

    const shift = await ShiftsService.openShift({
      ...body,
      cashierId: session.user.id,
    });

    return NextResponse.json(shift, { status: 201 });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;

    // Filtros
    const search = searchParams.get("search");
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");
    const cashier = searchParams.get("cashier");
    const status = searchParams.get("status");

    // Ordenamiento
    const orderBy = searchParams.get("orderBy") || "fecha";
    const order = searchParams.get("order") || "desc";

    // Paginación
    const page = parseInt(searchParams.get("page") || "1");
    const perPage = parseInt(searchParams.get("perPage") || "10");

    // Construir filtros
    const where: any = {};

    if (search) {
      where.folio = {
        contains: search,
        mode: "insensitive",
      };
    }

    if (startDate && endDate) {
      where.openingDate = {
        gte: new Date(startDate),
        lte: new Date(endDate),
      };
    }

    if (cashier) {
      where.cashierId = cashier;
    }

    if (status === "abiertos") {
      where.closingDate = null;
    } else if (status === "cerrados") {
      where.closingDate = { not: null };
    }

    // Ordenamiento
    const orderByField = orderBy === "folio" ? "folio" : "openingDate";
    const orderDirection = order === "asc" ? "asc" : "desc";

    // Contar total
    const total = await prisma.shift.count({ where });

    // Obtener shifts paginados
    const shifts = await prisma.shift.findMany({
      where,
      include: {
        cashier: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
      orderBy: {
        [orderByField]: orderDirection,
      },
      skip: (page - 1) * perPage,
      take: perPage,
    });

    return NextResponse.json({
      shifts: serializeDecimal(shifts),
      total,
      page,
      perPage,
      totalPages: Math.ceil(total / perPage),
    });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}




### TYPES ###


=== types/api/shifts.ts ===

import type { Corte } from "../models/corte";
import type { MetodoPago } from "../models/movimiento-inventario";

// ==================== QUERY PARAMS ====================

export interface BuscarCortesQuery {
  search?: string;
  startDate?: string;
  endDate?: string;
  cashier?: string;
  status?: string;
  orderBy?: string;
  order?: string;
  page?: string;
  perPage?: string;
}

// ==================== REQUEST TYPES ====================

export interface AbrirCorteRequest {
  initialCash: number;
  notes?: string;
}

export interface CerrarCorteRequest {
  shiftId: number;
  cashAmount: number;
  debitCardAmount: number;
  creditCardAmount: number;
  totalWithdrawals?: number;
  withdrawalsConcept?: string;
  difference: number;
  notes?: string;
}

// ==================== RESPONSE TYPES ====================

export interface CorteResponse {
  id: number;
  folio: string;
  cashierId: string;
  openingDate: Date;
  closingDate?: Date;
  initialCash: number;
  ticketCount: number;
  membershipSales: number;
  productSales0Tax: number;
  productSales16Tax: number;
  subtotal: number;
  tax: number;
  totalSales: number;
  cashAmount: number;
  debitCardAmount: number;
  creditCardAmount: number;
  totalVoucher: number;
  totalWithdrawals: number;
  withdrawalsConcept?: string;
  cancelledSales: number;
  totalCash: number;
  difference: number;
  notes?: string;
  createdAt: Date;
  updatedAt: Date;
  cashier: {
    id: string;
    name: string;
    email: string;
  };
}

export interface CorteConVentasResponse extends CorteResponse {
  inventoryMovements: Array<{
    id: number;
    type: string;
    quantity: number;
    ticket?: string;
    total: number;
    paymentMethod?: MetodoPago;
    date: Date;
    product: {
      name: string;
    };
    member?: {
      memberNumber: string;
      name?: string;
    };
  }>;
}

export interface ResumenCorteResponse {
  initialCash: number;
  ticketCount: number;
  totalSales: number;
  cashAmount: number;
  debitCardAmount: number;
  creditCardAmount: number;
  totalWithdrawals: number;
}

export interface ListaCortesResponse {
  shifts: CorteResponse[];
  total: number;
  page: number;
  perPage: number;
  totalPages: number;
}

export interface EstadisticasCortesResponse {
  totalShifts: number;
  totalSales: number;
  averageSales: number;
  totalDifferences: number;
}

export interface ResumenVentasPorProducto {
  product: string;
  quantity: number;
  total: number;
}

export interface ResumenPorFormaPago {
  CASH: number;
  DEBIT_CARD: number;
  CREDIT_CARD: number;
  TRANSFER: number;
}


