### PHASE 1 - SALES DOMAIN EXTRACTION


===== app/api/sales =====


--- FILE: app/api/sales/products/route.ts ---

import { NextResponse } from "next/server";
import { headers } from "next/headers";
import { auth } from "@/lib/auth";
import { prisma } from "@/lib/db";

export async function GET() {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session?.user) {
    return NextResponse.json({ error: "No autorizado" }, { status: 401 });
  }

  const products = await prisma.product.findMany({
    where: {
      isActive: true,
      // Solo productos físicos con stock
      // Excluir membresías basados en keywords
      NOT: {
        OR: [
          { name: { contains: "EFECTIVO", mode: "insensitive" } },
          { name: { contains: "VISITA", mode: "insensitive" } },
          { name: { contains: "MENSUALIDAD", mode: "insensitive" } },
          { name: { contains: "SEMANA", mode: "insensitive" } },
          { name: { contains: "TRIMESTRE", mode: "insensitive" } },
          { name: { contains: "ANUAL", mode: "insensitive" } },
        ],
      },
    },
    select: {
      id: true,
      name: true,
      salePrice: true,
      gymStock: true,
      warehouseStock: true,
    },
    orderBy: { name: "asc" },
  });

  // Agregar campo calculado de stock total
  const productsWithStock = products.map(p => ({
    ...p,
    totalStock: p.gymStock + p.warehouseStock,
  }));

  return NextResponse.json(productsWithStock);
}

--- FILE: app/api/sales/history/route.ts ---

// app/api/sales/history/route.ts

import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { serializeDecimal } from "@/services/utils";
import { Prisma } from "@prisma/client";

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;

    const where: Prisma.InventoryMovementWhereInput = {
      type: "SALE",
    };

    // ================= Filters =================

    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");

    if (startDate && endDate) {
      where.date = {
        gte: new Date(startDate),
        lte: new Date(endDate + "T23:59:59"),
      };
    }

    const cashier = searchParams.get("cashier");
    if (cashier && cashier !== "todos") where.userId = cashier;

    const product = searchParams.get("product");
    if (product && product !== "todos") where.productId = parseInt(product);

    const member = searchParams.get("member");
    if (member && member !== "todos") where.memberId = parseInt(member);

    const paymentMethod = searchParams.get("paymentMethod");
    if (paymentMethod && paymentMethod !== "todos")
      where.paymentMethod = paymentMethod as any;

    const onlyActive = searchParams.get("onlyActive") === "true";
    if (onlyActive) where.isCancelled = false;

    // Product type filter
    const productType = searchParams.get("productType");
    if (productType && productType !== "todos") {
      const membershipProducts = [
        "VISITA",
        "EFECTIVO SEMANA",
        "EFECTIVO MENSUALIDAD ESTUDIANTE",
        "EFECTIVO MENSUALIDAD GENERAL",
        "EFECTIVO TRIMESTRE ESTUDIANTE",
        "EFECTIVO TRIMESTRE GENERAL",
        "EFECTIVO ANUAL ESTUDIANTE",
        "EFECTIVO ANUAL GENERAL",
      ];

      if (productType === "membresias") {
        where.product = {
          name: { in: membershipProducts },
        };
      } else if (productType === "productos") {
        where.product = {
          name: { notIn: membershipProducts },
        };
      }
    }

    // Search filter
    const search = searchParams.get("search");
    if (search) {
      where.OR = [
        { ticket: { contains: search, mode: "insensitive" } },
        { product: { name: { contains: search, mode: "insensitive" } } },
        { member: { name: { contains: search, mode: "insensitive" } } },
        { member: { memberNumber: { contains: search, mode: "insensitive" } } },
        { user: { name: { contains: search, mode: "insensitive" } } },
      ];
    }

    // ================= Order By =================

    const orderBy = searchParams.get("orderBy") || "date";
    const order = searchParams.get("order") || "desc";

    let orderByClause: any = { date: order };

    if (orderBy === "total") {
      orderByClause = { total: order };
    } else if (orderBy === "ticket") {
      orderByClause = { ticket: order };
    }

    // ================= Pagination =================

    const page = parseInt(searchParams.get("page") || "1");
    const perPage = parseInt(searchParams.get("perPage") || "10");

    // ================= Get unique tickets count =================

    const uniqueTickets = await prisma.inventoryMovement.findMany({
      where,
      select: { ticket: true },
      distinct: ["ticket"],
    });

    const total = uniqueTickets.length;

    // ================= Get movements for current page =================

    // Get all movements, then group by ticket
    const movements = await prisma.inventoryMovement.findMany({
      where,
      orderBy: orderByClause,
      select: {
        id: true,
        ticket: true,
        date: true,
        quantity: true,
        total: true,
        paymentMethod: true,
        isCancelled: true,
        product: { select: { name: true } },
        member: { select: { memberNumber: true, name: true } },
        user: { select: { name: true } },
      },
    });

    // ================= Group by ticket =================

    const groups = new Map<string, any>();

    for (const m of movements) {
      const ticket = m.ticket || "NO-TICKET";

      if (!groups.has(ticket)) {
        groups.set(ticket, {
          ticket,
          date: m.date,
          total: 0,
          paymentMethod: m.paymentMethod,
          cashier: m.user.name,
          member: m.member,
          isCancelled: m.isCancelled,
          items: [],
        });
      }

      const g = groups.get(ticket);
      g.total += Number(m.total || 0);

      g.items.push({
        id: m.id,
        product: m.product,
        quantity: m.quantity,
        total: m.total,
      });
    }

    // Convert to array and apply ordering
    let ticketsArray = Array.from(groups.values());

    // Apply ordering to grouped tickets
    if (orderBy === "date") {
      ticketsArray.sort((a, b) => {
        const dateA = new Date(a.date).getTime();
        const dateB = new Date(b.date).getTime();
        return order === "desc" ? dateB - dateA : dateA - dateB;
      });
    } else if (orderBy === "total") {
      ticketsArray.sort((a, b) => {
        return order === "desc" ? b.total - a.total : a.total - b.total;
      });
    } else if (orderBy === "ticket") {
      ticketsArray.sort((a, b) => {
        const ticketA = a.ticket || "";
        const ticketB = b.ticket || "";
        return order === "desc"
          ? ticketB.localeCompare(ticketA)
          : ticketA.localeCompare(ticketB);
      });
    }

    // Apply pagination
    const skip = (page - 1) * perPage;
    const tickets = ticketsArray.slice(skip, skip + perPage);

    return NextResponse.json({
      tickets: serializeDecimal(tickets),
      total,
      page,
      perPage,
      totalPages: Math.ceil(total / perPage),
    });
  } catch (error: any) {
    console.error("[sales/history]", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- FILE: app/api/sales/ticket/[ticket]/route.ts ---

import { NextRequest, NextResponse } from "next/server";
import { InventoryService } from "@/services";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ ticket: string }> },
) {
  try {
    const { ticket } = await params;
    const ticketData = await InventoryService.getTicketDetail(ticket);
    return NextResponse.json(ticketData);
  } catch (error) {
    const message =
      error instanceof Error ? error.message : "Error al obtener ticket";
    const status =
      error instanceof Error && error.message === "Ticket no encontrado"
        ? 404
        : 500;
    return NextResponse.json({ error: message }, { status });
  }
}


===== services =====


--- FILE: services/inventory.service.ts ---

import { prisma } from "@/lib/db";
import { InventoryType, Location, PaymentMethod } from "@prisma/client";
import { calculateMembershipDates, parseISODate, parseIntParam } from "./utils";
import {
  mapInventoryType,
  mapLocation,
  mapPaymentMethod,
} from "./enum-mappers";
import {
  MovementsQuerySchema,
  CancelledSalesQuerySchema,
} from "@/types/api/inventory";
import type {
  CrearVentaRequest,
  CrearEntradaRequest,
  CrearTraspasoRequest,
  CrearAjusteRequest,
  CancelarVentaRequest,
  MovimientoInventarioResponse,
  MovementsQueryInput,
  CancelledSalesQueryInput,
  VentaCreada,
  EntradaCreada,
  TraspasoCreado,
  AjusteCreado,
  VentaCancelada,
} from "@/types/api/inventory";
import type { DetalleTicketResponse, ItemVentaTicket } from "@/types/api/sales";

// ==================== INTERNAL TYPES ====================

export interface GetMovementsByDateParams {
  startDate: Date;
  endDate: Date;
}

export interface GetCancelledSalesParams {
  startDate?: Date;
  endDate?: Date;
}

// ==================== HELPERS ====================

function serializeInventoryMovement(movement: {
  id: number;
  productId: number;
  type: InventoryType;
  location: Location;
  quantity: number;
  ticket: string | null;
  memberId: number | null;
  userId: string;
  unitPrice: import("@prisma/client/runtime/library").Decimal | null;
  subtotal: import("@prisma/client/runtime/library").Decimal | null;
  discount: import("@prisma/client/runtime/library").Decimal | null;
  surcharge: import("@prisma/client/runtime/library").Decimal | null;
  total: import("@prisma/client/runtime/library").Decimal | null;
  paymentMethod: PaymentMethod | null;
  shiftId: number | null;
  notes: string | null;
  isCancelled: boolean;
  cancellationReason: string | null;
  cancellationDate: Date | null;
  date: Date;
  createdAt: Date;
  product: {
    name: string;
    salePrice?: import("@prisma/client/runtime/library").Decimal;
  };
  member?: { memberNumber: string; name: string | null } | null;
  user: { name: string };
}): MovimientoInventarioResponse {
  return {
    id: movement.id,
    productId: movement.productId,
    type: mapInventoryType(movement.type),
    location: mapLocation(movement.location),
    quantity: movement.quantity,
    ticket: movement.ticket ?? undefined,
    memberId: movement.memberId ?? undefined,
    userId: movement.userId,
    unitPrice: movement.unitPrice ? Number(movement.unitPrice) : undefined,
    subtotal: movement.subtotal ? Number(movement.subtotal) : undefined,
    discount: movement.discount ? Number(movement.discount) : undefined,
    surcharge: movement.surcharge ? Number(movement.surcharge) : undefined,
    total: movement.total ? Number(movement.total) : undefined,
    paymentMethod: movement.paymentMethod
      ? mapPaymentMethod(movement.paymentMethod)
      : undefined,
    shiftId: movement.shiftId ?? undefined,
    notes: movement.notes ?? undefined,
    isCancelled: movement.isCancelled,
    cancellationReason: movement.cancellationReason ?? undefined,
    cancellationDate: movement.cancellationDate ?? undefined,
    date: movement.date,
    createdAt: movement.createdAt,
    product: {
      name: movement.product.name,
      salePrice: movement.product.salePrice
        ? Number(movement.product.salePrice)
        : undefined,
    },
    member: movement.member
      ? {
          memberNumber: movement.member.memberNumber,
          name: movement.member.name ?? undefined,
        }
      : undefined,
    user: {
      name: movement.user.name,
    },
  };
}

// ==================== VALIDATIONS ====================

async function validateStock(
  productId: number,
  quantity: number,
  location: Location,
): Promise<{
  id: number;
  name: string;
  warehouseStock: number;
  gymStock: number;
  salePrice: import("@prisma/client/runtime/library").Decimal;
}> {
  const product = await prisma.product.findUnique({
    where: { id: productId },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  const isMembership =
    product.name.includes("EFECTIVO") ||
    product.name.includes("VISITA") ||
    product.name.includes("MENSUALIDAD") ||
    product.name.includes("SEMANA") ||
    product.name.includes("TRIMESTRE") ||
    product.name.includes("ANUAL");

  if (!isMembership) {
    const currentStock =
      location === "WAREHOUSE" ? product.warehouseStock : product.gymStock;

    if (currentStock < quantity) {
      throw new Error(
        `Stock insuficiente en ${location}. Disponible: ${currentStock}, Solicitado: ${quantity}`,
      );
    }
  }

  return product;
}

// ==================== PARSING HELPERS ====================

export function parseMovementsQuery(
  raw: MovementsQueryInput,
): GetMovementsByDateParams {
  const validated = MovementsQuerySchema.parse(raw);

  const startDate = new Date(validated.startDate);
  const endDate = new Date(validated.endDate);

  if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
    throw new Error("Fechas inválidas");
  }

  return { startDate, endDate };
}

export function parseCancelledSalesQuery(
  raw: CancelledSalesQueryInput,
): GetCancelledSalesParams {
  const validated = CancelledSalesQuerySchema.parse(raw);

  return {
    startDate: parseISODate(validated.startDate),
    endDate: parseISODate(validated.endDate),
  };
}

export function parseProductIdParam(id: string): number {
  return parseIntParam(id, "ID de producto");
}

// ==================== SALE SERVICES ====================

export async function createSale(
  data: CrearVentaRequest,
  userId: string,
): Promise<VentaCreada> {
  const product = await validateStock(data.productId, data.quantity, "GYM");

  const unitPrice = data.unitPrice || Number(product.salePrice);
  const subtotal = unitPrice * data.quantity;
  const discount = data.discount || 0;
  const surcharge = data.surcharge || 0;
  const total = subtotal - discount + surcharge;

  const isMembership =
    product.name.includes("EFECTIVO") ||
    product.name.includes("VISITA") ||
    product.name.includes("MENSUALIDAD") ||
    product.name.includes("SEMANA") ||
    product.name.includes("TRIMESTRE") ||
    product.name.includes("ANUAL");

  const inventoryMovement = await prisma.$transaction(async (tx) => {
    const movement = await tx.inventoryMovement.create({
      data: {
        productId: data.productId,
        type: "SALE",
        location: "GYM",
        quantity: -data.quantity,
        ticket: data.ticket,
        memberId: data.memberId,
        userId,
        unitPrice,
        subtotal,
        discount,
        surcharge,
        total,
        paymentMethod: data.paymentMethod,
        shiftId: data.shiftId,
        notes: data.notes,
      },
      include: {
        product: true,
        member: true,
        user: {
          select: {
            name: true,
          },
        },
      },
    });

    if (!isMembership) {
      await tx.product.update({
        where: { id: data.productId },
        data: {
          gymStock: product.gymStock - data.quantity,
        },
      });
    }

    return movement;
  });

  if (data.memberId && isMembership) {
    const member = await prisma.member.findUnique({
      where: { id: data.memberId },
    });

    if (member && member.membershipType) {
      const dates = calculateMembershipDates(member.membershipType);

      await prisma.member.update({
        where: { id: data.memberId },
        data: {
          startDate: dates.startDate,
          endDate: dates.endDate,
          totalVisits: { increment: 1 },
          lastVisit: new Date(),
        },
      });
    }
  } else if (data.memberId) {
    await prisma.member.update({
      where: { id: data.memberId },
      data: {
        totalVisits: { increment: 1 },
        lastVisit: new Date(),
      },
    });
  }

  return serializeInventoryMovement(inventoryMovement) as VentaCreada;
}

export async function cancelSale(
  data: CancelarVentaRequest,
): Promise<VentaCancelada> {
  const sale = await prisma.inventoryMovement.findUnique({
    where: { id: data.inventoryId },
    include: {
      product: true,
      user: {
        select: {
          name: true,
        },
      },
    },
  });

  if (!sale) {
    throw new Error("Venta no encontrada");
  }

  if (sale.type !== "SALE") {
    throw new Error("Solo se pueden cancelar ventas");
  }

  if (sale.isCancelled) {
    throw new Error("La venta ya fue cancelada");
  }

  const quantityToReturn = Math.abs(sale.quantity);

  const cancelledInventory = await prisma.$transaction(async (tx) => {
    const cancelled = await tx.inventoryMovement.update({
      where: { id: data.inventoryId },
      data: {
        isCancelled: true,
        cancellationReason: data.cancellationReason,
        cancellationDate: new Date(),
      },
      include: {
        product: true,
        member: true,
        user: {
          select: {
            name: true,
          },
        },
      },
    });

    await tx.product.update({
      where: { id: sale.productId },
      data: {
        gymStock: sale.product.gymStock + quantityToReturn,
      },
    });

    return cancelled;
  });

  return serializeInventoryMovement(cancelledInventory) as VentaCancelada;
}

// ==================== TICKET SERVICES ====================

export async function getTicketDetail(
  ticket: string,
): Promise<DetalleTicketResponse> {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      ticket,
      type: "SALE",
    },
    include: {
      product: {
        select: {
          name: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { date: "asc" },
  });

  if (sales.length === 0) {
    throw new Error("Ticket no encontrado");
  }

  const firstSale = sales[0];

  const items: ItemVentaTicket[] = sales.map((s) => ({
    id: s.id,
    product: {
      name: s.product.name,
    },
    quantity: s.quantity,
    total: Number(s.total || 0),
  }));

  const total = sales.reduce((sum, s) => sum + Number(s.total || 0), 0);

  return {
    ticket,
    date: firstSale.date,
    cashier: firstSale.user.name,
    paymentMethod: firstSale.paymentMethod
      ? mapPaymentMethod(firstSale.paymentMethod)
      : undefined,
    member: firstSale.member
      ? {
          memberNumber: firstSale.member.memberNumber,
          name: firstSale.member.name ?? undefined,
        }
      : undefined,
    isCancelled: firstSale.isCancelled,
    cancellationReason: firstSale.cancellationReason ?? undefined,
    cancellationDate: firstSale.cancellationDate ?? undefined,
    notes: firstSale.notes ?? undefined,
    total,
    items,
  };
}

// ==================== ENTRY SERVICES ====================

export async function createEntry(
  data: CrearEntradaRequest,
  userId: string,
): Promise<EntradaCreada> {
  const product = await prisma.product.findUnique({
    where: { id: data.productId },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  const type: InventoryType =
    data.location === "WAREHOUSE" ? "WAREHOUSE_ENTRY" : "GYM_ENTRY";

  const inventoryMovement = await prisma.$transaction(async (tx) => {
    const movement = await tx.inventoryMovement.create({
      data: {
        productId: data.productId,
        type,
        location: data.location,
        quantity: data.quantity,
        userId,
        notes: data.notes,
      },
      include: {
        product: true,
        user: {
          select: {
            name: true,
          },
        },
      },
    });

    await tx.product.update({
      where: { id: data.productId },
      data: {
        [data.location === "WAREHOUSE" ? "warehouseStock" : "gymStock"]: {
          increment: data.quantity,
        },
      },
    });

    return movement;
  });

  return serializeInventoryMovement(inventoryMovement) as EntradaCreada;
}

// ==================== TRANSFER SERVICES ====================

export async function createTransfer(
  data: CrearTraspasoRequest,
  userId: string,
): Promise<TraspasoCreado> {
  const origin: Location = data.destination === "GYM" ? "WAREHOUSE" : "GYM";

  const product = await validateStock(data.productId, data.quantity, origin);

  const type: InventoryType =
    data.destination === "GYM" ? "TRANSFER_TO_GYM" : "TRANSFER_TO_WAREHOUSE";

  const inventoryMovement = await prisma.$transaction(async (tx) => {
    const movement = await tx.inventoryMovement.create({
      data: {
        productId: data.productId,
        type,
        location: data.destination,
        quantity: data.quantity,
        userId,
        notes:
          data.notes ||
          `Traspaso de ${data.quantity} unidades de ${origin} a ${data.destination}`,
      },
      include: {
        product: true,
        user: {
          select: {
            name: true,
          },
        },
      },
    });

    await tx.product.update({
      where: { id: data.productId },
      data: {
        warehouseStock:
          origin === "WAREHOUSE"
            ? product.warehouseStock - data.quantity
            : product.warehouseStock + data.quantity,
        gymStock:
          origin === "GYM"
            ? product.gymStock - data.quantity
            : product.gymStock + data.quantity,
      },
    });

    return movement;
  });

  return serializeInventoryMovement(inventoryMovement) as TraspasoCreado;
}

// ==================== ADJUSTMENT SERVICES ====================

export async function createAdjustment(
  data: CrearAjusteRequest,
  userId: string,
): Promise<AjusteCreado> {
  const product = await prisma.product.findUnique({
    where: { id: data.productId },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  const currentStock =
    data.location === "WAREHOUSE" ? product.warehouseStock : product.gymStock;
  const newStock = currentStock + data.quantity;

  if (newStock < 0) {
    throw new Error(
      `El ajuste resultaría en existencia negativa. Existencia actual: ${currentStock}`,
    );
  }

  const inventoryMovement = await prisma.$transaction(async (tx) => {
    const movement = await tx.inventoryMovement.create({
      data: {
        productId: data.productId,
        type: "ADJUSTMENT",
        location: data.location,
        quantity: data.quantity,
        userId,
        notes: data.notes,
      },
      include: {
        product: true,
        user: {
          select: {
            name: true,
          },
        },
      },
    });

    await tx.product.update({
      where: { id: data.productId },
      data: {
        [data.location === "WAREHOUSE" ? "warehouseStock" : "gymStock"]:
          newStock,
      },
    });

    return movement;
  });

  return serializeInventoryMovement(inventoryMovement) as AjusteCreado;
}

// ==================== QUERY SERVICES ====================

export async function getMovementsByProduct(
  productId: number,
  limit?: number,
): Promise<MovimientoInventarioResponse[]> {
  const movements = await prisma.inventoryMovement.findMany({
    where: { productId },
    include: {
      product: {
        select: {
          name: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { date: "desc" },
    take: limit,
  });

  return movements.map(serializeInventoryMovement);
}

export async function getMovementsByDate(
  params: GetMovementsByDateParams,
): Promise<MovimientoInventarioResponse[]> {
  const movements = await prisma.inventoryMovement.findMany({
    where: {
      date: {
        gte: params.startDate,
        lte: params.endDate,
      },
    },
    include: {
      product: {
        select: {
          name: true,
          salePrice: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { date: "desc" },
  });

  return movements.map(serializeInventoryMovement);
}

export async function getSalesByTicket(
  ticket: string,
): Promise<MovimientoInventarioResponse[]> {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      ticket,
      type: "SALE",
    },
    include: {
      product: {
        select: {
          name: true,
          salePrice: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { date: "asc" },
  });

  return sales.map(serializeInventoryMovement);
}

export async function getSalesByShift(
  shiftId: number,
): Promise<MovimientoInventarioResponse[]> {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      shiftId,
      type: "SALE",
    },
    include: {
      product: {
        select: {
          name: true,
          salePrice: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { date: "asc" },
  });

  return sales.map(serializeInventoryMovement);
}

export async function getCancelledSales(
  params?: GetCancelledSalesParams,
): Promise<MovimientoInventarioResponse[]> {
  const where: {
    type: InventoryType;
    isCancelled: boolean;
    cancellationDate?: { gte: Date; lte: Date };
  } = {
    type: "SALE",
    isCancelled: true,
  };

  if (params?.startDate && params?.endDate) {
    where.cancellationDate = {
      gte: params.startDate,
      lte: params.endDate,
    };
  }

  const sales = await prisma.inventoryMovement.findMany({
    where,
    include: {
      product: {
        select: {
          name: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { cancellationDate: "desc" },
  });

  return sales.map(serializeInventoryMovement);
}

--- FILE: services/products.service.ts ---

import { prisma } from "@/lib/db";
import { Location } from "@prisma/client";
import { mapLocation } from "./enum-mappers";
import { parseBooleanQuery, parseIntParam } from "./utils";
import {
  ProductsQuerySchema,
  CreateProductInputSchema,
  UpdateProductInputSchema,
} from "@/types/api/products";
import type {
  ProductoResponse,
  ProductoConMovimientosResponse,
  ProductoBajoStockResponse,
  StockProductoResponse,
  EstadisticasProductosResponse,
  ProductsQueryInput,
  CreateProductInputRaw,
  UpdateProductInputRaw,
  CrearProductoRequest,
  ActualizarProductoRequest,
} from "@/types/api/products";
import type { ProductoVentaResponse } from "@/types/api/sales";

function serializeProduct(product: {
  id: number;
  name: string;
  salePrice: import("@prisma/client/runtime/library").Decimal;
  warehouseStock: number;
  gymStock: number;
  minStock: number;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}): ProductoResponse {
  return {
    id: product.id,
    name: product.name,
    salePrice: Number(product.salePrice),
    warehouseStock: product.warehouseStock,
    gymStock: product.gymStock,
    minStock: product.minStock,
    isActive: product.isActive,
    createdAt: product.createdAt,
    updatedAt: product.updatedAt,
  };
}

export interface SearchProductsParams {
  search?: string;
  isActive?: boolean;
  lowStock?: boolean;
}

// ==================== PARSING HELPERS ====================

export function parseProductsQuery(
  raw: ProductsQueryInput,
): SearchProductsParams {
  const validated = ProductsQuerySchema.parse(raw);

  return {
    search: validated.search,
    isActive: parseBooleanQuery(validated.isActive),
    lowStock: parseBooleanQuery(validated.lowStock) ?? false,
  };
}

export function parseCreateProductInput(
  raw: CreateProductInputRaw,
): CrearProductoRequest {
  const validated = CreateProductInputSchema.parse(raw);

  return {
    name: validated.name,
    salePrice: validated.salePrice,
    minStock: validated.minStock,
  };
}

export function parseUpdateProductInput(
  raw: UpdateProductInputRaw,
): ActualizarProductoRequest {
  const validated = UpdateProductInputSchema.parse(raw);

  return {
    name: validated.name,
    salePrice: validated.salePrice,
    minStock: validated.minStock,
    isActive: validated.isActive,
  };
}

export function parseProductId(id: string): number {
  return parseIntParam(id, "ID de producto");
}

// ==================== SERVICE METHODS ====================

export async function getAllProducts(
  params?: SearchProductsParams,
): Promise<ProductoResponse[]> {
  const where: {
    name?: { contains: string; mode: "insensitive" };
    isActive?: boolean;
  } = {};

  if (params?.search) {
    where.name = {
      contains: params.search,
      mode: "insensitive",
    };
  }

  if (params?.isActive !== undefined) {
    where.isActive = params.isActive;
  }

  const products = await prisma.product.findMany({
    where,
    orderBy: { name: "asc" },
  });

  let result = products;

  if (params?.lowStock) {
    result = products.filter(
      (p) => p.gymStock < p.minStock || p.warehouseStock < p.minStock,
    );
  }

  return result.map(serializeProduct);
}

export async function getProductById(
  id: number,
): Promise<ProductoConMovimientosResponse> {
  const product = await prisma.product.findUnique({
    where: { id },
    include: {
      inventoryMovements: {
        orderBy: { date: "desc" },
        take: 20,
        include: {
          user: {
            select: {
              name: true,
            },
          },
          member: {
            select: {
              memberNumber: true,
              name: true,
            },
          },
        },
      },
    },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  return {
    ...serializeProduct(product),
    inventoryMovements: product.inventoryMovements.map((m) => ({
      id: m.id,
      type: m.type,
      location: mapLocation(m.location),
      quantity: m.quantity,
      ticket: m.ticket ?? undefined,
      unitPrice: m.unitPrice ? Number(m.unitPrice) : undefined,
      total: m.total ? Number(m.total) : undefined,
      notes: m.notes ?? undefined,
      isCancelled: m.isCancelled,
      date: m.date,
      user: {
        name: m.user.name,
      },
      member: m.member
        ? {
            memberNumber: m.member.memberNumber,
            name: m.member.name ?? undefined,
          }
        : undefined,
    })),
  };
}

export async function createProduct(
  data: CrearProductoRequest,
): Promise<ProductoResponse> {
  const existingProduct = await prisma.product.findUnique({
    where: { name: data.name },
  });

  if (existingProduct) {
    throw new Error("Ya existe un producto con ese nombre");
  }

  const product = await prisma.product.create({
    data: {
      name: data.name,
      salePrice: data.salePrice,
      minStock: data.minStock || 0,
    },
  });

  return serializeProduct(product);
}

export async function updateProduct(
  id: number,
  data: ActualizarProductoRequest,
): Promise<ProductoResponse> {
  const product = await prisma.product.findUnique({
    where: { id },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  if (data.name && data.name !== product.name) {
    const existingProduct = await prisma.product.findUnique({
      where: { name: data.name },
    });

    if (existingProduct) {
      throw new Error("Ya existe un producto con ese nombre");
    }
  }

  const updatedProduct = await prisma.product.update({
    where: { id },
    data,
  });

  return serializeProduct(updatedProduct);
}

export async function toggleProductStatus(
  id: number,
): Promise<ProductoResponse> {
  const product = await prisma.product.findUnique({
    where: { id },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  const updatedProduct = await prisma.product.update({
    where: { id },
    data: { isActive: !product.isActive },
  });

  return serializeProduct(updatedProduct);
}

export async function getActiveProducts(): Promise<ProductoResponse[]> {
  const products = await prisma.product.findMany({
    where: { isActive: true },
    orderBy: { name: "asc" },
  });

  return products.map(serializeProduct);
}

export async function getLowStockProducts(): Promise<
  ProductoBajoStockResponse[]
> {
  const products = await prisma.product.findMany({
    where: { isActive: true },
  });

  const result = products.filter(
    (p) => p.gymStock < p.minStock || p.warehouseStock < p.minStock,
  );

  return result.map((p) => ({
    id: p.id,
    name: p.name,
    gymStock: p.gymStock,
    warehouseStock: p.warehouseStock,
    minStock: p.minStock,
    stockFaltante: {
      gym: Math.max(0, p.minStock - p.gymStock),
      warehouse: Math.max(0, p.minStock - p.warehouseStock),
    },
  }));
}

export async function getProductStock(
  productId: number,
  location?: Location,
): Promise<StockProductoResponse | number> {
  const product = await prisma.product.findUnique({
    where: { id: productId },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  if (location === "WAREHOUSE") {
    return product.warehouseStock;
  } else if (location === "GYM") {
    return product.gymStock;
  }

  return {
    warehouse: product.warehouseStock,
    gym: product.gymStock,
    total: product.warehouseStock + product.gymStock,
  };
}

export async function getMembershipProducts(): Promise<ProductoResponse[]> {
  const keywords = ["EFECTIVO", "VISITA", "MENSUALIDAD", "SEMANA"];

  const products = await prisma.product.findMany({
    where: {
      isActive: true,
      OR: keywords.map((keyword) => ({
        name: { contains: keyword, mode: "insensitive" },
      })),
    },
    orderBy: { name: "asc" },
  });

  return products.map(serializeProduct);
}

export async function getSaleProducts(): Promise<ProductoVentaResponse[]> {
  const keywords = ["EFECTIVO", "VISITA", "MENSUALIDAD", "SEMANA"];

  const products = await prisma.product.findMany({
    where: {
      isActive: true,
      NOT: {
        OR: keywords.map((keyword) => ({
          name: { contains: keyword, mode: "insensitive" },
        })),
      },
    },
    orderBy: { name: "asc" },
  });

  return products.map((p) => ({
    id: p.id,
    name: p.name,
    salePrice: Number(p.salePrice),
    gymStock: p.gymStock,
    warehouseStock: p.warehouseStock,
    totalStock: p.gymStock + p.warehouseStock,
  }));
}

export async function getProductsStatistics(): Promise<EstadisticasProductosResponse> {
  const total = await prisma.product.count();
  const active = await prisma.product.count({ where: { isActive: true } });

  const products = await prisma.product.findMany({
    where: { isActive: true },
  });

  const lowStockGym = products.filter((p) => p.gymStock < p.minStock).length;
  const lowStockWarehouse = products.filter(
    (p) => p.warehouseStock < p.minStock,
  ).length;

  const inventoryValue = products.reduce((sum, p) => {
    const totalStock = p.warehouseStock + p.gymStock;
    return sum + Number(p.salePrice) * totalStock;
  }, 0);

  return {
    total,
    active,
    lowStockGym,
    lowStockWarehouse,
    inventoryValue,
  };
}

--- FILE: services/members.service.ts ---

import { prisma } from "@/lib/db";
import { MembershipType } from "@prisma/client";
import {
  mapMembershipType,
  parseMembershipType,
  mapMembershipTypeToApi,
  mapPaymentMethodFromApi,
} from "./enum-mappers";
import {
  parseISODate,
  parseBooleanQuery,
  calculateMembershipDates,
} from "./utils";
import {
  MembersQuerySchema,
  CreateMemberInputSchema,
  UpdateMemberInputSchema,
  RenewMemberInputSchema,
} from "@/types/api/members";
import type {
  SocioResponse,
  SocioConHistorialResponse,
  SocioVencidoResponse,
  VigenciaMembresiaResponse,
  MembersQueryInput,
  CreateMemberInputRaw,
  UpdateMemberInputRaw,
  RenewMemberInputRaw,
  CrearSocioRequest,
  ActualizarSocioRequest,
  RenovarMembresiaRequest,
} from "@/types/api/members";

function serializeMember(member: {
  id: number;
  memberNumber: string;
  name: string | null;
  phone: string | null;
  email: string | null;
  birthDate: Date | null;
  membershipType: MembershipType | null;
  membershipDescription: string | null;
  startDate: Date | null;
  endDate: Date | null;
  totalVisits: number;
  lastVisit: Date | null;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}): SocioResponse {
  return {
    id: member.id,
    memberNumber: member.memberNumber,
    name: member.name ?? undefined,
    phone: member.phone ?? undefined,
    email: member.email ?? undefined,
    birthDate: member.birthDate ?? undefined,
    membershipType: member.membershipType
      ? mapMembershipType(member.membershipType)
      : undefined,
    membershipDescription: member.membershipDescription ?? undefined,
    startDate: member.startDate ?? undefined,
    endDate: member.endDate ?? undefined,
    totalVisits: member.totalVisits,
    lastVisit: member.lastVisit ?? undefined,
    isActive: member.isActive,
    createdAt: member.createdAt,
    updatedAt: member.updatedAt,
  };
}

export interface SearchMembersParams {
  search?: string;
  isActive?: boolean;
  membershipType?: MembershipType;
}

// ==================== PARSING HELPERS ====================

export function parseMembersQuery(raw: MembersQueryInput): SearchMembersParams {
  const validated = MembersQuerySchema.parse(raw);

  return {
    search: validated.search,
    isActive: parseBooleanQuery(validated.isActive),
    membershipType: parseMembershipType(validated.membershipType),
  };
}

export function parseCreateMemberInput(
  raw: CreateMemberInputRaw,
): CrearSocioRequest {
  const validated = CreateMemberInputSchema.parse(raw);

  const parsedMembershipType = parseMembershipType(validated.membershipType);

  return {
    memberNumber: validated.memberNumber,
    name: validated.name,
    phone: validated.phone,
    email: validated.email,
    birthDate: validated.birthDate,
    membershipType: parsedMembershipType
      ? mapMembershipTypeToApi(parsedMembershipType)
      : undefined,
    membershipDescription: validated.membershipDescription,
    startDate: validated.startDate,
    endDate: validated.endDate,
    paymentMethod: validated.paymentMethod
      ? mapPaymentMethodFromApi(validated.paymentMethod)
      : undefined,
  };
}

export function parseUpdateMemberInput(
  raw: UpdateMemberInputRaw,
): ActualizarSocioRequest {
  const validated = UpdateMemberInputSchema.parse(raw);

  const parsedMembershipType = parseMembershipType(validated.membershipType);

  return {
    name: validated.name,
    phone: validated.phone,
    email: validated.email,
    birthDate: validated.birthDate,
    membershipType: parsedMembershipType
      ? mapMembershipTypeToApi(parsedMembershipType)
      : undefined,
    membershipDescription: validated.membershipDescription,
    startDate: validated.startDate,
    endDate: validated.endDate,
    isActive: validated.isActive,
  };
}

export function parseRenewMemberInput(
  raw: RenewMemberInputRaw,
): RenovarMembresiaRequest {
  const validated = RenewMemberInputSchema.parse(raw);

  const membershipType = parseMembershipType(validated.membershipType);
  if (!membershipType) {
    throw new Error("membershipType is required for renewal");
  }

  return {
    memberId: validated.memberId,
    membershipType: mapMembershipTypeToApi(membershipType),
    membershipDescription: validated.membershipDescription,
    startDate: validated.startDate,
    paymentMethod: validated.paymentMethod
      ? mapPaymentMethodFromApi(validated.paymentMethod)
      : undefined,
  };
}

// ==================== SERVICE METHODS ====================

export async function getAllMembers(
  params?: SearchMembersParams,
): Promise<SocioResponse[]> {
  const where: {
    OR?: Array<{
      memberNumber?: { contains: string; mode: "insensitive" };
      name?: { contains: string; mode: "insensitive" };
      phone?: { contains: string; mode: "insensitive" };
      email?: { contains: string; mode: "insensitive" };
    }>;
    isActive?: boolean;
    membershipType?: MembershipType;
  } = {};

  if (params?.search) {
    where.OR = [
      { memberNumber: { contains: params.search, mode: "insensitive" } },
      { name: { contains: params.search, mode: "insensitive" } },
      { phone: { contains: params.search, mode: "insensitive" } },
      { email: { contains: params.search, mode: "insensitive" } },
    ];
  }

  if (params?.isActive !== undefined) {
    where.isActive = params.isActive;
  }

  if (params?.membershipType) {
    where.membershipType = params.membershipType;
  }

  const members = await prisma.member.findMany({
    where,
    orderBy: { createdAt: "desc" },
  });

  return members.map(serializeMember);
}

export async function getMemberById(
  id: number,
): Promise<SocioConHistorialResponse> {
  const member = await prisma.member.findUnique({
    where: { id },
    include: {
      inventoryMovements: {
        where: { type: "SALE", isCancelled: false },
        orderBy: { date: "desc" },
        take: 20,
        include: {
          product: {
            select: {
              name: true,
              salePrice: true,
            },
          },
        },
      },
    },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  return {
    ...serializeMember(member),
    inventoryMovements: member.inventoryMovements.map((m) => ({
      id: m.id,
      type: m.type,
      quantity: m.quantity,
      total: m.total ? Number(m.total) : 0,
      date: m.date,
      product: {
        name: m.product.name,
        salePrice: Number(m.product.salePrice),
      },
    })),
  };
}

export async function getMemberByNumber(
  memberNumber: string,
): Promise<SocioConHistorialResponse> {
  const member = await prisma.member.findUnique({
    where: { memberNumber },
    include: {
      inventoryMovements: {
        where: { type: "SALE", isCancelled: false },
        orderBy: { date: "desc" },
        take: 5,
        include: {
          product: {
            select: {
              name: true,
              salePrice: true,
            },
          },
        },
      },
    },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  return {
    ...serializeMember(member),
    inventoryMovements: member.inventoryMovements.map((m) => ({
      id: m.id,
      type: m.type,
      quantity: m.quantity,
      total: m.total ? Number(m.total) : 0,
      date: m.date,
      product: {
        name: m.product.name,
        salePrice: Number(m.product.salePrice),
      },
    })),
  };
}

export async function createMember(
  data: CrearSocioRequest,
  userId: string,
): Promise<SocioResponse> {
  const existingMember = await prisma.member.findUnique({
    where: { memberNumber: data.memberNumber },
  });

  if (existingMember) {
    throw new Error("El número de socio ya existe");
  }

  const member = await prisma.member.create({
    data: {
      memberNumber: data.memberNumber,
      name: data.name,
      phone: data.phone,
      email: data.email,
      birthDate: data.birthDate ? parseISODate(data.birthDate) : undefined,
      membershipType: data.membershipType
        ? parseMembershipType(data.membershipType)
        : undefined,
      membershipDescription: data.membershipDescription,
      startDate: data.startDate ? parseISODate(data.startDate) : undefined,
      endDate: data.endDate ? parseISODate(data.endDate) : undefined,
    },
  });

  if (data.membershipType && userId) {
    const keywordMap: Record<string, string> = {
      MONTH_STUDENT: "MENSUALIDAD ESTUDIANTE",
      MONTH_GENERAL: "MENSUALIDAD GENERAL",
      WEEK: "SEMANA",
      VISIT: "VISITA",
      QUARTER_STUDENT: "TRIMESTRE ESTUDIANTE",
      QUARTER_GENERAL: "TRIMESTRE GENERAL",
      ANNUAL_STUDENT: "ANUAL ESTUDIANTE",
      ANNUAL_GENERAL: "ANUAL GENERAL",
      PROMOTION: "PROMOCION",
      REBIRTH: "RENACER",
    };

    const keyword = keywordMap[data.membershipType] || data.membershipType;

    const product = await prisma.product.findFirst({
      where: {
        name: { contains: keyword, mode: "insensitive" },
        isActive: true,
      },
    });

    if (product) {
      const activeShift = await prisma.shift.findFirst({
        where: { closingDate: null },
      });

      const timestamp = Date.now().toString().slice(-6);
      const random = Math.floor(Math.random() * 100)
        .toString()
        .padStart(2, "0");
      const ticket = `NEW${timestamp}${random}`;

      await prisma.inventoryMovement.create({
        data: {
          productId: product.id,
          type: "SALE",
          location: "GYM",
          quantity: -1,
          ticket,
          memberId: member.id,
          userId,
          unitPrice: product.salePrice,
          subtotal: product.salePrice,
          discount: 0,
          surcharge: 0,
          total: product.salePrice,
          paymentMethod: data.paymentMethod
            ? mapPaymentMethodFromApi(data.paymentMethod)
            : "CASH",
          shiftId: activeShift?.id,
          notes: `Alta de socio: ${data.membershipDescription || data.membershipType}`,
        },
      });
    }
  }

  return serializeMember(member);
}

export async function updateMember(
  id: number,
  data: ActualizarSocioRequest,
): Promise<SocioResponse> {
  const member = await prisma.member.findUnique({
    where: { id },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  const updatedMember = await prisma.member.update({
    where: { id },
    data: {
      name: data.name,
      phone: data.phone,
      email: data.email,
      birthDate: data.birthDate ? parseISODate(data.birthDate) : undefined,
      membershipType: data.membershipType
        ? parseMembershipType(data.membershipType)
        : undefined,
      membershipDescription: data.membershipDescription,
      startDate: data.startDate ? parseISODate(data.startDate) : undefined,
      endDate: data.endDate ? parseISODate(data.endDate) : undefined,
      isActive: data.isActive,
    },
  });

  return serializeMember(updatedMember);
}

export async function toggleMemberStatus(id: number): Promise<SocioResponse> {
  const member = await prisma.member.findUnique({
    where: { id },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  const updatedMember = await prisma.member.update({
    where: { id },
    data: { isActive: !member.isActive },
  });

  return serializeMember(updatedMember);
}

export async function registerVisit(memberId: number): Promise<SocioResponse> {
  const member = await prisma.member.findUnique({
    where: { id: memberId },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  if (!member.isActive) {
    throw new Error("El socio no está activo");
  }

  const updatedMember = await prisma.member.update({
    where: { id: memberId },
    data: {
      totalVisits: { increment: 1 },
      lastVisit: new Date(),
    },
  });

  return serializeMember(updatedMember);
}

export async function getActiveMembers(): Promise<SocioResponse[]> {
  const members = await prisma.member.findMany({
    where: { isActive: true },
    orderBy: { name: "asc" },
  });

  return members.map(serializeMember);
}

export async function getMembersExpiringSoon(
  days: number = 7,
): Promise<SocioResponse[]> {
  const today = new Date();
  const limitDate = new Date();
  limitDate.setDate(limitDate.getDate() + days);

  const members = await prisma.member.findMany({
    where: {
      isActive: true,
      endDate: {
        gte: today,
        lte: limitDate,
      },
      membershipType: {
        not: "VISIT",
      },
    },
    orderBy: { endDate: "asc" },
  });

  return members.map(serializeMember);
}

export async function getMembersStatistics(): Promise<{
  total: number;
  active: number;
  inactive: number;
  byType: Array<{ membershipType: MembershipType | null; _count: number }>;
}> {
  const total = await prisma.member.count();
  const active = await prisma.member.count({ where: { isActive: true } });
  const inactive = await prisma.member.count({ where: { isActive: false } });

  const byType = await prisma.member.groupBy({
    by: ["membershipType"],
    where: { isActive: true },
    _count: true,
  });

  return {
    total,
    active,
    inactive,
    byType,
  };
}

export async function renewMembership(
  data: RenovarMembresiaRequest,
  userId: string,
): Promise<SocioResponse> {
  const member = await prisma.member.findUnique({
    where: { id: data.memberId },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  const prismaType = parseMembershipType(data.membershipType);
  if (!prismaType) {
    throw new Error("membershipType is required for renewal");
  }

  const dates = calculateMembershipDates(
    prismaType,
    data.startDate ? parseISODate(data.startDate) : undefined,
  );

  const keywordMap: Record<string, string> = {
    MONTH_STUDENT: "MENSUALIDAD ESTUDIANTE",
    MONTH_GENERAL: "MENSUALIDAD GENERAL",
    WEEK: "SEMANA",
    VISIT: "VISITA",
    QUARTER_STUDENT: "TRIMESTRE ESTUDIANTE",
    QUARTER_GENERAL: "TRIMESTRE GENERAL",
    ANNUAL_STUDENT: "ANUAL ESTUDIANTE",
    ANNUAL_GENERAL: "ANUAL GENERAL",
    PROMOTION: "PROMOCION",
    REBIRTH: "RENACER",
  };

  const keyword = keywordMap[data.membershipType] || data.membershipType;

  const product = await prisma.product.findFirst({
    where: {
      name: { contains: keyword, mode: "insensitive" },
      isActive: true,
    },
  });

  if (!product) {
    throw new Error(
      `No se encontró producto para membresía: ${data.membershipType}`,
    );
  }

  const activeShift = await prisma.shift.findFirst({
    where: { closingDate: null },
  });

  const timestamp = Date.now().toString().slice(-6);
  const random = Math.floor(Math.random() * 100)
    .toString()
    .padStart(2, "0");
  const ticket = `REN${timestamp}${random}`;

  const updatedMember = await prisma.$transaction(async (tx) => {
    const renewed = await tx.member.update({
      where: { id: data.memberId },
      data: {
        membershipType: prismaType,
        membershipDescription: data.membershipDescription,
        startDate: dates.startDate,
        endDate: dates.endDate,
        isActive: true,
        totalVisits: { increment: 1 },
        lastVisit: new Date(),
      },
    });

    await tx.inventoryMovement.create({
      data: {
        productId: product.id,
        type: "SALE",
        location: "GYM",
        quantity: -1,
        ticket,
        memberId: data.memberId,
        userId,
        unitPrice: product.salePrice,
        subtotal: product.salePrice,
        discount: 0,
        surcharge: 0,
        total: product.salePrice,
        paymentMethod: data.paymentMethod
          ? mapPaymentMethodFromApi(data.paymentMethod)
          : "CASH",
        shiftId: activeShift?.id,
        notes: `Renovación: ${data.membershipDescription || data.membershipType}`,
      },
    });

    return renewed;
  });

  return serializeMember(updatedMember);
}

export async function getExpiredMembers(): Promise<SocioVencidoResponse[]> {
  const today = new Date();

  const members = await prisma.member.findMany({
    where: {
      isActive: true,
      endDate: {
        lt: today,
      },
      membershipType: {
        not: "VISIT",
      },
    },
    orderBy: { endDate: "desc" },
  });

  return members.map((m) => {
    const serialized = serializeMember(m);
    const daysExpired = m.endDate
      ? Math.floor(
          (today.getTime() - m.endDate.getTime()) / (1000 * 60 * 60 * 24),
        )
      : 0;

    return {
      id: serialized.id,
      memberNumber: serialized.memberNumber,
      name: serialized.name,
      membershipType: serialized.membershipType,
      endDate: serialized.endDate,
      daysExpired,
    };
  });
}

export async function verifyMembershipValidity(
  memberId: number,
): Promise<VigenciaMembresiaResponse> {
  const member = await prisma.member.findUnique({
    where: { id: memberId },
  });

  if (!member || !member.endDate || member.membershipType === "VISIT") {
    return {
      isValid: false,
      daysRemaining: 0,
      endDate: null,
    };
  }

  const today = new Date();
  const endDate = new Date(member.endDate);
  const difference = endDate.getTime() - today.getTime();
  const daysRemaining = Math.ceil(difference / (1000 * 60 * 60 * 24));

  return {
    isValid: daysRemaining > 0,
    daysRemaining: Math.max(0, daysRemaining),
    endDate,
  };
}

--- FILE: services/enum-mappers.ts ---

// services/enum-mappers.ts
import type {
  InventoryType,
  Location,
  PaymentMethod,
  MembershipType,
} from "@prisma/client";
import {
  TipoInventario,
  Ubicacion,
  MetodoPago,
  TipoMembresia,
} from "@/types/models";

// ==================== INVENTORY TYPE MAPPING ====================

export function mapInventoryType(type: InventoryType): TipoInventario {
  switch (type) {
    case "SALE":
      return TipoInventario.SALE;
    case "ADJUSTMENT":
      return TipoInventario.ADJUSTMENT;
    case "WAREHOUSE_ENTRY":
      return TipoInventario.WAREHOUSE_ENTRY;
    case "GYM_ENTRY":
      return TipoInventario.GYM_ENTRY;
    case "TRANSFER_TO_GYM":
      return TipoInventario.TRANSFER_TO_GYM;
    case "TRANSFER_TO_WAREHOUSE":
      return TipoInventario.TRANSFER_TO_WAREHOUSE;
    default:
      throw new Error(`Unknown InventoryType: ${type}`);
  }
}

// ==================== LOCATION MAPPING ====================

export function mapLocation(location: Location): Ubicacion {
  switch (location) {
    case "WAREHOUSE":
      return Ubicacion.WAREHOUSE;
    case "GYM":
      return Ubicacion.GYM;
    default:
      throw new Error(`Unknown Location: ${location}`);
  }
}

// ==================== PAYMENT METHOD MAPPING ====================

export function mapPaymentMethod(method: PaymentMethod): MetodoPago {
  switch (method) {
    case "CASH":
      return MetodoPago.CASH;
    case "DEBIT_CARD":
      return MetodoPago.DEBIT_CARD;
    case "CREDIT_CARD":
      return MetodoPago.CREDIT_CARD;
    case "TRANSFER":
      return MetodoPago.TRANSFER;
    default:
      throw new Error(`Unknown PaymentMethod: ${method}`);
  }
}

/**
 * Convert API PaymentMethod string to API MetodoPago enum
 */
export function mapPaymentMethodFromApi(method: string): MetodoPago {
  switch (method) {
    case "CASH":
      return MetodoPago.CASH;
    case "DEBIT_CARD":
      return MetodoPago.DEBIT_CARD;
    case "CREDIT_CARD":
      return MetodoPago.CREDIT_CARD;
    case "TRANSFER":
      return MetodoPago.TRANSFER;
    default:
      throw new Error(`Unknown PaymentMethod: ${method}`);
  }
}

// ==================== MEMBERSHIP TYPE MAPPING ====================

export function mapMembershipType(type: MembershipType): TipoMembresia {
  switch (type) {
    case "VISIT":
      return TipoMembresia.VISIT;
    case "WEEK":
      return TipoMembresia.WEEK;
    case "MONTH_STUDENT":
      return TipoMembresia.MONTH_STUDENT;
    case "MONTH_GENERAL":
      return TipoMembresia.MONTH_GENERAL;
    case "QUARTER_STUDENT":
      return TipoMembresia.QUARTER_STUDENT;
    case "QUARTER_GENERAL":
      return TipoMembresia.QUARTER_GENERAL;
    case "ANNUAL_STUDENT":
      return TipoMembresia.ANNUAL_STUDENT;
    case "ANNUAL_GENERAL":
      return TipoMembresia.ANNUAL_GENERAL;
    case "PROMOTION":
      return TipoMembresia.PROMOTION;
    case "REBIRTH":
      return TipoMembresia.REBIRTH;
    case "NUTRITION_CONSULTATION":
      return TipoMembresia.NUTRITION_CONSULTATION;
    default:
      throw new Error(`Unknown MembershipType: ${type}`);
  }
}

/**
 * Convert API TipoMembresia to Prisma MembershipType enum
 */
export function mapMembershipTypeToApi(type: MembershipType): TipoMembresia {
  return mapMembershipType(type);
}

/**
 * Convert API TipoMembresia string to Prisma MembershipType enum
 */
export function mapMembershipTypeFromApi(type: string): MembershipType {
  switch (type) {
    case "VISIT":
      return "VISIT";
    case "WEEK":
      return "WEEK";
    case "MONTH_STUDENT":
      return "MONTH_STUDENT";
    case "MONTH_GENERAL":
      return "MONTH_GENERAL";
    case "QUARTER_STUDENT":
      return "QUARTER_STUDENT";
    case "QUARTER_GENERAL":
      return "QUARTER_GENERAL";
    case "ANNUAL_STUDENT":
      return "ANNUAL_STUDENT";
    case "ANNUAL_GENERAL":
      return "ANNUAL_GENERAL";
    case "PROMOTION":
      return "PROMOTION";
    case "REBIRTH":
      return "REBIRTH";
    case "NUTRITION_CONSULTATION":
      return "NUTRITION_CONSULTATION";
    default:
      throw new Error(`Unknown membership type: ${type}`);
  }
}

// ==================== MEMBERSHIP TYPE PARSING ====================

/**
 * Parse and validate membership type string to MembershipType enum
 */
export function parseMembershipType(
  type: string | undefined,
): MembershipType | undefined {
  if (!type) return undefined;

  const normalized = type.toUpperCase();
  const validTypes: MembershipType[] = [
    "VISIT",
    "WEEK",
    "MONTH_STUDENT",
    "MONTH_GENERAL",
    "QUARTER_STUDENT",
    "QUARTER_GENERAL",
    "ANNUAL_STUDENT",
    "ANNUAL_GENERAL",
    "PROMOTION",
    "REBIRTH",
    "NUTRITION_CONSULTATION",
  ];

  if (validTypes.includes(normalized as MembershipType)) {
    return normalized as MembershipType;
  }

  throw new Error(`Invalid membership type: ${type}`);
}

--- FILE: services/reports.service.ts ---

import { prisma } from "@/lib/db";
import {
  ReportPeriodQuerySchema,
  DashboardQuerySchema,
} from "@/types/api/reports";
import type {
  ReporteVentasPorProducto,
  ReporteVentasDiarias,
  ReporteStockActual,
  ResumenDashboard,
  ReportPeriodQueryInput,
  DashboardQueryInput,
} from "@/types/api/reports";
import { getLowStockProducts } from "./products.service";

export interface ReportPeriodParams {
  startDate: Date;
  endDate: Date;
}

export interface DashboardParams {
  startDate?: Date;
  endDate?: Date;
}

function formatDate(date: Date): string {
  return date.toISOString().split("T")[0];
}

// ==================== PARSING HELPERS ====================

export function parseReportPeriodQuery(
  raw: ReportPeriodQueryInput,
): ReportPeriodParams {
  const validated = ReportPeriodQuerySchema.parse(raw);

  const startDate = new Date(validated.startDate);
  const endDate = new Date(validated.endDate);

  if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
    throw new Error("Fechas inválidas");
  }

  return { startDate, endDate };
}

export function parseDashboardQuery(raw: DashboardQueryInput): DashboardParams {
  const validated = DashboardQuerySchema.parse(raw);

  return {
    startDate: validated.startDate ? new Date(validated.startDate) : undefined,
    endDate: validated.endDate ? new Date(validated.endDate) : undefined,
  };
}

// ==================== REPORT SERVICES ====================

export async function getSalesReportByProduct(
  params: ReportPeriodParams,
): Promise<ReporteVentasPorProducto[]> {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      type: "SALE",
      date: {
        gte: params.startDate,
        lte: params.endDate,
      },
    },
    include: {
      product: {
        select: {
          id: true,
          name: true,
        },
      },
    },
  });

  const reportByProduct = sales.reduce(
    (acc, sale) => {
      const id = sale.product.id;
      if (!acc[id]) {
        acc[id] = {
          productId: id,
          productName: sale.product.name,
          quantitySold: 0,
          totalSales: 0,
          quantityCancelled: 0,
          totalCancelled: 0,
        };
      }

      const quantity = Math.abs(sale.quantity);
      const total = Number(sale.total || 0);

      if (sale.isCancelled) {
        acc[id].quantityCancelled += quantity;
        acc[id].totalCancelled += total;
      } else {
        acc[id].quantitySold += quantity;
        acc[id].totalSales += total;
      }

      return acc;
    },
    {} as Record<number, ReporteVentasPorProducto>,
  );

  return Object.values(reportByProduct).sort(
    (a, b) => b.totalSales - a.totalSales,
  );
}

export async function getDailySalesReport(
  params: ReportPeriodParams,
): Promise<ReporteVentasDiarias[]> {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      type: "SALE",
      date: {
        gte: params.startDate,
        lte: params.endDate,
      },
    },
  });

  const salesByDay = sales.reduce(
    (acc, sale) => {
      const date = formatDate(sale.date);
      if (!acc[date]) {
        acc[date] = {
          date,
          tickets: new Set<string>(),
          totalSales: 0,
          totalCancelled: 0,
        };
      }

      if (sale.ticket) {
        acc[date].tickets.add(sale.ticket);
      }

      const total = Number(sale.total || 0);

      if (sale.isCancelled) {
        acc[date].totalCancelled += total;
      } else {
        acc[date].totalSales += total;
      }

      return acc;
    },
    {} as Record<
      string,
      {
        date: string;
        tickets: Set<string>;
        totalSales: number;
        totalCancelled: number;
      }
    >,
  );

  return Object.values(salesByDay)
    .map((day) => ({
      date: day.date,
      ticketCount: day.tickets.size,
      totalSales: day.totalSales,
      totalCancelled: day.totalCancelled,
    }))
    .sort((a, b) => a.date.localeCompare(b.date));
}

export async function getCurrentStockReport(): Promise<ReporteStockActual> {
  const products = await prisma.product.findMany({
    where: { isActive: true },
    orderBy: { name: "asc" },
  });

  const stockSummary = products.reduce(
    (acc, p) => {
      acc.warehouse += p.warehouseStock;
      acc.gym += p.gymStock;
      acc.total += p.warehouseStock + p.gymStock;
      acc.totalValue += Number(p.salePrice) * (p.warehouseStock + p.gymStock);
      return acc;
    },
    { warehouse: 0, gym: 0, total: 0, totalValue: 0 },
  );

  const lowStock = await getLowStockProducts();

  return {
    products: products.map((p) => ({
      id: p.id,
      name: p.name,
      warehouseStock: p.warehouseStock,
      gymStock: p.gymStock,
      minStock: p.minStock,
      salePrice: Number(p.salePrice),
    })),
    stockSummary,
    lowStock,
  };
}

export async function getDashboardSummary(
  params?: DashboardParams,
): Promise<ResumenDashboard> {
  const startDate =
    params?.startDate || new Date(new Date().setHours(0, 0, 0, 0));
  const endDate =
    params?.endDate || new Date(new Date().setHours(23, 59, 59, 999));

  const [salesToday, activeMembers, activeProducts, activeShift] =
    await Promise.all([
      prisma.inventoryMovement.findMany({
        where: {
          type: "SALE",
          isCancelled: false,
          date: {
            gte: startDate,
            lte: endDate,
          },
        },
      }),
      prisma.member.count({ where: { isActive: true } }),
      prisma.product.count({ where: { isActive: true } }),
      prisma.shift.findFirst({
        where: { closingDate: null },
        include: {
          cashier: {
            select: {
              name: true,
            },
          },
        },
      }),
    ]);

  const totalSalesToday = salesToday.reduce(
    (sum, v) => sum + Number(v.total || 0),
    0,
  );

  const ticketsToday = new Set(salesToday.map((v) => v.ticket)).size;

  const productsLowStock = await prisma.product.count({
    where: {
      isActive: true,
      OR: [
        { gymStock: { lt: prisma.product.fields.minStock } },
        { warehouseStock: { lt: prisma.product.fields.minStock } },
      ],
    },
  });

  return {
    salesToday: {
      total: totalSalesToday,
      tickets: ticketsToday,
      quantity: salesToday.length,
    },
    members: {
      active: activeMembers,
    },
    products: {
      active: activeProducts,
      lowStock: productsLowStock,
    },
    activeShift: activeShift
      ? {
          id: activeShift.id,
          folio: activeShift.folio,
          cashier: {
            name: activeShift.cashier.name,
          },
          openingDate: activeShift.openingDate,
          initialCash: Number(activeShift.initialCash),
        }
      : undefined,
  };
}

--- FILE: services/utils.ts ---

import { Decimal } from "@prisma/client/runtime/library";
import { MembershipType } from "@prisma/client";

export function serializeDecimal(value: unknown): unknown {
  return JSON.parse(
    JSON.stringify(value, (_key, val) => {
      if (val instanceof Decimal) {
        return Number(val.toString());
      }
      if (val instanceof Date) {
        return val.toISOString();
      }
      return val;
    }),
  );
}

/**
 * Parse ISO date string to Date object
 */
export function parseISODate(dateString: string | undefined): Date | undefined {
  if (!dateString) return undefined;
  return new Date(dateString);
}

/**
 * Parse boolean from query string
 */
export function parseBooleanQuery(
  value: string | undefined,
): boolean | undefined {
  if (value === "true") return true;
  if (value === "false") return false;
  return undefined;
}

/**
 * Parse and validate integer parameter (e.g., from URL params)
 */
export function parseIntParam(value: string, paramName: string = "ID"): number {
  const parsed = parseInt(value, 10);
  if (isNaN(parsed)) {
    throw new Error(`${paramName} inválido`);
  }
  return parsed;
}

/**
 * Calculate end date based on membership type
 */
function calculateEndDate(
  startDate: Date,
  membershipType: MembershipType,
): Date {
  const date = new Date(startDate);

  switch (membershipType) {
    case "VISIT":
      return date;
    case "WEEK":
      date.setDate(date.getDate() + 7);
      break;
    case "MONTH_STUDENT":
    case "MONTH_GENERAL":
      date.setMonth(date.getMonth() + 1);
      break;
    case "QUARTER_STUDENT":
    case "QUARTER_GENERAL":
      date.setMonth(date.getMonth() + 3);
      break;
    case "ANNUAL_STUDENT":
    case "ANNUAL_GENERAL":
      date.setFullYear(date.getFullYear() + 1);
      break;
    case "PROMOTION":
    case "REBIRTH":
    case "NUTRITION_CONSULTATION":
      date.setMonth(date.getMonth() + 1);
      break;
  }

  return date;
}

/**
 * Calculate membership start and end dates
 */
export function calculateMembershipDates(
  membershipType: MembershipType,
  startDate?: Date,
): { startDate: Date; endDate: Date } {
  const start = startDate || new Date();
  const end = calculateEndDate(start, membershipType);

  return {
    startDate: start,
    endDate: end,
  };
}

--- FILE: services/users.service.ts ---

import { prisma } from "@/lib/db";
import { Role } from "@prisma/client";

interface UserResponse {
  id: string;
  name: string;
  email: string;
  role: Role;
  isActive: boolean;
  createdAt?: Date;
  updatedAt?: Date;
}

function validateAdminRole(userRole: Role): void {
  if (userRole !== "ADMIN") {
    throw new Error("No tienes permisos para realizar esta operación");
  }
}

export async function getAllUsers(): Promise<UserResponse[]> {
  return await prisma.user.findMany({
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      isActive: true,
      createdAt: true,
      updatedAt: true,
    },
    orderBy: { createdAt: "desc" },
  });
}

export async function getUserById(userId: string): Promise<UserResponse> {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      isActive: true,
      createdAt: true,
      updatedAt: true,
    },
  });

  if (!user) {
    throw new Error("Usuario no encontrado");
  }

  return user;
}

export async function createUser(
  data: {
    name: string;
    email: string;
    role?: Role;
    password: string;
  },
  currentUserRole: Role,
): Promise<UserResponse> {
  validateAdminRole(currentUserRole);

  const existingUser = await prisma.user.findUnique({
    where: { email: data.email },
  });

  if (existingUser) {
    throw new Error("El correo electrónico ya está registrado");
  }

  const userId = `user_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;

  const user = await prisma.user.create({
    data: {
      id: userId,
      name: data.name,
      email: data.email,
      role: data.role || "EMPLEADO",
      emailVerified: true,
    },
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      isActive: true,
    },
  });

  return user;
}

export async function updateUser(
  userId: string,
  data: {
    name?: string;
    email?: string;
    role?: Role;
    isActive?: boolean;
  },
  currentUserRole: Role,
): Promise<UserResponse> {
  validateAdminRole(currentUserRole);

  const user = await prisma.user.findUnique({
    where: { id: userId },
  });

  if (!user) {
    throw new Error("Usuario no encontrado");
  }

  if (data.email && data.email !== user.email) {
    const existingUser = await prisma.user.findUnique({
      where: { email: data.email },
    });

    if (existingUser) {
      throw new Error("El correo electrónico ya está registrado");
    }
  }

  const updatedUser = await prisma.user.update({
    where: { id: userId },
    data,
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      isActive: true,
      updatedAt: true,
    },
  });

  return updatedUser;
}

export async function toggleUserStatus(
  userId: string,
  currentUserRole: Role,
): Promise<UserResponse> {
  validateAdminRole(currentUserRole);

  const user = await prisma.user.findUnique({
    where: { id: userId },
  });

  if (!user) {
    throw new Error("Usuario no encontrado");
  }

  const updatedUser = await prisma.user.update({
    where: { id: userId },
    data: { isActive: !user.isActive },
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      isActive: true,
    },
  });

  return updatedUser;
}

export async function getActiveUsers(): Promise<UserResponse[]> {
  return await prisma.user.findMany({
    where: { isActive: true },
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      isActive: true,
    },
    orderBy: { name: "asc" },
  });
}

--- FILE: services/shifts.service.ts ---

import { prisma } from "@/lib/db";
import { mapPaymentMethod } from "./enum-mappers";
import { parseISODate, parseIntParam } from "./utils";
import { ShiftsQuerySchema, CloseShiftSchema } from "@/types/api/shifts";
import type {
  CorteResponse,
  CorteConVentasResponse,
  EstadisticasCortesResponse,
  ResumenVentasPorProducto,
  ResumenPorFormaPago,
  ResumenCorteResponse,
  ListaCortesResponse,
  ShiftsQueryInput,
  CloseShiftInput,
  AbrirCorteRequest,
} from "@/types/api/shifts";

export interface GetShiftsParams {
  search?: string;
  startDate?: Date;
  endDate?: Date;
  cashier?: string;
  status?: string;
  orderBy?: string;
  order?: string;
  page?: number;
  perPage?: number;
}

function serializeShift(shift: {
  id: number;
  folio: string;
  cashierId: string;
  openingDate: Date;
  closingDate: Date | null;
  initialCash: import("@prisma/client/runtime/library").Decimal;
  ticketCount: number;
  membershipSales: import("@prisma/client/runtime/library").Decimal;
  productSales0Tax: import("@prisma/client/runtime/library").Decimal;
  productSales16Tax: import("@prisma/client/runtime/library").Decimal;
  subtotal: import("@prisma/client/runtime/library").Decimal;
  tax: import("@prisma/client/runtime/library").Decimal;
  totalSales: import("@prisma/client/runtime/library").Decimal;
  cashAmount: import("@prisma/client/runtime/library").Decimal;
  debitCardAmount: import("@prisma/client/runtime/library").Decimal;
  creditCardAmount: import("@prisma/client/runtime/library").Decimal;
  totalVoucher: import("@prisma/client/runtime/library").Decimal;
  totalWithdrawals: import("@prisma/client/runtime/library").Decimal;
  withdrawalsConcept: string | null;
  cancelledSales: import("@prisma/client/runtime/library").Decimal;
  totalCash: import("@prisma/client/runtime/library").Decimal;
  difference: import("@prisma/client/runtime/library").Decimal;
  notes: string | null;
  createdAt: Date;
  updatedAt: Date;
  cashier: { id: string; name: string; email: string };
}): CorteResponse {
  return {
    id: shift.id,
    folio: shift.folio,
    cashierId: shift.cashierId,
    openingDate: shift.openingDate,
    closingDate: shift.closingDate ?? undefined,
    initialCash: Number(shift.initialCash),
    ticketCount: shift.ticketCount,
    membershipSales: Number(shift.membershipSales),
    productSales0Tax: Number(shift.productSales0Tax),
    productSales16Tax: Number(shift.productSales16Tax),
    subtotal: Number(shift.subtotal),
    tax: Number(shift.tax),
    totalSales: Number(shift.totalSales),
    cashAmount: Number(shift.cashAmount),
    debitCardAmount: Number(shift.debitCardAmount),
    creditCardAmount: Number(shift.creditCardAmount),
    totalVoucher: Number(shift.totalVoucher),
    totalWithdrawals: Number(shift.totalWithdrawals),
    withdrawalsConcept: shift.withdrawalsConcept ?? undefined,
    cancelledSales: Number(shift.cancelledSales),
    totalCash: Number(shift.totalCash),
    difference: Number(shift.difference),
    notes: shift.notes ?? undefined,
    createdAt: shift.createdAt,
    updatedAt: shift.updatedAt,
    cashier: shift.cashier,
  };
}

async function validateNoOpenShift(cashierId: string): Promise<void> {
  const openShift = await prisma.shift.findFirst({
    where: {
      cashierId,
      closingDate: null,
    },
  });

  if (openShift) {
    throw new Error("Ya tienes un corte abierto");
  }
}

async function validateNoSystemOpenShift(): Promise<void> {
  const openShift = await prisma.shift.findFirst({
    where: {
      closingDate: null,
    },
  });

  if (openShift) {
    throw new Error("Ya existe un corte abierto en el sistema");
  }
}

// ==================== PARSING HELPERS ====================

export function parseShiftsQuery(raw: ShiftsQueryInput): GetShiftsParams {
  const validated = ShiftsQuerySchema.parse(raw);

  return {
    search: validated.search,
    startDate: parseISODate(validated.startDate),
    endDate: parseISODate(validated.endDate),
    cashier: validated.cashier,
    status: validated.status,
    orderBy: validated.orderBy,
    order: validated.order,
    page: validated.page ? parseInt(validated.page, 10) : 1,
    perPage: validated.perPage ? parseInt(validated.perPage, 10) : 10,
  };
}

export function parseCloseShiftInput(raw: CloseShiftInput): CloseShiftInput {
  const validated = CloseShiftSchema.parse(raw);
  return validated;
}

export function parseShiftIdParam(id: string): number {
  return parseIntParam(id, "ID de corte");
}

// ==================== SHIFT SERVICES ====================

export async function openShift(
  data: AbrirCorteRequest,
  cashierId: string,
): Promise<CorteResponse> {
  await validateNoOpenShift(cashierId);
  await validateNoSystemOpenShift();

  const lastShift = await prisma.shift.findFirst({
    orderBy: { createdAt: "desc" },
  });

  let newFolio = "FN-1";
  if (lastShift) {
    const currentNumber = parseInt(lastShift.folio.split("-")[1]) || 0;
    newFolio = `FN-${currentNumber + 1}`;
  }

  const shift = await prisma.shift.create({
    data: {
      folio: newFolio,
      cashierId,
      openingDate: new Date(),
      initialCash: data.initialCash,
      notes: data.notes,
    },
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  return serializeShift(shift);
}

export async function closeShift(
  data: CloseShiftInput,
): Promise<CorteResponse> {
  const shift = await prisma.shift.findUnique({
    where: { id: data.shiftId },
    include: {
      inventoryMovements: {
        where: {
          type: "SALE",
          isCancelled: false,
        },
      },
    },
  });

  if (!shift) {
    throw new Error("Corte no encontrado");
  }

  if (shift.closingDate) {
    throw new Error("El corte ya está cerrado");
  }

  const tickets = new Set(shift.inventoryMovements.map((i) => i.ticket)).size;

  let membershipSales = 0;
  let productSales0Tax = 0;
  const productSales16Tax = 0;
  let cashAmount = 0;
  let debitCardAmount = 0;
  let creditCardAmount = 0;

  const membershipProducts = await prisma.product.findMany({
    where: {
      OR: [
        { name: { contains: "EFECTIVO", mode: "insensitive" } },
        { name: { contains: "VISITA", mode: "insensitive" } },
      ],
    },
  });
  const membershipIds = membershipProducts.map((p) => p.id);

  for (const sale of shift.inventoryMovements) {
    const total = Number(sale.total || 0);

    if (membershipIds.includes(sale.productId)) {
      membershipSales += total;
    } else {
      productSales0Tax += total;
    }

    switch (sale.paymentMethod) {
      case "CASH":
        cashAmount += total;
        break;
      case "DEBIT_CARD":
        debitCardAmount += total;
        break;
      case "CREDIT_CARD":
        creditCardAmount += total;
        break;
    }
  }

  const subtotal = membershipSales + productSales0Tax + productSales16Tax;
  const tax = productSales16Tax * 0.16;
  const totalSales = subtotal + tax;
  const totalVoucher = debitCardAmount + creditCardAmount;
  const totalWithdrawals = data.totalWithdrawals || 0;
  const totalCash =
    (data.cashAmount || 0) +
    (data.debitCardAmount || 0) +
    (data.creditCardAmount || 0) -
    totalWithdrawals;
  const expectedCash =
    Number(shift.initialCash) + cashAmount - totalWithdrawals;
  const difference =
    data.difference !== undefined ? data.difference : totalCash - expectedCash;

  const updatedShift = await prisma.shift.update({
    where: { id: data.shiftId },
    data: {
      closingDate: new Date(),
      ticketCount: tickets,
      membershipSales,
      productSales0Tax,
      productSales16Tax,
      subtotal,
      tax,
      totalSales,
      cashAmount,
      debitCardAmount,
      creditCardAmount,
      totalVoucher,
      totalWithdrawals,
      withdrawalsConcept: data.withdrawalsConcept,
      totalCash,
      difference,
      notes: data.notes || shift.notes,
    },
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  return serializeShift(updatedShift);
}

export async function getShifts(
  params?: GetShiftsParams,
): Promise<ListaCortesResponse> {
  const page = params?.page || 1;
  const perPage = params?.perPage || 10;

  const where: {
    folio?: { contains: string; mode: "insensitive" };
    openingDate?: { gte: Date; lte: Date };
    cashierId?: string;
    closingDate?: null | { not: null };
  } = {};

  if (params?.search) {
    where.folio = {
      contains: params.search,
      mode: "insensitive",
    };
  }

  if (params?.startDate && params?.endDate) {
    where.openingDate = {
      gte: params.startDate,
      lte: params.endDate,
    };
  }

  if (params?.cashier) {
    where.cashierId = params.cashier;
  }

  if (params?.status === "abiertos") {
    where.closingDate = null;
  } else if (params?.status === "cerrados") {
    where.closingDate = { not: null };
  }

  const orderByField = params?.orderBy === "folio" ? "folio" : "openingDate";
  const orderDirection = params?.order === "asc" ? "asc" : "desc";

  const total = await prisma.shift.count({ where });

  const shifts = await prisma.shift.findMany({
    where,
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
    orderBy: {
      [orderByField]: orderDirection,
    },
    skip: (page - 1) * perPage,
    take: perPage,
  });

  return {
    shifts: shifts.map(serializeShift),
    total,
    page,
    perPage,
    totalPages: Math.ceil(total / perPage),
  };
}

export async function getActiveShift(): Promise<CorteConVentasResponse | null> {
  const shift = await prisma.shift.findFirst({
    where: { closingDate: null },
    include: {
      cashier: {
        select: { id: true, name: true, email: true },
      },
      inventoryMovements: {
        where: { type: "SALE", isCancelled: false },
        include: {
          product: { select: { name: true } },
          member: { select: { memberNumber: true, name: true } },
        },
        orderBy: { date: "desc" },
      },
    },
  });

  if (!shift) return null;

  const tickets = new Set(shift.inventoryMovements.map((i) => i.ticket)).size;
  let cashAmount = 0;
  let debitCardAmount = 0;
  let creditCardAmount = 0;
  let totalSales = 0;

  shift.inventoryMovements.forEach((sale) => {
    const total = Number(sale.total || 0);
    totalSales += total;

    switch (sale.paymentMethod) {
      case "CASH":
        cashAmount += total;
        break;
      case "DEBIT_CARD":
        debitCardAmount += total;
        break;
      case "CREDIT_CARD":
        creditCardAmount += total;
        break;
    }
  });

  const baseShift = serializeShift(shift);

  return {
    ...baseShift,
    ticketCount: tickets,
    cashAmount,
    debitCardAmount,
    creditCardAmount,
    totalSales,
    inventoryMovements: shift.inventoryMovements.map((m) => ({
      id: m.id,
      type: m.type,
      quantity: m.quantity,
      ticket: m.ticket ?? undefined,
      total: Number(m.total || 0),
      paymentMethod: m.paymentMethod
        ? mapPaymentMethod(m.paymentMethod)
        : undefined,
      date: m.date,
      product: {
        name: m.product.name,
      },
      member: m.member
        ? {
            memberNumber: m.member.memberNumber,
            name: m.member.name ?? undefined,
          }
        : undefined,
    })),
  };
}

export async function getShiftById(
  id: number,
): Promise<CorteConVentasResponse> {
  const shift = await prisma.shift.findUnique({
    where: { id },
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
      inventoryMovements: {
        where: {
          type: "SALE",
        },
        include: {
          product: {
            select: {
              name: true,
            },
          },
          member: {
            select: {
              memberNumber: true,
              name: true,
            },
          },
        },
        orderBy: { date: "asc" },
      },
    },
  });

  if (!shift) {
    throw new Error("Corte no encontrado");
  }

  return {
    ...serializeShift(shift),
    inventoryMovements: shift.inventoryMovements.map((m) => ({
      id: m.id,
      type: m.type,
      quantity: m.quantity,
      ticket: m.ticket ?? undefined,
      total: Number(m.total || 0),
      paymentMethod: m.paymentMethod
        ? mapPaymentMethod(m.paymentMethod)
        : undefined,
      date: m.date,
      product: {
        name: m.product.name,
      },
      member: m.member
        ? {
            memberNumber: m.member.memberNumber,
            name: m.member.name ?? undefined,
          }
        : undefined,
    })),
  };
}

export async function getAllShifts(limit?: number): Promise<CorteResponse[]> {
  const shifts = await prisma.shift.findMany({
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
    orderBy: { openingDate: "desc" },
    take: limit,
  });

  return shifts.map(serializeShift);
}

export async function getShiftsBetweenDates(
  startDate: Date,
  endDate: Date,
): Promise<CorteResponse[]> {
  const shifts = await prisma.shift.findMany({
    where: {
      openingDate: {
        gte: startDate,
        lte: endDate,
      },
    },
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
    orderBy: { openingDate: "desc" },
  });

  return shifts.map(serializeShift);
}

export async function getShiftsByCashier(
  cashierId: string,
  limit?: number,
): Promise<CorteResponse[]> {
  const shifts = await prisma.shift.findMany({
    where: { cashierId },
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
    orderBy: { openingDate: "desc" },
    take: limit,
  });

  return shifts.map(serializeShift);
}

export async function getSalesSummaryByShift(
  shiftId: number,
): Promise<ResumenVentasPorProducto[]> {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      shiftId,
      type: "SALE",
      isCancelled: false,
    },
    include: {
      product: {
        select: {
          name: true,
        },
      },
    },
  });

  const summaryByProduct = sales.reduce(
    (acc, sale) => {
      const name = sale.product.name;
      if (!acc[name]) {
        acc[name] = {
          product: name,
          quantity: 0,
          total: 0,
        };
      }
      acc[name].quantity += Math.abs(sale.quantity);
      acc[name].total += Number(sale.total || 0);
      return acc;
    },
    {} as Record<string, { product: string; quantity: number; total: number }>,
  );

  return Object.values(summaryByProduct);
}

export async function getPaymentMethodSummary(
  shiftId: number,
): Promise<ResumenPorFormaPago> {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      shiftId,
      type: "SALE",
      isCancelled: false,
    },
  });

  const summary = sales.reduce(
    (acc, sale) => {
      const total = Number(sale.total || 0);
      const method = sale.paymentMethod || "CASH";
      acc[method] += total;
      return acc;
    },
    {
      CASH: 0,
      DEBIT_CARD: 0,
      CREDIT_CARD: 0,
      TRANSFER: 0,
    },
  );

  return summary;
}

export async function getShiftsStatistics(
  startDate?: Date,
  endDate?: Date,
): Promise<EstadisticasCortesResponse> {
  const where: { openingDate?: { gte: Date; lte: Date } } = {};

  if (startDate && endDate) {
    where.openingDate = {
      gte: startDate,
      lte: endDate,
    };
  }

  const shifts = await prisma.shift.findMany({
    where,
  });

  const totalShifts = shifts.length;
  const totalSales = shifts.reduce((sum, s) => sum + Number(s.totalSales), 0);
  const averageSales = totalShifts > 0 ? totalSales / totalShifts : 0;
  const totalDifferences = shifts.reduce(
    (sum, s) => sum + Math.abs(Number(s.difference)),
    0,
  );

  return {
    totalShifts,
    totalSales,
    averageSales,
    totalDifferences,
  };
}

export async function cancelShift(
  shiftId: number,
  userRole: string,
): Promise<{ success: boolean; message: string }> {
  if (userRole !== "ADMIN") {
    throw new Error("Solo un administrador puede cancelar un corte");
  }

  const shift = await prisma.shift.findUnique({
    where: { id: shiftId },
  });

  if (!shift) {
    throw new Error("Corte no encontrado");
  }

  if (!shift.closingDate) {
    throw new Error("No se puede cancelar un corte abierto");
  }

  await prisma.shift.delete({
    where: { id: shiftId },
  });

  return { success: true, message: "Corte cancelado exitosamente" };
}

export async function getShiftSummary(
  shiftId: number,
): Promise<ResumenCorteResponse> {
  const shift = await prisma.shift.findUnique({
    where: { id: shiftId },
    include: {
      inventoryMovements: {
        where: {
          type: "SALE",
          isCancelled: false,
        },
      },
    },
  });

  if (!shift) {
    throw new Error("Corte no encontrado");
  }

  const tickets = new Set(shift.inventoryMovements.map((i) => i.ticket)).size;

  let cashAmount = 0;
  let debitCardAmount = 0;
  let creditCardAmount = 0;
  let totalSales = 0;

  shift.inventoryMovements.forEach((sale) => {
    const total = Number(sale.total || 0);
    totalSales += total;

    switch (sale.paymentMethod) {
      case "CASH":
        cashAmount += total;
        break;
      case "DEBIT_CARD":
        debitCardAmount += total;
        break;
      case "CREDIT_CARD":
        creditCardAmount += total;
        break;
    }
  });

  return {
    initialCash: Number(shift.initialCash),
    ticketCount: tickets,
    totalSales,
    cashAmount,
    debitCardAmount,
    creditCardAmount,
    totalWithdrawals: Number(shift.totalWithdrawals || 0),
  };
}

--- FILE: services/index.ts ---

// Exportar todos los servicios
export * as UsersService from "./users.service";
export * as MembersService from "./members.service";
export * as ProductsService from "./products.service";
export * as InventoryService from "./inventory.service";
export * as ShiftsService from "./shifts.service";
export * as ReportsService from "./reports.service";


===== types/api/sales.ts =====


--- FILE: types/api/sales.ts ---

import { z } from "zod";
import type { MetodoPago } from "../models/movimiento-inventario";

// ==================== ZOD SCHEMAS ====================

export const TicketParamsSchema = z.object({
  ticket: z.string(),
});

// Schema para filtros de historial de ventas
export const HistorialVentasFiltersSchema = z.object({
  search: z.string().optional(),
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  cashier: z.string().optional(),
  product: z.string().optional(),
  member: z.string().optional(),
  paymentMethod: z.string().optional(),
  productType: z.enum(["todos", "membresias", "productos"]).optional(),
  orderBy: z
    .enum([
      "date_desc",
      "date_asc",
      "total_desc",
      "total_asc",
      "ticket_desc",
      "ticket_asc",
    ])
    .optional(),
  onlyActive: z.boolean().optional(),
});

// ==================== INFERRED TYPES ====================

export type TicketParamsInput = z.infer<typeof TicketParamsSchema>;
export type HistorialVentasFilters = z.infer<
  typeof HistorialVentasFiltersSchema
>;

// ==================== QUERY PARAMS ====================

export interface ObtenerHistorialVentasQuery {
  startDate?: string;
  endDate?: string;
  cashier?: string;
  product?: string;
  member?: string;
  paymentMethod?: string;
  onlyActive?: string;
  productType?: string;
  search?: string;
  orderBy?: string;
  order?: string;
  page?: string;
  perPage?: string;
}

// ==================== RESPONSE TYPES ====================

export interface ProductoVentaResponse {
  id: number;
  name: string;
  salePrice: number;
  gymStock: number;
  warehouseStock: number;
  totalStock: number;
}

export interface ItemVentaTicket {
  id: number;
  product: {
    name: string;
  };
  quantity: number;
  total: number;
}

export interface TicketVentaAgrupado {
  ticket: string;
  date: Date;
  total: number;
  paymentMethod?: MetodoPago;
  cashier: string;
  member?: {
    memberNumber: string;
    name?: string;
  };
  isCancelled: boolean;
  items: ItemVentaTicket[];
}

export interface HistorialVentasResponse {
  tickets: TicketVentaAgrupado[];
  total: number;
  page: number;
  perPage: number;
  totalPages: number;
}

export interface DetalleTicketResponse {
  ticket: string;
  date: Date;
  cashier: string;
  paymentMethod?: MetodoPago;
  member?: {
    memberNumber: string;
    name?: string;
  };
  isCancelled: boolean;
  cancellationReason?: string;
  cancellationDate?: Date;
  notes?: string;
  total: number;
  items: ItemVentaTicket[];
}

// ==================== HELPER TYPES ====================

export interface CashierOption {
  id: string;
  name: string;
}

export interface ProductOption {
  id: number;
  name: string;
}

export interface MemberOption {
  id: number;
  memberNumber: string;
  name: string | null;
}
