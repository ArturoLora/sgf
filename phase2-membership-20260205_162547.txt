### PHASE 2 - MEMBERSHIP LOGIC CENTRALIZATION


===== services/products.service.ts =====


--- FILE: services/products.service.ts ---

import { prisma } from "@/lib/db";
import { Location } from "@prisma/client";
import { mapLocation } from "./enum-mappers";
import { parseBooleanQuery, parseIntParam } from "./utils";
import {
  ProductsQuerySchema,
  CreateProductInputSchema,
  UpdateProductInputSchema,
} from "@/types/api/products";
import type {
  ProductoResponse,
  ProductoConMovimientosResponse,
  ProductoBajoStockResponse,
  StockProductoResponse,
  EstadisticasProductosResponse,
  ProductsQueryInput,
  CreateProductInputRaw,
  UpdateProductInputRaw,
  CrearProductoRequest,
  ActualizarProductoRequest,
} from "@/types/api/products";
import type { ProductoVentaResponse } from "@/types/api/sales";

function serializeProduct(product: {
  id: number;
  name: string;
  salePrice: import("@prisma/client/runtime/library").Decimal;
  warehouseStock: number;
  gymStock: number;
  minStock: number;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}): ProductoResponse {
  return {
    id: product.id,
    name: product.name,
    salePrice: Number(product.salePrice),
    warehouseStock: product.warehouseStock,
    gymStock: product.gymStock,
    minStock: product.minStock,
    isActive: product.isActive,
    createdAt: product.createdAt,
    updatedAt: product.updatedAt,
  };
}

export interface SearchProductsParams {
  search?: string;
  isActive?: boolean;
  lowStock?: boolean;
}

// ==================== PARSING HELPERS ====================

export function parseProductsQuery(
  raw: ProductsQueryInput,
): SearchProductsParams {
  const validated = ProductsQuerySchema.parse(raw);

  return {
    search: validated.search,
    isActive: parseBooleanQuery(validated.isActive),
    lowStock: parseBooleanQuery(validated.lowStock) ?? false,
  };
}

export function parseCreateProductInput(
  raw: CreateProductInputRaw,
): CrearProductoRequest {
  const validated = CreateProductInputSchema.parse(raw);

  return {
    name: validated.name,
    salePrice: validated.salePrice,
    minStock: validated.minStock,
  };
}

export function parseUpdateProductInput(
  raw: UpdateProductInputRaw,
): ActualizarProductoRequest {
  const validated = UpdateProductInputSchema.parse(raw);

  return {
    name: validated.name,
    salePrice: validated.salePrice,
    minStock: validated.minStock,
    isActive: validated.isActive,
  };
}

export function parseProductId(id: string): number {
  return parseIntParam(id, "ID de producto");
}

// ==================== SERVICE METHODS ====================

export async function getAllProducts(
  params?: SearchProductsParams,
): Promise<ProductoResponse[]> {
  const where: {
    name?: { contains: string; mode: "insensitive" };
    isActive?: boolean;
  } = {};

  if (params?.search) {
    where.name = {
      contains: params.search,
      mode: "insensitive",
    };
  }

  if (params?.isActive !== undefined) {
    where.isActive = params.isActive;
  }

  const products = await prisma.product.findMany({
    where,
    orderBy: { name: "asc" },
  });

  let result = products;

  if (params?.lowStock) {
    result = products.filter(
      (p) => p.gymStock < p.minStock || p.warehouseStock < p.minStock,
    );
  }

  return result.map(serializeProduct);
}

export async function getProductById(
  id: number,
): Promise<ProductoConMovimientosResponse> {
  const product = await prisma.product.findUnique({
    where: { id },
    include: {
      inventoryMovements: {
        orderBy: { date: "desc" },
        take: 20,
        include: {
          user: {
            select: {
              name: true,
            },
          },
          member: {
            select: {
              memberNumber: true,
              name: true,
            },
          },
        },
      },
    },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  return {
    ...serializeProduct(product),
    inventoryMovements: product.inventoryMovements.map((m) => ({
      id: m.id,
      type: m.type,
      location: mapLocation(m.location),
      quantity: m.quantity,
      ticket: m.ticket ?? undefined,
      unitPrice: m.unitPrice ? Number(m.unitPrice) : undefined,
      total: m.total ? Number(m.total) : undefined,
      notes: m.notes ?? undefined,
      isCancelled: m.isCancelled,
      date: m.date,
      user: {
        name: m.user.name,
      },
      member: m.member
        ? {
            memberNumber: m.member.memberNumber,
            name: m.member.name ?? undefined,
          }
        : undefined,
    })),
  };
}

export async function createProduct(
  data: CrearProductoRequest,
): Promise<ProductoResponse> {
  const existingProduct = await prisma.product.findUnique({
    where: { name: data.name },
  });

  if (existingProduct) {
    throw new Error("Ya existe un producto con ese nombre");
  }

  const product = await prisma.product.create({
    data: {
      name: data.name,
      salePrice: data.salePrice,
      minStock: data.minStock || 0,
    },
  });

  return serializeProduct(product);
}

export async function updateProduct(
  id: number,
  data: ActualizarProductoRequest,
): Promise<ProductoResponse> {
  const product = await prisma.product.findUnique({
    where: { id },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  if (data.name && data.name !== product.name) {
    const existingProduct = await prisma.product.findUnique({
      where: { name: data.name },
    });

    if (existingProduct) {
      throw new Error("Ya existe un producto con ese nombre");
    }
  }

  const updatedProduct = await prisma.product.update({
    where: { id },
    data,
  });

  return serializeProduct(updatedProduct);
}

export async function toggleProductStatus(
  id: number,
): Promise<ProductoResponse> {
  const product = await prisma.product.findUnique({
    where: { id },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  const updatedProduct = await prisma.product.update({
    where: { id },
    data: { isActive: !product.isActive },
  });

  return serializeProduct(updatedProduct);
}

export async function getActiveProducts(): Promise<ProductoResponse[]> {
  const products = await prisma.product.findMany({
    where: { isActive: true },
    orderBy: { name: "asc" },
  });

  return products.map(serializeProduct);
}

export async function getLowStockProducts(): Promise<
  ProductoBajoStockResponse[]
> {
  const products = await prisma.product.findMany({
    where: { isActive: true },
  });

  const result = products.filter(
    (p) => p.gymStock < p.minStock || p.warehouseStock < p.minStock,
  );

  return result.map((p) => ({
    id: p.id,
    name: p.name,
    gymStock: p.gymStock,
    warehouseStock: p.warehouseStock,
    minStock: p.minStock,
    stockFaltante: {
      gym: Math.max(0, p.minStock - p.gymStock),
      warehouse: Math.max(0, p.minStock - p.warehouseStock),
    },
  }));
}

export async function getProductStock(
  productId: number,
  location?: Location,
): Promise<StockProductoResponse | number> {
  const product = await prisma.product.findUnique({
    where: { id: productId },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  if (location === "WAREHOUSE") {
    return product.warehouseStock;
  } else if (location === "GYM") {
    return product.gymStock;
  }

  return {
    warehouse: product.warehouseStock,
    gym: product.gymStock,
    total: product.warehouseStock + product.gymStock,
  };
}

export async function getMembershipProducts(): Promise<ProductoResponse[]> {
  const keywords = ["EFECTIVO", "VISITA", "MENSUALIDAD", "SEMANA"];

  const products = await prisma.product.findMany({
    where: {
      isActive: true,
      OR: keywords.map((keyword) => ({
        name: { contains: keyword, mode: "insensitive" },
      })),
    },
    orderBy: { name: "asc" },
  });

  return products.map(serializeProduct);
}

export async function getSaleProducts(): Promise<ProductoVentaResponse[]> {
  const keywords = ["EFECTIVO", "VISITA", "MENSUALIDAD", "SEMANA"];

  const products = await prisma.product.findMany({
    where: {
      isActive: true,
      NOT: {
        OR: keywords.map((keyword) => ({
          name: { contains: keyword, mode: "insensitive" },
        })),
      },
    },
    orderBy: { name: "asc" },
  });

  return products.map((p) => ({
    id: p.id,
    name: p.name,
    salePrice: Number(p.salePrice),
    gymStock: p.gymStock,
    warehouseStock: p.warehouseStock,
    totalStock: p.gymStock + p.warehouseStock,
  }));
}

export async function getProductsStatistics(): Promise<EstadisticasProductosResponse> {
  const total = await prisma.product.count();
  const active = await prisma.product.count({ where: { isActive: true } });

  const products = await prisma.product.findMany({
    where: { isActive: true },
  });

  const lowStockGym = products.filter((p) => p.gymStock < p.minStock).length;
  const lowStockWarehouse = products.filter(
    (p) => p.warehouseStock < p.minStock,
  ).length;

  const inventoryValue = products.reduce((sum, p) => {
    const totalStock = p.warehouseStock + p.gymStock;
    return sum + Number(p.salePrice) * totalStock;
  }, 0);

  return {
    total,
    active,
    lowStockGym,
    lowStockWarehouse,
    inventoryValue,
  };
}


===== services/inventory.service.ts =====


--- FILE: services/inventory.service.ts ---

import { prisma } from "@/lib/db";
import { InventoryType, Location, PaymentMethod } from "@prisma/client";
import { calculateMembershipDates, parseISODate, parseIntParam } from "./utils";
import {
  mapInventoryType,
  mapLocation,
  mapPaymentMethod,
} from "./enum-mappers";
import {
  MovementsQuerySchema,
  CancelledSalesQuerySchema,
} from "@/types/api/inventory";
import type {
  CrearVentaRequest,
  CrearEntradaRequest,
  CrearTraspasoRequest,
  CrearAjusteRequest,
  CancelarVentaRequest,
  MovimientoInventarioResponse,
  MovementsQueryInput,
  CancelledSalesQueryInput,
  VentaCreada,
  EntradaCreada,
  TraspasoCreado,
  AjusteCreado,
  VentaCancelada,
} from "@/types/api/inventory";
import type { DetalleTicketResponse, ItemVentaTicket } from "@/types/api/sales";

// ==================== INTERNAL TYPES ====================

export interface GetMovementsByDateParams {
  startDate: Date;
  endDate: Date;
}

export interface GetCancelledSalesParams {
  startDate?: Date;
  endDate?: Date;
}

// ==================== HELPERS ====================

function serializeInventoryMovement(movement: {
  id: number;
  productId: number;
  type: InventoryType;
  location: Location;
  quantity: number;
  ticket: string | null;
  memberId: number | null;
  userId: string;
  unitPrice: import("@prisma/client/runtime/library").Decimal | null;
  subtotal: import("@prisma/client/runtime/library").Decimal | null;
  discount: import("@prisma/client/runtime/library").Decimal | null;
  surcharge: import("@prisma/client/runtime/library").Decimal | null;
  total: import("@prisma/client/runtime/library").Decimal | null;
  paymentMethod: PaymentMethod | null;
  shiftId: number | null;
  notes: string | null;
  isCancelled: boolean;
  cancellationReason: string | null;
  cancellationDate: Date | null;
  date: Date;
  createdAt: Date;
  product: {
    name: string;
    salePrice?: import("@prisma/client/runtime/library").Decimal;
  };
  member?: { memberNumber: string; name: string | null } | null;
  user: { name: string };
}): MovimientoInventarioResponse {
  return {
    id: movement.id,
    productId: movement.productId,
    type: mapInventoryType(movement.type),
    location: mapLocation(movement.location),
    quantity: movement.quantity,
    ticket: movement.ticket ?? undefined,
    memberId: movement.memberId ?? undefined,
    userId: movement.userId,
    unitPrice: movement.unitPrice ? Number(movement.unitPrice) : undefined,
    subtotal: movement.subtotal ? Number(movement.subtotal) : undefined,
    discount: movement.discount ? Number(movement.discount) : undefined,
    surcharge: movement.surcharge ? Number(movement.surcharge) : undefined,
    total: movement.total ? Number(movement.total) : undefined,
    paymentMethod: movement.paymentMethod
      ? mapPaymentMethod(movement.paymentMethod)
      : undefined,
    shiftId: movement.shiftId ?? undefined,
    notes: movement.notes ?? undefined,
    isCancelled: movement.isCancelled,
    cancellationReason: movement.cancellationReason ?? undefined,
    cancellationDate: movement.cancellationDate ?? undefined,
    date: movement.date,
    createdAt: movement.createdAt,
    product: {
      name: movement.product.name,
      salePrice: movement.product.salePrice
        ? Number(movement.product.salePrice)
        : undefined,
    },
    member: movement.member
      ? {
          memberNumber: movement.member.memberNumber,
          name: movement.member.name ?? undefined,
        }
      : undefined,
    user: {
      name: movement.user.name,
    },
  };
}

// ==================== VALIDATIONS ====================

async function validateStock(
  productId: number,
  quantity: number,
  location: Location,
): Promise<{
  id: number;
  name: string;
  warehouseStock: number;
  gymStock: number;
  salePrice: import("@prisma/client/runtime/library").Decimal;
}> {
  const product = await prisma.product.findUnique({
    where: { id: productId },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  const isMembership =
    product.name.includes("EFECTIVO") ||
    product.name.includes("VISITA") ||
    product.name.includes("MENSUALIDAD") ||
    product.name.includes("SEMANA") ||
    product.name.includes("TRIMESTRE") ||
    product.name.includes("ANUAL");

  if (!isMembership) {
    const currentStock =
      location === "WAREHOUSE" ? product.warehouseStock : product.gymStock;

    if (currentStock < quantity) {
      throw new Error(
        `Stock insuficiente en ${location}. Disponible: ${currentStock}, Solicitado: ${quantity}`,
      );
    }
  }

  return product;
}

// ==================== PARSING HELPERS ====================

export function parseMovementsQuery(
  raw: MovementsQueryInput,
): GetMovementsByDateParams {
  const validated = MovementsQuerySchema.parse(raw);

  const startDate = new Date(validated.startDate);
  const endDate = new Date(validated.endDate);

  if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
    throw new Error("Fechas inválidas");
  }

  return { startDate, endDate };
}

export function parseCancelledSalesQuery(
  raw: CancelledSalesQueryInput,
): GetCancelledSalesParams {
  const validated = CancelledSalesQuerySchema.parse(raw);

  return {
    startDate: parseISODate(validated.startDate),
    endDate: parseISODate(validated.endDate),
  };
}

export function parseProductIdParam(id: string): number {
  return parseIntParam(id, "ID de producto");
}

// ==================== SALE SERVICES ====================

export async function createSale(
  data: CrearVentaRequest,
  userId: string,
): Promise<VentaCreada> {
  const product = await validateStock(data.productId, data.quantity, "GYM");

  const unitPrice = data.unitPrice || Number(product.salePrice);
  const subtotal = unitPrice * data.quantity;
  const discount = data.discount || 0;
  const surcharge = data.surcharge || 0;
  const total = subtotal - discount + surcharge;

  const isMembership =
    product.name.includes("EFECTIVO") ||
    product.name.includes("VISITA") ||
    product.name.includes("MENSUALIDAD") ||
    product.name.includes("SEMANA") ||
    product.name.includes("TRIMESTRE") ||
    product.name.includes("ANUAL");

  const inventoryMovement = await prisma.$transaction(async (tx) => {
    const movement = await tx.inventoryMovement.create({
      data: {
        productId: data.productId,
        type: "SALE",
        location: "GYM",
        quantity: -data.quantity,
        ticket: data.ticket,
        memberId: data.memberId,
        userId,
        unitPrice,
        subtotal,
        discount,
        surcharge,
        total,
        paymentMethod: data.paymentMethod,
        shiftId: data.shiftId,
        notes: data.notes,
      },
      include: {
        product: true,
        member: true,
        user: {
          select: {
            name: true,
          },
        },
      },
    });

    if (!isMembership) {
      await tx.product.update({
        where: { id: data.productId },
        data: {
          gymStock: product.gymStock - data.quantity,
        },
      });
    }

    return movement;
  });

  if (data.memberId && isMembership) {
    const member = await prisma.member.findUnique({
      where: { id: data.memberId },
    });

    if (member && member.membershipType) {
      const dates = calculateMembershipDates(member.membershipType);

      await prisma.member.update({
        where: { id: data.memberId },
        data: {
          startDate: dates.startDate,
          endDate: dates.endDate,
          totalVisits: { increment: 1 },
          lastVisit: new Date(),
        },
      });
    }
  } else if (data.memberId) {
    await prisma.member.update({
      where: { id: data.memberId },
      data: {
        totalVisits: { increment: 1 },
        lastVisit: new Date(),
      },
    });
  }

  return serializeInventoryMovement(inventoryMovement) as VentaCreada;
}

export async function cancelSale(
  data: CancelarVentaRequest,
): Promise<VentaCancelada> {
  const sale = await prisma.inventoryMovement.findUnique({
    where: { id: data.inventoryId },
    include: {
      product: true,
      user: {
        select: {
          name: true,
        },
      },
    },
  });

  if (!sale) {
    throw new Error("Venta no encontrada");
  }

  if (sale.type !== "SALE") {
    throw new Error("Solo se pueden cancelar ventas");
  }

  if (sale.isCancelled) {
    throw new Error("La venta ya fue cancelada");
  }

  const quantityToReturn = Math.abs(sale.quantity);

  const cancelledInventory = await prisma.$transaction(async (tx) => {
    const cancelled = await tx.inventoryMovement.update({
      where: { id: data.inventoryId },
      data: {
        isCancelled: true,
        cancellationReason: data.cancellationReason,
        cancellationDate: new Date(),
      },
      include: {
        product: true,
        member: true,
        user: {
          select: {
            name: true,
          },
        },
      },
    });

    await tx.product.update({
      where: { id: sale.productId },
      data: {
        gymStock: sale.product.gymStock + quantityToReturn,
      },
    });

    return cancelled;
  });

  return serializeInventoryMovement(cancelledInventory) as VentaCancelada;
}

// ==================== TICKET SERVICES ====================

export async function getTicketDetail(
  ticket: string,
): Promise<DetalleTicketResponse> {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      ticket,
      type: "SALE",
    },
    include: {
      product: {
        select: {
          name: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { date: "asc" },
  });

  if (sales.length === 0) {
    throw new Error("Ticket no encontrado");
  }

  const firstSale = sales[0];

  const items: ItemVentaTicket[] = sales.map((s) => ({
    id: s.id,
    product: {
      name: s.product.name,
    },
    quantity: s.quantity,
    total: Number(s.total || 0),
  }));

  const total = sales.reduce((sum, s) => sum + Number(s.total || 0), 0);

  return {
    ticket,
    date: firstSale.date,
    cashier: firstSale.user.name,
    paymentMethod: firstSale.paymentMethod
      ? mapPaymentMethod(firstSale.paymentMethod)
      : undefined,
    member: firstSale.member
      ? {
          memberNumber: firstSale.member.memberNumber,
          name: firstSale.member.name ?? undefined,
        }
      : undefined,
    isCancelled: firstSale.isCancelled,
    cancellationReason: firstSale.cancellationReason ?? undefined,
    cancellationDate: firstSale.cancellationDate ?? undefined,
    notes: firstSale.notes ?? undefined,
    total,
    items,
  };
}

// ==================== ENTRY SERVICES ====================

export async function createEntry(
  data: CrearEntradaRequest,
  userId: string,
): Promise<EntradaCreada> {
  const product = await prisma.product.findUnique({
    where: { id: data.productId },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  const type: InventoryType =
    data.location === "WAREHOUSE" ? "WAREHOUSE_ENTRY" : "GYM_ENTRY";

  const inventoryMovement = await prisma.$transaction(async (tx) => {
    const movement = await tx.inventoryMovement.create({
      data: {
        productId: data.productId,
        type,
        location: data.location,
        quantity: data.quantity,
        userId,
        notes: data.notes,
      },
      include: {
        product: true,
        user: {
          select: {
            name: true,
          },
        },
      },
    });

    await tx.product.update({
      where: { id: data.productId },
      data: {
        [data.location === "WAREHOUSE" ? "warehouseStock" : "gymStock"]: {
          increment: data.quantity,
        },
      },
    });

    return movement;
  });

  return serializeInventoryMovement(inventoryMovement) as EntradaCreada;
}

// ==================== TRANSFER SERVICES ====================

export async function createTransfer(
  data: CrearTraspasoRequest,
  userId: string,
): Promise<TraspasoCreado> {
  const origin: Location = data.destination === "GYM" ? "WAREHOUSE" : "GYM";

  const product = await validateStock(data.productId, data.quantity, origin);

  const type: InventoryType =
    data.destination === "GYM" ? "TRANSFER_TO_GYM" : "TRANSFER_TO_WAREHOUSE";

  const inventoryMovement = await prisma.$transaction(async (tx) => {
    const movement = await tx.inventoryMovement.create({
      data: {
        productId: data.productId,
        type,
        location: data.destination,
        quantity: data.quantity,
        userId,
        notes:
          data.notes ||
          `Traspaso de ${data.quantity} unidades de ${origin} a ${data.destination}`,
      },
      include: {
        product: true,
        user: {
          select: {
            name: true,
          },
        },
      },
    });

    await tx.product.update({
      where: { id: data.productId },
      data: {
        warehouseStock:
          origin === "WAREHOUSE"
            ? product.warehouseStock - data.quantity
            : product.warehouseStock + data.quantity,
        gymStock:
          origin === "GYM"
            ? product.gymStock - data.quantity
            : product.gymStock + data.quantity,
      },
    });

    return movement;
  });

  return serializeInventoryMovement(inventoryMovement) as TraspasoCreado;
}

// ==================== ADJUSTMENT SERVICES ====================

export async function createAdjustment(
  data: CrearAjusteRequest,
  userId: string,
): Promise<AjusteCreado> {
  const product = await prisma.product.findUnique({
    where: { id: data.productId },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  const currentStock =
    data.location === "WAREHOUSE" ? product.warehouseStock : product.gymStock;
  const newStock = currentStock + data.quantity;

  if (newStock < 0) {
    throw new Error(
      `El ajuste resultaría en existencia negativa. Existencia actual: ${currentStock}`,
    );
  }

  const inventoryMovement = await prisma.$transaction(async (tx) => {
    const movement = await tx.inventoryMovement.create({
      data: {
        productId: data.productId,
        type: "ADJUSTMENT",
        location: data.location,
        quantity: data.quantity,
        userId,
        notes: data.notes,
      },
      include: {
        product: true,
        user: {
          select: {
            name: true,
          },
        },
      },
    });

    await tx.product.update({
      where: { id: data.productId },
      data: {
        [data.location === "WAREHOUSE" ? "warehouseStock" : "gymStock"]:
          newStock,
      },
    });

    return movement;
  });

  return serializeInventoryMovement(inventoryMovement) as AjusteCreado;
}

// ==================== QUERY SERVICES ====================

export async function getMovementsByProduct(
  productId: number,
  limit?: number,
): Promise<MovimientoInventarioResponse[]> {
  const movements = await prisma.inventoryMovement.findMany({
    where: { productId },
    include: {
      product: {
        select: {
          name: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { date: "desc" },
    take: limit,
  });

  return movements.map(serializeInventoryMovement);
}

export async function getMovementsByDate(
  params: GetMovementsByDateParams,
): Promise<MovimientoInventarioResponse[]> {
  const movements = await prisma.inventoryMovement.findMany({
    where: {
      date: {
        gte: params.startDate,
        lte: params.endDate,
      },
    },
    include: {
      product: {
        select: {
          name: true,
          salePrice: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { date: "desc" },
  });

  return movements.map(serializeInventoryMovement);
}

export async function getSalesByTicket(
  ticket: string,
): Promise<MovimientoInventarioResponse[]> {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      ticket,
      type: "SALE",
    },
    include: {
      product: {
        select: {
          name: true,
          salePrice: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { date: "asc" },
  });

  return sales.map(serializeInventoryMovement);
}

export async function getSalesByShift(
  shiftId: number,
): Promise<MovimientoInventarioResponse[]> {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      shiftId,
      type: "SALE",
    },
    include: {
      product: {
        select: {
          name: true,
          salePrice: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { date: "asc" },
  });

  return sales.map(serializeInventoryMovement);
}

export async function getCancelledSales(
  params?: GetCancelledSalesParams,
): Promise<MovimientoInventarioResponse[]> {
  const where: {
    type: InventoryType;
    isCancelled: boolean;
    cancellationDate?: { gte: Date; lte: Date };
  } = {
    type: "SALE",
    isCancelled: true,
  };

  if (params?.startDate && params?.endDate) {
    where.cancellationDate = {
      gte: params.startDate,
      lte: params.endDate,
    };
  }

  const sales = await prisma.inventoryMovement.findMany({
    where,
    include: {
      product: {
        select: {
          name: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { cancellationDate: "desc" },
  });

  return sales.map(serializeInventoryMovement);
}


===== services/members.service.ts =====


--- FILE: services/members.service.ts ---

import { prisma } from "@/lib/db";
import { MembershipType } from "@prisma/client";
import {
  mapMembershipType,
  parseMembershipType,
  mapMembershipTypeToApi,
  mapPaymentMethodFromApi,
} from "./enum-mappers";
import {
  parseISODate,
  parseBooleanQuery,
  calculateMembershipDates,
} from "./utils";
import {
  MembersQuerySchema,
  CreateMemberInputSchema,
  UpdateMemberInputSchema,
  RenewMemberInputSchema,
} from "@/types/api/members";
import type {
  SocioResponse,
  SocioConHistorialResponse,
  SocioVencidoResponse,
  VigenciaMembresiaResponse,
  MembersQueryInput,
  CreateMemberInputRaw,
  UpdateMemberInputRaw,
  RenewMemberInputRaw,
  CrearSocioRequest,
  ActualizarSocioRequest,
  RenovarMembresiaRequest,
} from "@/types/api/members";

function serializeMember(member: {
  id: number;
  memberNumber: string;
  name: string | null;
  phone: string | null;
  email: string | null;
  birthDate: Date | null;
  membershipType: MembershipType | null;
  membershipDescription: string | null;
  startDate: Date | null;
  endDate: Date | null;
  totalVisits: number;
  lastVisit: Date | null;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}): SocioResponse {
  return {
    id: member.id,
    memberNumber: member.memberNumber,
    name: member.name ?? undefined,
    phone: member.phone ?? undefined,
    email: member.email ?? undefined,
    birthDate: member.birthDate ?? undefined,
    membershipType: member.membershipType
      ? mapMembershipType(member.membershipType)
      : undefined,
    membershipDescription: member.membershipDescription ?? undefined,
    startDate: member.startDate ?? undefined,
    endDate: member.endDate ?? undefined,
    totalVisits: member.totalVisits,
    lastVisit: member.lastVisit ?? undefined,
    isActive: member.isActive,
    createdAt: member.createdAt,
    updatedAt: member.updatedAt,
  };
}

export interface SearchMembersParams {
  search?: string;
  isActive?: boolean;
  membershipType?: MembershipType;
}

// ==================== PARSING HELPERS ====================

export function parseMembersQuery(raw: MembersQueryInput): SearchMembersParams {
  const validated = MembersQuerySchema.parse(raw);

  return {
    search: validated.search,
    isActive: parseBooleanQuery(validated.isActive),
    membershipType: parseMembershipType(validated.membershipType),
  };
}

export function parseCreateMemberInput(
  raw: CreateMemberInputRaw,
): CrearSocioRequest {
  const validated = CreateMemberInputSchema.parse(raw);

  const parsedMembershipType = parseMembershipType(validated.membershipType);

  return {
    memberNumber: validated.memberNumber,
    name: validated.name,
    phone: validated.phone,
    email: validated.email,
    birthDate: validated.birthDate,
    membershipType: parsedMembershipType
      ? mapMembershipTypeToApi(parsedMembershipType)
      : undefined,
    membershipDescription: validated.membershipDescription,
    startDate: validated.startDate,
    endDate: validated.endDate,
    paymentMethod: validated.paymentMethod
      ? mapPaymentMethodFromApi(validated.paymentMethod)
      : undefined,
  };
}

export function parseUpdateMemberInput(
  raw: UpdateMemberInputRaw,
): ActualizarSocioRequest {
  const validated = UpdateMemberInputSchema.parse(raw);

  const parsedMembershipType = parseMembershipType(validated.membershipType);

  return {
    name: validated.name,
    phone: validated.phone,
    email: validated.email,
    birthDate: validated.birthDate,
    membershipType: parsedMembershipType
      ? mapMembershipTypeToApi(parsedMembershipType)
      : undefined,
    membershipDescription: validated.membershipDescription,
    startDate: validated.startDate,
    endDate: validated.endDate,
    isActive: validated.isActive,
  };
}

export function parseRenewMemberInput(
  raw: RenewMemberInputRaw,
): RenovarMembresiaRequest {
  const validated = RenewMemberInputSchema.parse(raw);

  const membershipType = parseMembershipType(validated.membershipType);
  if (!membershipType) {
    throw new Error("membershipType is required for renewal");
  }

  return {
    memberId: validated.memberId,
    membershipType: mapMembershipTypeToApi(membershipType),
    membershipDescription: validated.membershipDescription,
    startDate: validated.startDate,
    paymentMethod: validated.paymentMethod
      ? mapPaymentMethodFromApi(validated.paymentMethod)
      : undefined,
  };
}

// ==================== SERVICE METHODS ====================

export async function getAllMembers(
  params?: SearchMembersParams,
): Promise<SocioResponse[]> {
  const where: {
    OR?: Array<{
      memberNumber?: { contains: string; mode: "insensitive" };
      name?: { contains: string; mode: "insensitive" };
      phone?: { contains: string; mode: "insensitive" };
      email?: { contains: string; mode: "insensitive" };
    }>;
    isActive?: boolean;
    membershipType?: MembershipType;
  } = {};

  if (params?.search) {
    where.OR = [
      { memberNumber: { contains: params.search, mode: "insensitive" } },
      { name: { contains: params.search, mode: "insensitive" } },
      { phone: { contains: params.search, mode: "insensitive" } },
      { email: { contains: params.search, mode: "insensitive" } },
    ];
  }

  if (params?.isActive !== undefined) {
    where.isActive = params.isActive;
  }

  if (params?.membershipType) {
    where.membershipType = params.membershipType;
  }

  const members = await prisma.member.findMany({
    where,
    orderBy: { createdAt: "desc" },
  });

  return members.map(serializeMember);
}

export async function getMemberById(
  id: number,
): Promise<SocioConHistorialResponse> {
  const member = await prisma.member.findUnique({
    where: { id },
    include: {
      inventoryMovements: {
        where: { type: "SALE", isCancelled: false },
        orderBy: { date: "desc" },
        take: 20,
        include: {
          product: {
            select: {
              name: true,
              salePrice: true,
            },
          },
        },
      },
    },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  return {
    ...serializeMember(member),
    inventoryMovements: member.inventoryMovements.map((m) => ({
      id: m.id,
      type: m.type,
      quantity: m.quantity,
      total: m.total ? Number(m.total) : 0,
      date: m.date,
      product: {
        name: m.product.name,
        salePrice: Number(m.product.salePrice),
      },
    })),
  };
}

export async function getMemberByNumber(
  memberNumber: string,
): Promise<SocioConHistorialResponse> {
  const member = await prisma.member.findUnique({
    where: { memberNumber },
    include: {
      inventoryMovements: {
        where: { type: "SALE", isCancelled: false },
        orderBy: { date: "desc" },
        take: 5,
        include: {
          product: {
            select: {
              name: true,
              salePrice: true,
            },
          },
        },
      },
    },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  return {
    ...serializeMember(member),
    inventoryMovements: member.inventoryMovements.map((m) => ({
      id: m.id,
      type: m.type,
      quantity: m.quantity,
      total: m.total ? Number(m.total) : 0,
      date: m.date,
      product: {
        name: m.product.name,
        salePrice: Number(m.product.salePrice),
      },
    })),
  };
}

export async function createMember(
  data: CrearSocioRequest,
  userId: string,
): Promise<SocioResponse> {
  const existingMember = await prisma.member.findUnique({
    where: { memberNumber: data.memberNumber },
  });

  if (existingMember) {
    throw new Error("El número de socio ya existe");
  }

  const member = await prisma.member.create({
    data: {
      memberNumber: data.memberNumber,
      name: data.name,
      phone: data.phone,
      email: data.email,
      birthDate: data.birthDate ? parseISODate(data.birthDate) : undefined,
      membershipType: data.membershipType
        ? parseMembershipType(data.membershipType)
        : undefined,
      membershipDescription: data.membershipDescription,
      startDate: data.startDate ? parseISODate(data.startDate) : undefined,
      endDate: data.endDate ? parseISODate(data.endDate) : undefined,
    },
  });

  if (data.membershipType && userId) {
    const keywordMap: Record<string, string> = {
      MONTH_STUDENT: "MENSUALIDAD ESTUDIANTE",
      MONTH_GENERAL: "MENSUALIDAD GENERAL",
      WEEK: "SEMANA",
      VISIT: "VISITA",
      QUARTER_STUDENT: "TRIMESTRE ESTUDIANTE",
      QUARTER_GENERAL: "TRIMESTRE GENERAL",
      ANNUAL_STUDENT: "ANUAL ESTUDIANTE",
      ANNUAL_GENERAL: "ANUAL GENERAL",
      PROMOTION: "PROMOCION",
      REBIRTH: "RENACER",
    };

    const keyword = keywordMap[data.membershipType] || data.membershipType;

    const product = await prisma.product.findFirst({
      where: {
        name: { contains: keyword, mode: "insensitive" },
        isActive: true,
      },
    });

    if (product) {
      const activeShift = await prisma.shift.findFirst({
        where: { closingDate: null },
      });

      const timestamp = Date.now().toString().slice(-6);
      const random = Math.floor(Math.random() * 100)
        .toString()
        .padStart(2, "0");
      const ticket = `NEW${timestamp}${random}`;

      await prisma.inventoryMovement.create({
        data: {
          productId: product.id,
          type: "SALE",
          location: "GYM",
          quantity: -1,
          ticket,
          memberId: member.id,
          userId,
          unitPrice: product.salePrice,
          subtotal: product.salePrice,
          discount: 0,
          surcharge: 0,
          total: product.salePrice,
          paymentMethod: data.paymentMethod
            ? mapPaymentMethodFromApi(data.paymentMethod)
            : "CASH",
          shiftId: activeShift?.id,
          notes: `Alta de socio: ${data.membershipDescription || data.membershipType}`,
        },
      });
    }
  }

  return serializeMember(member);
}

export async function updateMember(
  id: number,
  data: ActualizarSocioRequest,
): Promise<SocioResponse> {
  const member = await prisma.member.findUnique({
    where: { id },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  const updatedMember = await prisma.member.update({
    where: { id },
    data: {
      name: data.name,
      phone: data.phone,
      email: data.email,
      birthDate: data.birthDate ? parseISODate(data.birthDate) : undefined,
      membershipType: data.membershipType
        ? parseMembershipType(data.membershipType)
        : undefined,
      membershipDescription: data.membershipDescription,
      startDate: data.startDate ? parseISODate(data.startDate) : undefined,
      endDate: data.endDate ? parseISODate(data.endDate) : undefined,
      isActive: data.isActive,
    },
  });

  return serializeMember(updatedMember);
}

export async function toggleMemberStatus(id: number): Promise<SocioResponse> {
  const member = await prisma.member.findUnique({
    where: { id },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  const updatedMember = await prisma.member.update({
    where: { id },
    data: { isActive: !member.isActive },
  });

  return serializeMember(updatedMember);
}

export async function registerVisit(memberId: number): Promise<SocioResponse> {
  const member = await prisma.member.findUnique({
    where: { id: memberId },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  if (!member.isActive) {
    throw new Error("El socio no está activo");
  }

  const updatedMember = await prisma.member.update({
    where: { id: memberId },
    data: {
      totalVisits: { increment: 1 },
      lastVisit: new Date(),
    },
  });

  return serializeMember(updatedMember);
}

export async function getActiveMembers(): Promise<SocioResponse[]> {
  const members = await prisma.member.findMany({
    where: { isActive: true },
    orderBy: { name: "asc" },
  });

  return members.map(serializeMember);
}

export async function getMembersExpiringSoon(
  days: number = 7,
): Promise<SocioResponse[]> {
  const today = new Date();
  const limitDate = new Date();
  limitDate.setDate(limitDate.getDate() + days);

  const members = await prisma.member.findMany({
    where: {
      isActive: true,
      endDate: {
        gte: today,
        lte: limitDate,
      },
      membershipType: {
        not: "VISIT",
      },
    },
    orderBy: { endDate: "asc" },
  });

  return members.map(serializeMember);
}

export async function getMembersStatistics(): Promise<{
  total: number;
  active: number;
  inactive: number;
  byType: Array<{ membershipType: MembershipType | null; _count: number }>;
}> {
  const total = await prisma.member.count();
  const active = await prisma.member.count({ where: { isActive: true } });
  const inactive = await prisma.member.count({ where: { isActive: false } });

  const byType = await prisma.member.groupBy({
    by: ["membershipType"],
    where: { isActive: true },
    _count: true,
  });

  return {
    total,
    active,
    inactive,
    byType,
  };
}

export async function renewMembership(
  data: RenovarMembresiaRequest,
  userId: string,
): Promise<SocioResponse> {
  const member = await prisma.member.findUnique({
    where: { id: data.memberId },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  const prismaType = parseMembershipType(data.membershipType);
  if (!prismaType) {
    throw new Error("membershipType is required for renewal");
  }

  const dates = calculateMembershipDates(
    prismaType,
    data.startDate ? parseISODate(data.startDate) : undefined,
  );

  const keywordMap: Record<string, string> = {
    MONTH_STUDENT: "MENSUALIDAD ESTUDIANTE",
    MONTH_GENERAL: "MENSUALIDAD GENERAL",
    WEEK: "SEMANA",
    VISIT: "VISITA",
    QUARTER_STUDENT: "TRIMESTRE ESTUDIANTE",
    QUARTER_GENERAL: "TRIMESTRE GENERAL",
    ANNUAL_STUDENT: "ANUAL ESTUDIANTE",
    ANNUAL_GENERAL: "ANUAL GENERAL",
    PROMOTION: "PROMOCION",
    REBIRTH: "RENACER",
  };

  const keyword = keywordMap[data.membershipType] || data.membershipType;

  const product = await prisma.product.findFirst({
    where: {
      name: { contains: keyword, mode: "insensitive" },
      isActive: true,
    },
  });

  if (!product) {
    throw new Error(
      `No se encontró producto para membresía: ${data.membershipType}`,
    );
  }

  const activeShift = await prisma.shift.findFirst({
    where: { closingDate: null },
  });

  const timestamp = Date.now().toString().slice(-6);
  const random = Math.floor(Math.random() * 100)
    .toString()
    .padStart(2, "0");
  const ticket = `REN${timestamp}${random}`;

  const updatedMember = await prisma.$transaction(async (tx) => {
    const renewed = await tx.member.update({
      where: { id: data.memberId },
      data: {
        membershipType: prismaType,
        membershipDescription: data.membershipDescription,
        startDate: dates.startDate,
        endDate: dates.endDate,
        isActive: true,
        totalVisits: { increment: 1 },
        lastVisit: new Date(),
      },
    });

    await tx.inventoryMovement.create({
      data: {
        productId: product.id,
        type: "SALE",
        location: "GYM",
        quantity: -1,
        ticket,
        memberId: data.memberId,
        userId,
        unitPrice: product.salePrice,
        subtotal: product.salePrice,
        discount: 0,
        surcharge: 0,
        total: product.salePrice,
        paymentMethod: data.paymentMethod
          ? mapPaymentMethodFromApi(data.paymentMethod)
          : "CASH",
        shiftId: activeShift?.id,
        notes: `Renovación: ${data.membershipDescription || data.membershipType}`,
      },
    });

    return renewed;
  });

  return serializeMember(updatedMember);
}

export async function getExpiredMembers(): Promise<SocioVencidoResponse[]> {
  const today = new Date();

  const members = await prisma.member.findMany({
    where: {
      isActive: true,
      endDate: {
        lt: today,
      },
      membershipType: {
        not: "VISIT",
      },
    },
    orderBy: { endDate: "desc" },
  });

  return members.map((m) => {
    const serialized = serializeMember(m);
    const daysExpired = m.endDate
      ? Math.floor(
          (today.getTime() - m.endDate.getTime()) / (1000 * 60 * 60 * 24),
        )
      : 0;

    return {
      id: serialized.id,
      memberNumber: serialized.memberNumber,
      name: serialized.name,
      membershipType: serialized.membershipType,
      endDate: serialized.endDate,
      daysExpired,
    };
  });
}

export async function verifyMembershipValidity(
  memberId: number,
): Promise<VigenciaMembresiaResponse> {
  const member = await prisma.member.findUnique({
    where: { id: memberId },
  });

  if (!member || !member.endDate || member.membershipType === "VISIT") {
    return {
      isValid: false,
      daysRemaining: 0,
      endDate: null,
    };
  }

  const today = new Date();
  const endDate = new Date(member.endDate);
  const difference = endDate.getTime() - today.getTime();
  const daysRemaining = Math.ceil(difference / (1000 * 60 * 60 * 24));

  return {
    isValid: daysRemaining > 0,
    daysRemaining: Math.max(0, daysRemaining),
    endDate,
  };
}


===== app/api/sales/products =====


--- FILE: app/api/sales/products/route.ts ---

import { NextResponse } from "next/server";
import { headers } from "next/headers";
import { auth } from "@/lib/auth";
import { prisma } from "@/lib/db";

export async function GET() {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session?.user) {
    return NextResponse.json({ error: "No autorizado" }, { status: 401 });
  }

  const products = await prisma.product.findMany({
    where: {
      isActive: true,
      // Solo productos físicos con stock
      // Excluir membresías basados en keywords
      NOT: {
        OR: [
          { name: { contains: "EFECTIVO", mode: "insensitive" } },
          { name: { contains: "VISITA", mode: "insensitive" } },
          { name: { contains: "MENSUALIDAD", mode: "insensitive" } },
          { name: { contains: "SEMANA", mode: "insensitive" } },
          { name: { contains: "TRIMESTRE", mode: "insensitive" } },
          { name: { contains: "ANUAL", mode: "insensitive" } },
        ],
      },
    },
    select: {
      id: true,
      name: true,
      salePrice: true,
      gymStock: true,
      warehouseStock: true,
    },
    orderBy: { name: "asc" },
  });

  // Agregar campo calculado de stock total
  const productsWithStock = products.map(p => ({
    ...p,
    totalStock: p.gymStock + p.warehouseStock,
  }));

  return NextResponse.json(productsWithStock);
}


===== types =====


--- FILE: types/cache-life.d.ts ---

// Type definitions for Next.js cacheLife configs

declare module 'next/cache' {
  export { unstable_cache } from 'next/dist/server/web/spec-extension/unstable-cache'
  export {
    updateTag,
    revalidateTag,
    revalidatePath,
    refresh,
  } from 'next/dist/server/web/spec-extension/revalidate'
  export { unstable_noStore } from 'next/dist/server/web/spec-extension/unstable-no-store'

  
    /**
     * Cache this `"use cache"` for a timespan defined by the `"default"` profile.
     * ```
     *   stale:      300 seconds (5 minutes)
     *   revalidate: 900 seconds (15 minutes)
     *   expire:     never
     * ```
     * 
     * This cache may be stale on clients for 5 minutes before checking with the server.
     * If the server receives a new request after 15 minutes, start revalidating new values in the background.
     * It lives for the maximum age of the server cache. If this entry has no traffic for a while, it may serve an old value the next request.
     */
    export function cacheLife(profile: "default"): void
    
    /**
     * Cache this `"use cache"` for a timespan defined by the `"seconds"` profile.
     * ```
     *   stale:      30 seconds
     *   revalidate: 1 seconds
     *   expire:     60 seconds (1 minute)
     * ```
     * 
     * This cache may be stale on clients for 30 seconds before checking with the server.
     * If the server receives a new request after 1 seconds, start revalidating new values in the background.
     * If this entry has no traffic for 1 minute it will expire. The next request will recompute it.
     */
    export function cacheLife(profile: "seconds"): void
    
    /**
     * Cache this `"use cache"` for a timespan defined by the `"minutes"` profile.
     * ```
     *   stale:      300 seconds (5 minutes)
     *   revalidate: 60 seconds (1 minute)
     *   expire:     3600 seconds (1 hour)
     * ```
     * 
     * This cache may be stale on clients for 5 minutes before checking with the server.
     * If the server receives a new request after 1 minute, start revalidating new values in the background.
     * If this entry has no traffic for 1 hour it will expire. The next request will recompute it.
     */
    export function cacheLife(profile: "minutes"): void
    
    /**
     * Cache this `"use cache"` for a timespan defined by the `"hours"` profile.
     * ```
     *   stale:      300 seconds (5 minutes)
     *   revalidate: 3600 seconds (1 hour)
     *   expire:     86400 seconds (1 day)
     * ```
     * 
     * This cache may be stale on clients for 5 minutes before checking with the server.
     * If the server receives a new request after 1 hour, start revalidating new values in the background.
     * If this entry has no traffic for 1 day it will expire. The next request will recompute it.
     */
    export function cacheLife(profile: "hours"): void
    
    /**
     * Cache this `"use cache"` for a timespan defined by the `"days"` profile.
     * ```
     *   stale:      300 seconds (5 minutes)
     *   revalidate: 86400 seconds (1 day)
     *   expire:     604800 seconds (1 week)
     * ```
     * 
     * This cache may be stale on clients for 5 minutes before checking with the server.
     * If the server receives a new request after 1 day, start revalidating new values in the background.
     * If this entry has no traffic for 1 week it will expire. The next request will recompute it.
     */
    export function cacheLife(profile: "days"): void
    
    /**
     * Cache this `"use cache"` for a timespan defined by the `"weeks"` profile.
     * ```
     *   stale:      300 seconds (5 minutes)
     *   revalidate: 604800 seconds (1 week)
     *   expire:     2592000 seconds (1 month)
     * ```
     * 
     * This cache may be stale on clients for 5 minutes before checking with the server.
     * If the server receives a new request after 1 week, start revalidating new values in the background.
     * If this entry has no traffic for 1 month it will expire. The next request will recompute it.
     */
    export function cacheLife(profile: "weeks"): void
    
    /**
     * Cache this `"use cache"` for a timespan defined by the `"max"` profile.
     * ```
     *   stale:      300 seconds (5 minutes)
     *   revalidate: 2592000 seconds (1 month)
     *   expire:     31536000 seconds (365 days)
     * ```
     * 
     * This cache may be stale on clients for 5 minutes before checking with the server.
     * If the server receives a new request after 1 month, start revalidating new values in the background.
     * If this entry has no traffic for 365 days it will expire. The next request will recompute it.
     */
    export function cacheLife(profile: "max"): void
    
    /**
     * Cache this `"use cache"` using a custom timespan.
     * ```
     *   stale: ... // seconds
     *   revalidate: ... // seconds
     *   expire: ... // seconds
     * ```
     *
     * This is similar to Cache-Control: max-age=`stale`,s-max-age=`revalidate`,stale-while-revalidate=`expire-revalidate`
     *
     * If a value is left out, the lowest of other cacheLife() calls or the default, is used instead.
     */
    export function cacheLife(profile: {
      /**
       * This cache may be stale on clients for ... seconds before checking with the server.
       */
      stale?: number,
      /**
       * If the server receives a new request after ... seconds, start revalidating new values in the background.
       */
      revalidate?: number,
      /**
       * If this entry has no traffic for ... seconds it will expire. The next request will recompute it.
       */
      expire?: number
    }): void
  

  import { cacheTag } from 'next/dist/server/use-cache/cache-tag'
  export { cacheTag }

  export const unstable_cacheTag: typeof cacheTag
  export const unstable_cacheLife: typeof cacheLife
}

--- FILE: types/models/verificacion.ts ---

export interface Verificacion {
  id: string;
  identifier: string;
  value: string;
  expiresAt: Date;
  createdAt: Date;
  updatedAt: Date;
}

--- FILE: types/models/corte.ts ---

export interface Corte {
  id: number;
  folio: string;
  cashierId: string;
  openingDate: Date;
  closingDate?: Date;
  initialCash: number;
  ticketCount: number;
  membershipSales: number;
  productSales0Tax: number;
  productSales16Tax: number;
  subtotal: number;
  tax: number;
  totalSales: number;
  cashAmount: number;
  debitCardAmount: number;
  creditCardAmount: number;
  totalVoucher: number;
  totalWithdrawals: number;
  withdrawalsConcept?: string;
  cancelledSales: number;
  totalCash: number;
  difference: number;
  notes?: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface CorteConRelaciones extends Corte {
  cashier: Usuario;
  inventoryMovements: MovimientoInventario[];
}

import type { Usuario } from "./usuario";
import type { MovimientoInventario } from "./movimiento-inventario";

--- FILE: types/models/sesion.ts ---

export interface Sesion {
  id: string;
  expiresAt: Date;
  token: string;
  createdAt: Date;
  updatedAt: Date;
  ipAddress?: string;
  userAgent?: string;
  userId: string;
}

export interface SesionConRelaciones extends Sesion {
  user: Usuario;
}

import type { Usuario } from "./usuario";

--- FILE: types/models/socio.ts ---

export enum TipoMembresia {
  VISIT = "VISIT",
  WEEK = "WEEK",
  MONTH_STUDENT = "MONTH_STUDENT",
  MONTH_GENERAL = "MONTH_GENERAL",
  QUARTER_STUDENT = "QUARTER_STUDENT",
  QUARTER_GENERAL = "QUARTER_GENERAL",
  ANNUAL_STUDENT = "ANNUAL_STUDENT",
  ANNUAL_GENERAL = "ANNUAL_GENERAL",
  PROMOTION = "PROMOTION",
  REBIRTH = "REBIRTH",
  NUTRITION_CONSULTATION = "NUTRITION_CONSULTATION",
}

export interface Socio {
  id: number;
  memberNumber: string;
  name?: string;
  phone?: string;
  email?: string;
  birthDate?: Date;
  membershipType?: TipoMembresia;
  membershipDescription?: string;
  startDate?: Date;
  endDate?: Date;
  totalVisits: number;
  lastVisit?: Date;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface SocioConRelaciones extends Socio {
  inventoryMovements: MovimientoInventario[];
}

import type { MovimientoInventario } from "./movimiento-inventario";

--- FILE: types/models/producto.ts ---

export interface Producto {
  id: number;
  name: string;
  salePrice: number;
  warehouseStock: number;
  gymStock: number;
  minStock: number;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface ProductoConRelaciones extends Producto {
  inventoryMovements: MovimientoInventario[];
}

import type { MovimientoInventario } from "./movimiento-inventario";

--- FILE: types/models/usuario.ts ---

export enum Rol {
  ADMIN = "ADMIN",
  EMPLEADO = "EMPLEADO",
}

export interface Usuario {
  id: string;
  name: string;
  email: string;
  emailVerified: boolean;
  image?: string;
  role: Rol;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface UsuarioConRelaciones extends Usuario {
  sessions: Sesion[];
  accounts: Cuenta[];
  shifts: Corte[];
  inventoryMovements: MovimientoInventario[];
}

// Importaciones necesarias para las relaciones
import type { Sesion } from "./sesion";
import type { Cuenta } from "./cuenta";
import type { Corte } from "./corte";
import type { MovimientoInventario } from "./movimiento-inventario";

--- FILE: types/models/index.ts ---

// Enums
export { Rol } from "./usuario";
export { TipoMembresia } from "./socio";
export { TipoInventario, Ubicacion, MetodoPago } from "./movimiento-inventario";

// Interfaces base
export type { Usuario, UsuarioConRelaciones } from "./usuario";
export type { Sesion, SesionConRelaciones } from "./sesion";
export type { Cuenta, CuentaConRelaciones } from "./cuenta";
export type { Verificacion } from "./verificacion";
export type { Socio, SocioConRelaciones } from "./socio";
export type { Producto, ProductoConRelaciones } from "./producto";
export type {
  MovimientoInventario,
  MovimientoInventarioConRelaciones,
} from "./movimiento-inventario";
export type { Corte, CorteConRelaciones } from "./corte";

--- FILE: types/models/cuenta.ts ---

export interface Cuenta {
  id: string;
  accountId: string;
  providerId: string;
  userId: string;
  accessToken?: string;
  refreshToken?: string;
  idToken?: string;
  accessTokenExpiresAt?: Date;
  refreshTokenExpiresAt?: Date;
  scope?: string;
  password?: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface CuentaConRelaciones extends Cuenta {
  user: Usuario;
}

import type { Usuario } from "./usuario";

--- FILE: types/models/movimiento-inventario.ts ---

export enum TipoInventario {
  SALE = "SALE",
  ADJUSTMENT = "ADJUSTMENT",
  WAREHOUSE_ENTRY = "WAREHOUSE_ENTRY",
  GYM_ENTRY = "GYM_ENTRY",
  TRANSFER_TO_GYM = "TRANSFER_TO_GYM",
  TRANSFER_TO_WAREHOUSE = "TRANSFER_TO_WAREHOUSE",
}

export enum Ubicacion {
  WAREHOUSE = "WAREHOUSE",
  GYM = "GYM",
}

export enum MetodoPago {
  CASH = "CASH",
  DEBIT_CARD = "DEBIT_CARD",
  CREDIT_CARD = "CREDIT_CARD",
  TRANSFER = "TRANSFER",
}

export interface MovimientoInventario {
  id: number;
  productId: number;
  type: TipoInventario;
  location: Ubicacion;
  quantity: number;
  ticket?: string;
  memberId?: number;
  userId: string;
  unitPrice?: number;
  subtotal?: number;
  discount?: number;
  surcharge?: number;
  total?: number;
  paymentMethod?: MetodoPago;
  shiftId?: number;
  notes?: string;
  isCancelled: boolean;
  cancellationReason?: string;
  cancellationDate?: Date;
  date: Date;
  createdAt: Date;
}

export interface MovimientoInventarioConRelaciones extends MovimientoInventario {
  product: Producto;
  member?: Socio;
  user: Usuario;
  shift?: Corte;
}

import type { Producto } from "./producto";
import type { Socio } from "./socio";
import type { Usuario } from "./usuario";
import type { Corte } from "./corte";

--- FILE: types/api/inventory.ts ---

import { z } from "zod";
import type {
  TipoInventario,
  Ubicacion,
  MetodoPago,
} from "../models/movimiento-inventario";
import type {
  MovimientoInventario,
  MovimientoInventarioConRelaciones,
} from "../models/movimiento-inventario";

// ==================== ZOD SCHEMAS ====================

export const MovementsQuerySchema = z.object({
  startDate: z.string().min(1, "startDate is required"),
  endDate: z.string().min(1, "endDate is required"),
});

export const CancelledSalesQuerySchema = z.object({
  startDate: z.string().optional(),
  endDate: z.string().optional(),
});

export const CreateSaleInputSchema = z.object({
  productId: z.number(),
  quantity: z.number(),
  memberId: z.number().optional(),
  unitPrice: z.number().optional(),
  discount: z.number().optional(),
  surcharge: z.number().optional(),
  paymentMethod: z.string(),
  ticket: z.string(),
  shiftId: z.number().optional(),
  notes: z.string().optional(),
});

export const CreateEntryInputSchema = z.object({
  productId: z.number(),
  quantity: z.number(),
  location: z.string(),
  notes: z.string().optional(),
});

export const CreateTransferInputSchema = z.object({
  productId: z.number(),
  quantity: z.number(),
  destination: z.string(),
  notes: z.string().optional(),
});

export const CreateAdjustmentInputSchema = z.object({
  productId: z.number(),
  quantity: z.number(),
  location: z.string(),
  notes: z.string(),
});

export const CancelSaleInputSchema = z.object({
  inventoryId: z.number(),
  cancellationReason: z.string(),
});

// ==================== INFERRED TYPES ====================

export type MovementsQueryInput = z.infer<typeof MovementsQuerySchema>;
export type CancelledSalesQueryInput = z.infer<
  typeof CancelledSalesQuerySchema
>;

// ==================== REQUEST TYPES ====================

export interface CrearVentaRequest {
  productId: number;
  quantity: number;
  memberId?: number;
  unitPrice?: number;
  discount?: number;
  surcharge?: number;
  paymentMethod: MetodoPago;
  ticket: string;
  shiftId?: number;
  notes?: string;
}

export interface CrearEntradaRequest {
  productId: number;
  quantity: number;
  location: Ubicacion;
  notes?: string;
}

export interface CrearTraspasoRequest {
  productId: number;
  quantity: number;
  destination: Ubicacion;
  notes?: string;
}

export interface CrearAjusteRequest {
  productId: number;
  quantity: number;
  location: Ubicacion;
  notes: string;
}

export interface CancelarVentaRequest {
  inventoryId: number;
  cancellationReason: string;
}

// ==================== RESPONSE TYPES ====================

export interface MovimientoInventarioResponse {
  id: number;
  productId: number;
  type: TipoInventario;
  location: Ubicacion;
  quantity: number;
  ticket?: string;
  memberId?: number;
  userId: string;
  unitPrice?: number;
  subtotal?: number;
  discount?: number;
  surcharge?: number;
  total?: number;
  paymentMethod?: MetodoPago;
  shiftId?: number;
  notes?: string;
  isCancelled: boolean;
  cancellationReason?: string;
  cancellationDate?: Date;
  date: Date;
  createdAt: Date;
  product: {
    name: string;
    salePrice?: number;
  };
  member?: {
    memberNumber: string;
    name?: string;
  };
  user: {
    name: string;
  };
}

export interface KardexMovimientoResponse {
  id: number;
  type: TipoInventario;
  location: Ubicacion;
  quantity: number;
  ticket?: string;
  unitPrice?: number;
  total?: number;
  paymentMethod?: MetodoPago;
  notes?: string;
  isCancelled: boolean;
  date: Date;
  user: {
    name: string;
  };
  member?: {
    memberNumber: string;
    name?: string;
  };
}

// ==================== QUERY PARAMS ====================

export interface ObtenerMovimientosQuery {
  startDate: string;
  endDate: string;
}

export interface ObtenerVentasCanceladasQuery {
  startDate?: string;
  endDate?: string;
}

// ==================== INTERNAL TYPES ====================

export interface VentaCreada extends MovimientoInventario {
  product: {
    name: string;
  };
  member?: {
    memberNumber: string;
    name?: string;
  };
  user: {
    name: string;
  };
}

export interface EntradaCreada extends MovimientoInventario {
  product: {
    name: string;
  };
  user: {
    name: string;
  };
}

export interface TraspasoCreado extends MovimientoInventario {
  product: {
    name: string;
  };
  user: {
    name: string;
  };
}

export interface AjusteCreado extends MovimientoInventario {
  product: {
    name: string;
  };
  user: {
    name: string;
  };
}

export interface VentaCancelada extends MovimientoInventario {
  product: {
    name: string;
  };
  member?: {
    memberNumber: string;
    name?: string;
  };
}

--- FILE: types/api/reports.ts ---

import { z } from "zod";
import { ProductoBajoStockResponse } from "./products";

// ==================== ZOD SCHEMAS ====================

export const ReportPeriodQuerySchema = z.object({
  startDate: z.string().min(1, "startDate is required"),
  endDate: z.string().min(1, "endDate is required"),
});

export const DashboardQuerySchema = z.object({
  startDate: z.string().optional(),
  endDate: z.string().optional(),
});

// ==================== INFERRED TYPES ====================

export type ReportPeriodQueryInput = z.infer<typeof ReportPeriodQuerySchema>;
export type DashboardQueryInput = z.infer<typeof DashboardQuerySchema>;

// ==================== REQUEST/QUERY TYPES ====================

export interface PeriodoReporteQuery {
  startDate: string;
  endDate: string;
}

// ==================== RESPONSE TYPES ====================

export interface ReporteVentasPorProducto {
  productId: number;
  productName: string;
  quantitySold: number;
  totalSales: number;
  quantityCancelled: number;
  totalCancelled: number;
}

export interface ReporteVentasDiarias {
  date: string;
  ticketCount: number;
  totalSales: number;
  totalCancelled: number;
}

export interface ReporteFormaPago {
  paymentMethod: string;
  quantity: number;
  total: number;
}

export interface ReporteVentasCanceladas {
  sales: Array<{
    id: number;
    ticket?: string;
    date: Date;
    total: number;
    cancellationReason?: string;
    cancellationDate?: Date;
    product: {
      name: string;
    };
    member?: {
      memberNumber: string;
      name?: string;
    };
    user: {
      name: string;
    };
  }>;
  totalCancelled: number;
  cancellationCount: number;
}

export interface ReporteMovimientosInventario {
  movements: Array<{
    id: number;
    type: string;
    location: string;
    quantity: number;
    date: Date;
    product: {
      name: string;
    };
    user: {
      name: string;
    };
  }>;
  summaryByType: Array<{
    type: string;
    quantity: number;
  }>;
}

export interface ReporteStockActual {
  products: Array<{
    id: number;
    name: string;
    warehouseStock: number;
    gymStock: number;
    minStock: number;
    salePrice: number;
  }>;
  stockSummary: {
    warehouse: number;
    gym: number;
    total: number;
    totalValue: number;
  };
  lowStock: ProductoBajoStockResponse[];
}

export interface ReporteSociosPorMembresia {
  membershipType: string;
  isActive: boolean;
  quantity: number;
}

export interface ReporteSociosNuevos {
  members: Array<{
    id: number;
    memberNumber: string;
    name?: string;
    membershipType?: string;
    createdAt: Date;
  }>;
  byDay: Array<{
    date: string;
    quantity: number;
  }>;
  total: number;
}

export interface ReporteVisitasSocios {
  member: {
    memberNumber: string;
    name?: string;
    membershipType?: string;
  };
  visitCount: number;
}

export interface ResumenDashboard {
  salesToday: {
    total: number;
    tickets: number;
    quantity: number;
  };
  members: {
    active: number;
  };
  products: {
    active: number;
    lowStock: number;
  };
  activeShift?: {
    id: number;
    folio: string;
    cashier: {
      name: string;
    };
    openingDate: Date;
    initialCash: number;
  };
}

--- FILE: types/api/common.ts ---

// ==================== COMMON TYPES ====================

export interface ErrorResponse {
  error: string;
}

export interface SuccessResponse {
  success: boolean;
  message: string;
}

export interface PaginacionQuery {
  page?: string;
  perPage?: string;
}

export interface PaginacionResponse {
  total: number;
  page: number;
  perPage: number;
  totalPages: number;
}

export interface OrdenamientoQuery {
  orderBy?: string;
  order?: "asc" | "desc";
}

export interface FiltroFechasQuery {
  startDate?: string;
  endDate?: string;
}

export interface BusquedaQuery {
  search?: string;
}

// ==================== AUTH TYPES ====================

export interface UsuarioSesion {
  id: string;
  name: string;
  email: string;
  role: "ADMIN" | "EMPLEADO";
}

export interface SesionActiva {
  user: UsuarioSesion;
  session: {
    id: string;
    expiresAt: Date;
  };
}

--- FILE: types/api/products.ts ---

import { z } from "zod";
import type { Ubicacion } from "../models/movimiento-inventario";

// ==================== ZOD SCHEMAS ====================

export const ProductsQuerySchema = z.object({
  search: z.string().optional(),
  isActive: z.string().optional(),
  lowStock: z.string().optional(),
});

export const CreateProductInputSchema = z.object({
  name: z.string().min(1, "El nombre es requerido"),
  salePrice: z.number().positive("El precio debe ser mayor a 0"),
  minStock: z
    .number()
    .int()
    .min(0, "El stock mínimo no puede ser negativo")
    .optional(),
});

export const UpdateProductInputSchema = z.object({
  name: z.string().min(1, "El nombre es requerido").optional(),
  salePrice: z.number().positive("El precio debe ser mayor a 0").optional(),
  minStock: z
    .number()
    .int()
    .min(0, "El stock mínimo no puede ser negativo")
    .optional(),
  isActive: z.boolean().optional(),
});

// ==================== INFERRED TYPES ====================

export type ProductsQueryInput = z.infer<typeof ProductsQuerySchema>;
export type CreateProductInputRaw = z.infer<typeof CreateProductInputSchema>;
export type UpdateProductInputRaw = z.infer<typeof UpdateProductInputSchema>;

// ==================== QUERY PARAMS ====================

export interface BuscarProductosQuery {
  search?: string;
  isActive?: string;
  lowStock?: string;
}

// ==================== REQUEST TYPES ====================

export interface CrearProductoRequest {
  name: string;
  salePrice: number;
  minStock?: number;
}

export interface ActualizarProductoRequest {
  name?: string;
  salePrice?: number;
  minStock?: number;
  isActive?: boolean;
}

// ==================== RESPONSE TYPES ====================

export interface ProductoResponse {
  id: number;
  name: string;
  salePrice: number;
  warehouseStock: number;
  gymStock: number;
  minStock: number;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface ProductoConMovimientosResponse extends ProductoResponse {
  inventoryMovements: Array<{
    id: number;
    type: string;
    location: Ubicacion;
    quantity: number;
    ticket?: string;
    unitPrice?: number;
    total?: number;
    notes?: string;
    isCancelled: boolean;
    date: Date;
    user: {
      name: string;
    };
    member?: {
      memberNumber: string;
      name?: string;
    };
  }>;
}

export interface StockProductoResponse {
  warehouse: number;
  gym: number;
  total: number;
}

export interface EstadisticasProductosResponse {
  total: number;
  active: number;
  lowStockGym: number;
  lowStockWarehouse: number;
  inventoryValue: number;
}

export interface ProductoBajoStockResponse {
  id: number;
  name: string;
  gymStock: number;
  warehouseStock: number;
  minStock: number;
  stockFaltante: {
    gym: number;
    warehouse: number;
  };
}

--- FILE: types/api/sales.ts ---

import { z } from "zod";
import type { MetodoPago } from "../models/movimiento-inventario";

// ==================== ZOD SCHEMAS ====================

export const TicketParamsSchema = z.object({
  ticket: z.string(),
});

// Schema para filtros de historial de ventas
export const HistorialVentasFiltersSchema = z.object({
  search: z.string().optional(),
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  cashier: z.string().optional(),
  product: z.string().optional(),
  member: z.string().optional(),
  paymentMethod: z.string().optional(),
  productType: z.enum(["todos", "membresias", "productos"]).optional(),
  orderBy: z
    .enum([
      "date_desc",
      "date_asc",
      "total_desc",
      "total_asc",
      "ticket_desc",
      "ticket_asc",
    ])
    .optional(),
  onlyActive: z.boolean().optional(),
});

// ==================== INFERRED TYPES ====================

export type TicketParamsInput = z.infer<typeof TicketParamsSchema>;
export type HistorialVentasFilters = z.infer<
  typeof HistorialVentasFiltersSchema
>;

// ==================== QUERY PARAMS ====================

export interface ObtenerHistorialVentasQuery {
  startDate?: string;
  endDate?: string;
  cashier?: string;
  product?: string;
  member?: string;
  paymentMethod?: string;
  onlyActive?: string;
  productType?: string;
  search?: string;
  orderBy?: string;
  order?: string;
  page?: string;
  perPage?: string;
}

// ==================== RESPONSE TYPES ====================

export interface ProductoVentaResponse {
  id: number;
  name: string;
  salePrice: number;
  gymStock: number;
  warehouseStock: number;
  totalStock: number;
}

export interface ItemVentaTicket {
  id: number;
  product: {
    name: string;
  };
  quantity: number;
  total: number;
}

export interface TicketVentaAgrupado {
  ticket: string;
  date: Date;
  total: number;
  paymentMethod?: MetodoPago;
  cashier: string;
  member?: {
    memberNumber: string;
    name?: string;
  };
  isCancelled: boolean;
  items: ItemVentaTicket[];
}

export interface HistorialVentasResponse {
  tickets: TicketVentaAgrupado[];
  total: number;
  page: number;
  perPage: number;
  totalPages: number;
}

export interface DetalleTicketResponse {
  ticket: string;
  date: Date;
  cashier: string;
  paymentMethod?: MetodoPago;
  member?: {
    memberNumber: string;
    name?: string;
  };
  isCancelled: boolean;
  cancellationReason?: string;
  cancellationDate?: Date;
  notes?: string;
  total: number;
  items: ItemVentaTicket[];
}

// ==================== HELPER TYPES ====================

export interface CashierOption {
  id: string;
  name: string;
}

export interface ProductOption {
  id: number;
  name: string;
}

export interface MemberOption {
  id: number;
  memberNumber: string;
  name: string | null;
}

--- FILE: types/api/members.ts ---

import { z } from "zod";
import type { TipoMembresia } from "../models/socio";
import type { MetodoPago } from "../models/movimiento-inventario";

// ==================== ZOD SCHEMAS ====================

export const MembersQuerySchema = z.object({
  search: z.string().optional(),
  isActive: z.string().optional(),
  membershipType: z.string().optional(),
});

export const CreateMemberInputSchema = z.object({
  memberNumber: z.string(),
  name: z.string().optional(),
  phone: z.string().optional(),
  email: z.string().optional(),
  birthDate: z.string().optional(),
  membershipType: z.string().optional(),
  membershipDescription: z.string().optional(),
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  paymentMethod: z
    .enum(["CASH", "DEBIT_CARD", "CREDIT_CARD", "TRANSFER"])
    .optional(),
});

export const UpdateMemberInputSchema = z.object({
  name: z.string().optional(),
  phone: z.string().optional(),
  email: z.string().optional(),
  birthDate: z.string().optional(),
  membershipType: z.string().optional(),
  membershipDescription: z.string().optional(),
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  isActive: z.boolean().optional(),
});

export const RenewMemberInputSchema = z.object({
  memberId: z.number(),
  membershipType: z.string(),
  membershipDescription: z.string().optional(),
  startDate: z.string().optional(),
  paymentMethod: z
    .enum(["CASH", "DEBIT_CARD", "CREDIT_CARD", "TRANSFER"])
    .optional(),
});

// ==================== INFERRED TYPES ====================

export type MembersQueryInput = z.infer<typeof MembersQuerySchema>;
export type CreateMemberInputRaw = z.infer<typeof CreateMemberInputSchema>;
export type UpdateMemberInputRaw = z.infer<typeof UpdateMemberInputSchema>;
export type RenewMemberInputRaw = z.infer<typeof RenewMemberInputSchema>;

// ==================== QUERY PARAMS ====================

export interface BuscarSociosQuery {
  search?: string;
  isActive?: string;
  membershipType?: string;
}

// ==================== REQUEST TYPES ====================

export interface CrearSocioRequest {
  memberNumber: string;
  name?: string;
  phone?: string;
  email?: string;
  birthDate?: string;
  membershipType?: TipoMembresia;
  membershipDescription?: string;
  startDate?: string;
  endDate?: string;
  paymentMethod?: MetodoPago;
}

export interface ActualizarSocioRequest {
  name?: string;
  phone?: string;
  email?: string;
  birthDate?: string;
  membershipType?: TipoMembresia;
  membershipDescription?: string;
  startDate?: string;
  endDate?: string;
  isActive?: boolean;
}

export interface RenovarMembresiaRequest {
  memberId: number;
  membershipType: TipoMembresia;
  membershipDescription?: string;
  startDate?: string;
  paymentMethod?: MetodoPago;
}

// ==================== RESPONSE TYPES ====================

export interface SocioResponse {
  id: number;
  memberNumber: string;
  name?: string;
  phone?: string;
  email?: string;
  birthDate?: Date;
  membershipType?: TipoMembresia;
  membershipDescription?: string;
  startDate?: Date;
  endDate?: Date;
  totalVisits: number;
  lastVisit?: Date;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface SocioConHistorialResponse extends SocioResponse {
  inventoryMovements: Array<{
    id: number;
    type: string;
    quantity: number;
    total: number;
    date: Date;
    product: {
      name: string;
      salePrice: number;
    };
  }>;
}

export interface VigenciaMembresiaResponse {
  isValid: boolean;
  daysRemaining: number;
  endDate: Date | null;
}

export interface SocioVencidoResponse {
  id: number;
  memberNumber: string;
  name?: string;
  membershipType?: TipoMembresia;
  endDate?: Date;
  daysExpired: number;
}

--- FILE: types/api/shifts.ts ---

import { z } from "zod";
import type { MetodoPago } from "../models/movimiento-inventario";

// ==================== ZOD SCHEMAS ====================

export const ShiftsQuerySchema = z.object({
  search: z.string().optional(),
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  cashier: z.string().optional(),
  status: z.string().optional(),
  orderBy: z.string().optional(),
  order: z.string().optional(),
  page: z.string().optional(),
  perPage: z.string().optional(),
});

export const OpenShiftSchema = z.object({
  initialCash: z.number().min(0, "El fondo inicial debe ser mayor o igual a 0"),
  notes: z.string().optional(),
});

export const CloseShiftSchema = z.object({
  shiftId: z.number(),
  cashAmount: z.number().min(0).optional(),
  debitCardAmount: z.number().min(0).optional(),
  creditCardAmount: z.number().min(0).optional(),
  totalWithdrawals: z.number().min(0).optional(),
  withdrawalsConcept: z.string().optional(),
  difference: z.number().optional(),
  notes: z.string().optional(),
});

// ==================== INFERRED TYPES ====================

export type ShiftsQueryInput = z.infer<typeof ShiftsQuerySchema>;
export type OpenShiftInput = z.infer<typeof OpenShiftSchema>;
export type CloseShiftInput = z.infer<typeof CloseShiftSchema>;

// ==================== QUERY PARAMS ====================

export interface BuscarCortesQuery {
  search?: string;
  startDate?: string;
  endDate?: string;
  cashier?: string;
  status?: string;
  orderBy?: string;
  order?: string;
  page?: string;
  perPage?: string;
}

// ==================== REQUEST TYPES ====================

export interface AbrirCorteRequest {
  initialCash: number;
  notes?: string;
}

export interface CerrarCorteRequest {
  shiftId: number;
  cashAmount: number;
  debitCardAmount: number;
  creditCardAmount: number;
  totalWithdrawals?: number;
  withdrawalsConcept?: string;
  difference: number;
  notes?: string;
}

// ==================== RESPONSE TYPES ====================

export interface CorteResponse {
  id: number;
  folio: string;
  cashierId: string;
  openingDate: Date;
  closingDate?: Date;
  initialCash: number;
  ticketCount: number;
  membershipSales: number;
  productSales0Tax: number;
  productSales16Tax: number;
  subtotal: number;
  tax: number;
  totalSales: number;
  cashAmount: number;
  debitCardAmount: number;
  creditCardAmount: number;
  totalVoucher: number;
  totalWithdrawals: number;
  withdrawalsConcept?: string;
  cancelledSales: number;
  totalCash: number;
  difference: number;
  notes?: string;
  createdAt: Date;
  updatedAt: Date;
  cashier: {
    id: string;
    name: string;
    email: string;
  };
}

export interface CorteConVentasResponse extends CorteResponse {
  inventoryMovements: Array<{
    id: number;
    type: string;
    quantity: number;
    ticket?: string;
    total: number;
    paymentMethod?: MetodoPago;
    date: Date;
    product: {
      name: string;
    };
    member?: {
      memberNumber: string;
      name?: string;
    };
  }>;
}

export interface ResumenCorteResponse {
  initialCash: number;
  ticketCount: number;
  totalSales: number;
  cashAmount: number;
  debitCardAmount: number;
  creditCardAmount: number;
  totalWithdrawals: number;
}

export interface ListaCortesResponse {
  shifts: CorteResponse[];
  total: number;
  page: number;
  perPage: number;
  totalPages: number;
}

export interface EstadisticasCortesResponse {
  totalShifts: number;
  totalSales: number;
  averageSales: number;
  totalDifferences: number;
}

export interface ResumenVentasPorProducto {
  product: string;
  quantity: number;
  total: number;
}

export interface ResumenPorFormaPago {
  CASH: number;
  DEBIT_CARD: number;
  CREDIT_CARD: number;
  TRANSFER: number;
}

--- FILE: types/api/index.ts ---

// Common types
export type {
  ErrorResponse,
  SuccessResponse,
  PaginacionQuery,
  PaginacionResponse,
  OrdenamientoQuery,
  FiltroFechasQuery,
  BusquedaQuery,
  UsuarioSesion,
  SesionActiva,
} from "./common";

// Inventory
export type {
  CrearVentaRequest,
  CrearEntradaRequest,
  CrearTraspasoRequest,
  CrearAjusteRequest,
  CancelarVentaRequest,
  MovimientoInventarioResponse,
  KardexMovimientoResponse,
  ObtenerMovimientosQuery,
  ObtenerVentasCanceladasQuery,
  VentaCreada,
  EntradaCreada,
  TraspasoCreado,
  AjusteCreado,
  VentaCancelada,
} from "./inventory";

// Sales
export type {
  ObtenerHistorialVentasQuery,
  ProductoVentaResponse,
  ItemVentaTicket,
  TicketVentaAgrupado,
  HistorialVentasResponse,
  DetalleTicketResponse,
} from "./sales";

// Members
export type {
  BuscarSociosQuery,
  CrearSocioRequest,
  ActualizarSocioRequest,
  RenovarMembresiaRequest,
  SocioResponse,
  SocioConHistorialResponse,
  VigenciaMembresiaResponse,
  SocioVencidoResponse,
} from "./members";

// Products
export type {
  BuscarProductosQuery,
  CrearProductoRequest,
  ActualizarProductoRequest,
  ProductoResponse,
  ProductoConMovimientosResponse,
  StockProductoResponse,
  EstadisticasProductosResponse,
  ProductoBajoStockResponse,
} from "./products";

// Shifts
export type {
  BuscarCortesQuery,
  AbrirCorteRequest,
  CerrarCorteRequest,
  CorteResponse,
  CorteConVentasResponse,
  ResumenCorteResponse,
  ListaCortesResponse,
  EstadisticasCortesResponse,
  ResumenVentasPorProducto,
  ResumenPorFormaPago,
} from "./shifts";

// Reports
export type {
  PeriodoReporteQuery,
  ReporteVentasPorProducto,
  ReporteVentasDiarias,
  ReporteFormaPago,
  ReporteVentasCanceladas,
  ReporteMovimientosInventario,
  ReporteStockActual,
  ReporteSociosPorMembresia,
  ReporteSociosNuevos,
  ReporteVisitasSocios,
  ResumenDashboard,
} from "./reports";

--- FILE: types/index.ts ---

// Re-export models
export * from "./models";

// Re-export API contracts
export * from "./api";

--- FILE: types/routes.d.ts ---

// This file is generated automatically by Next.js
// Do not edit this file manually

type AppRoutes = "/"
type PageRoutes = never
type LayoutRoutes = "/"
type RedirectRoutes = never
type RewriteRoutes = never
type Routes = AppRoutes | PageRoutes | LayoutRoutes | RedirectRoutes | RewriteRoutes


interface ParamMap {
  "/": {}
}


export type ParamsOf<Route extends Routes> = ParamMap[Route]

interface LayoutSlotMap {
  "/": never
}


export type { AppRoutes, PageRoutes, LayoutRoutes, RedirectRoutes, RewriteRoutes, ParamMap }

declare global {
  /**
   * Props for Next.js App Router page components
   * @example
   * ```tsx
   * export default function Page(props: PageProps<'/blog/[slug]'>) {
   *   const { slug } = await props.params
   *   return <div>Blog post: {slug}</div>
   * }
   * ```
   */
  interface PageProps<AppRoute extends AppRoutes> {
    params: Promise<ParamMap[AppRoute]>
    searchParams: Promise<Record<string, string | string[] | undefined>>
  }

  /**
   * Props for Next.js App Router layout components
   * @example
   * ```tsx
   * export default function Layout(props: LayoutProps<'/dashboard'>) {
   *   return <div>{props.children}</div>
   * }
   * ```
   */
  type LayoutProps<LayoutRoute extends LayoutRoutes> = {
    params: Promise<ParamMap[LayoutRoute]>
    children: React.ReactNode
  } & {
    [K in LayoutSlotMap[LayoutRoute]]: React.ReactNode
  }
}

--- FILE: types/validator.ts ---

// This file is generated automatically by Next.js
// Do not edit this file manually
// This file validates that all pages and layouts export the correct types

import type { AppRoutes, LayoutRoutes, ParamMap } from "./routes.js"
import type { ResolvingMetadata, ResolvingViewport } from "next/types.js"

type AppPageConfig<Route extends AppRoutes = AppRoutes> = {
  default: React.ComponentType<{ params: Promise<ParamMap[Route]> } & any> | ((props: { params: Promise<ParamMap[Route]> } & any) => React.ReactNode | Promise<React.ReactNode> | never | void | Promise<void>)
  generateStaticParams?: (props: { params: ParamMap[Route] }) => Promise<any[]> | any[]
  generateMetadata?: (
    props: { params: Promise<ParamMap[Route]> } & any,
    parent: ResolvingMetadata
  ) => Promise<any> | any
  generateViewport?: (
    props: { params: Promise<ParamMap[Route]> } & any,
    parent: ResolvingViewport
  ) => Promise<any> | any
  metadata?: any
  viewport?: any
}

type LayoutConfig<Route extends LayoutRoutes = LayoutRoutes> = {
  default: React.ComponentType<LayoutProps<Route>> | ((props: LayoutProps<Route>) => React.ReactNode | Promise<React.ReactNode> | never | void | Promise<void>)
  generateStaticParams?: (props: { params: ParamMap[Route] }) => Promise<any[]> | any[]
  generateMetadata?: (
    props: { params: Promise<ParamMap[Route]> } & any,
    parent: ResolvingMetadata
  ) => Promise<any> | any
  generateViewport?: (
    props: { params: Promise<ParamMap[Route]> } & any,
    parent: ResolvingViewport
  ) => Promise<any> | any
  metadata?: any
  viewport?: any
}


// Validate ../../app/page.tsx
{
  type __IsExpected<Specific extends AppPageConfig<"/">> = Specific
  const handler = {} as typeof import("../../app/page.js")
  type __Check = __IsExpected<typeof handler>
  // @ts-ignore
  type __Unused = __Check
}







// Validate ../../app/layout.tsx
{
  type __IsExpected<Specific extends LayoutConfig<"/">> = Specific
  const handler = {} as typeof import("../../app/layout.js")
  type __Check = __IsExpected<typeof handler>
  // @ts-ignore
  type __Unused = __Check
}
