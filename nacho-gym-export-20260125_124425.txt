NACHO GYM - Export 20260125_124425


### CONFIG ###


=== package.json ===

{
  "name": "sgf",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:push": "prisma db push",
    "prisma:studio": "prisma studio",
    "prisma:seed": "tsx prisma/seed.ts",
    "prisma:reset": "prisma migrate reset",
    "db:seed": "tsx prisma/seed.ts"
  },
  "prisma": {
    "seed": "tsx seed.ts"
  },
  "dependencies": {
    "@prisma/adapter-pg": "^7.2.0",
    "@prisma/client": "^6.19.2",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-slot": "^1.2.4",
    "better-auth": "^1.4.12",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dotenv": "^17.2.3",
    "lucide-react": "^0.562.0",
    "next": "16.1.1",
    "pg": "^8.16.3",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "tailwind-merge": "^3.4.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/pg": "^8.16.0",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.1.1",
    "prisma": "^6.19.2",
    "tailwindcss": "^4",
    "tsx": "^4.21.0",
    "tw-animate-css": "^1.4.0",
    "typescript": "^5"
  }
}



=== tsconfig.json ===

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"],
      "@prisma/client": ["./app/generated/prisma"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}



=== next.config.ts ===

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;



=== components.json ===

{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}




### PRISMA ###


=== prisma/schema.prisma ===

generator client {
  provider = "prisma-client-js"
  output   = "../app/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== ENUMS ====================

enum Role {
  ADMIN
  EMPLEADO
}

enum MembershipType {
  VISIT
  WEEK
  MONTH_STUDENT
  MONTH_GENERAL
  QUARTER_STUDENT
  QUARTER_GENERAL
  ANNUAL_STUDENT
  ANNUAL_GENERAL
  PROMOTION
  REBIRTH
  NUTRITION_CONSULTATION
}

enum InventoryType {
  SALE
  ADJUSTMENT
  WAREHOUSE_ENTRY
  GYM_ENTRY
  TRANSFER_TO_GYM
  TRANSFER_TO_WAREHOUSE
}

enum Location {
  WAREHOUSE
  GYM
}

enum PaymentMethod {
  CASH
  DEBIT_CARD
  CREDIT_CARD
  TRANSFER
}

// ==================== BETTER AUTH ====================

model User {
  id            String    @id
  name          String
  email         String    @unique
  emailVerified Boolean   @default(false)
  image         String?
  role          Role      @default(EMPLEADO)
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  sessions      Session[]
  accounts      Account[]
  shifts        Shift[]
  inventoryMovements InventoryMovement[]

  @@index([email])
  @@index([role, isActive])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@index([expiresAt])
  @@map("verification")
}

// ==================== MEMBERS ====================

model Member {
  id                     Int             @id @default(autoincrement())
  memberNumber           String          @unique
  name                   String?
  phone                  String?
  email                  String?
  birthDate              DateTime?
  membershipType         MembershipType?
  membershipDescription  String?
  startDate              DateTime?
  endDate                DateTime?
  totalVisits            Int             @default(0)
  lastVisit              DateTime?
  isActive               Boolean         @default(true)
  createdAt              DateTime        @default(now())
  updatedAt              DateTime        @updatedAt
  
  inventoryMovements InventoryMovement[]

  @@index([memberNumber])
  @@index([email])
  @@index([isActive])
  @@index([membershipType, isActive])
  @@index([endDate, isActive])
  @@map("member")
}

// ==================== PRODUCTS ====================

model Product {
  id               Int      @id @default(autoincrement())
  name             String   @unique
  salePrice        Decimal  @default(0) @db.Decimal(10, 2)
  warehouseStock   Int      @default(0)
  gymStock         Int      @default(0)
  minStock         Int      @default(0)
  isActive         Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  inventoryMovements InventoryMovement[]

  @@index([name])
  @@index([isActive])
  @@index([gymStock, minStock])
  @@index([warehouseStock, minStock])
  @@map("product")
}

// ==================== INVENTORY ====================

model InventoryMovement {
  id             Int             @id @default(autoincrement())
  productId      Int
  type           InventoryType
  location       Location
  /// Positive = stock entry, Negative = stock exit
  quantity       Int
  
  ticket         String?
  memberId       Int?
  userId         String
  unitPrice      Decimal?        @db.Decimal(10, 2)
  subtotal       Decimal?        @db.Decimal(10, 2)
  discount       Decimal?        @default(0) @db.Decimal(10, 2)
  surcharge      Decimal?        @default(0) @db.Decimal(10, 2)
  total          Decimal?        @db.Decimal(10, 2)
  paymentMethod  PaymentMethod?
  
  shiftId              Int?
  notes                String?
  isCancelled          Boolean  @default(false)
  cancellationReason   String?
  cancellationDate     DateTime?
  
  /// Actual movement date
  date          DateTime @default(now())
  /// System creation date
  createdAt     DateTime @default(now())

  product Product @relation(fields: [productId], references: [id])
  member  Member?  @relation(fields: [memberId], references: [id])
  user    User     @relation(fields: [userId], references: [id])
  shift   Shift?   @relation(fields: [shiftId], references: [id])

  @@index([productId])
  @@index([memberId])
  @@index([userId])
  @@index([shiftId])
  @@index([ticket])
  @@index([type])
  @@index([date])
  @@index([productId, date])
  @@index([isCancelled, date])
  @@index([shiftId, date])
  @@index([type, isCancelled])
  @@map("inventory_movement")
}

// ==================== SHIFTS ====================

model Shift {
  id                   Int      @id @default(autoincrement())
  folio                String   @unique
  cashierId            String
  openingDate          DateTime
  closingDate          DateTime?
  initialCash          Decimal  @db.Decimal(10, 2)
  ticketCount          Int      @default(0)
  membershipSales      Decimal  @default(0) @db.Decimal(10, 2)
  productSales0Tax     Decimal  @default(0) @db.Decimal(10, 2)
  productSales16Tax    Decimal  @default(0) @db.Decimal(10, 2)
  subtotal             Decimal  @default(0) @db.Decimal(10, 2)
  tax                  Decimal  @default(0) @db.Decimal(10, 2)
  totalSales           Decimal  @default(0) @db.Decimal(10, 2)
  cashAmount           Decimal  @default(0) @db.Decimal(10, 2)
  debitCardAmount      Decimal  @default(0) @db.Decimal(10, 2)
  creditCardAmount     Decimal  @default(0) @db.Decimal(10, 2)
  totalVoucher         Decimal  @default(0) @db.Decimal(10, 2)
  totalWithdrawals     Decimal  @default(0) @db.Decimal(10, 2)
  withdrawalsConcept   String?
  cancelledSales       Decimal  @default(0) @db.Decimal(10, 2)
  totalCash            Decimal  @default(0) @db.Decimal(10, 2)
  difference           Decimal  @default(0) @db.Decimal(10, 2)
  notes                String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  cashier User @relation(fields: [cashierId], references: [id])
  inventoryMovements InventoryMovement[]

  @@index([cashierId])
  @@index([openingDate])
  @@index([closingDate])
  @@index([folio])
  @@map("shift")
}


=== prisma/seed.ts ===

// prisma/seed.ts
import { PrismaClient } from "@prisma/client";
import { auth } from "../lib/auth";

const prisma = new PrismaClient();

async function main() {
  console.log("üå± Iniciando seed...");

  // ==================== USUARIOS ====================
  console.log("\nüìã Creando usuarios...");

  const users = [
    {
      name: "Nacho",
      email: "nacho@nachogym.com",
      password: "123",
      role: "ADMIN",
    },
    {
      name: "Carlos",
      email: "carlos@nachogym.com",
      password: "123",
      role: "EMPLEADO",
    },
    {
      name: "Andrew",
      email: "andrew@nachogym.com",
      password: "123",
      role: "EMPLEADO",
    },
  ];

  for (const userData of users) {
    try {
      await auth.api.signUpEmail({
        body: {
          name: userData.name,
          email: userData.email,
          password: userData.password,
        },
      });
      console.log(`‚úÖ ${userData.name} creado`);
    } catch (e: any) {
      if (e.message?.includes("already exists")) {
        console.log(`‚ÑπÔ∏è  ${userData.name} ya existe`);
      } else {
        throw e;
      }
    }
  }

  // Actualizar roles
  for (const userData of users) {
    await prisma.user.update({
      where: { email: userData.email },
      data: { role: userData.role, isActive: true },
    });
  }
  console.log("‚úÖ Roles actualizados");

  // Obtener IDs de usuarios
  const adminNacho = await prisma.user.findUnique({
    where: { email: "nacho@nachogym.com" },
  });
  const employeeCarlos = await prisma.user.findUnique({
    where: { email: "carlos@nachogym.com" },
  });
  const employeeAndrew = await prisma.user.findUnique({
    where: { email: "andrew@nachogym.com" },
  });

  if (!adminNacho || !employeeCarlos || !employeeAndrew) {
    throw new Error("No se pudieron crear los usuarios");
  }

  // ==================== PRODUCTOS ====================
  console.log("\nüì¶ Creando productos...");

  const productosData = [
    // Bebidas
    { name: "AGUA 1L", price: 15.0, minStock: 10 },
    { name: "AGUA CIEL 1.5L", price: 25.0, minStock: 8 },
    { name: "AGUA CIEL 600ML", price: 10.0, minStock: 15 },
    { name: "GATORADE 500ML", price: 22.0, minStock: 10 },
    { name: "COCA COLA", price: 18.0, minStock: 12 },
    { name: "DELAWARE PUNCH 600", price: 20.0, minStock: 8 },
    { name: "POWERADE 600ML", price: 20.0, minStock: 10 },

    // Energ√©ticas
    { name: "MONSTER ENERGY", price: 35.0, minStock: 6 },
    { name: "MONSTER BLANCO", price: 42.0, minStock: 4 },
    { name: "RED BULL", price: 38.0, minStock: 6 },

    // Hidratantes
    { name: "ELECTROLIT COCO", price: 25.0, minStock: 8 },
    { name: "ELECTROLIT NARANJA MANDARINA", price: 25.0, minStock: 8 },
    { name: "H2O POWER", price: 25.0, minStock: 6 },
    { name: "HIDRO PLEX ROMPOPE", price: 30.0, minStock: 4 },

    // Snacks
    { name: "BARRA PROTEINA", price: 45.0, minStock: 10 },
    { name: "GALLETAS PROTEINA", price: 35.0, minStock: 8 },
    { name: "CREATINA MONOHIDRATADA", price: 350.0, minStock: 3 },
    { name: "PROTEINA WHEY 1KG", price: 680.0, minStock: 2 },

    // Membres√≠as
    { name: "VISITA", price: 50.0, minStock: 0 },
    { name: "EFECTIVO SEMANA", price: 180.0, minStock: 0 },
    { name: "EFECTIVO MENSUALIDAD ESTUDIANTE", price: 450.0, minStock: 0 },
    { name: "EFECTIVO MENSUALIDAD GENERAL", price: 540.0, minStock: 0 },
    { name: "EFECTIVO TRIMESTRE ESTUDIANTE", price: 1215.0, minStock: 0 },
    { name: "EFECTIVO TRIMESTRE GENERAL", price: 1458.0, minStock: 0 },
    { name: "EFECTIVO ANUAL ESTUDIANTE", price: 4320.0, minStock: 0 },
    { name: "EFECTIVO ANUAL GENERAL", price: 5184.0, minStock: 0 },
  ];

  for (const product of productosData) {
    await prisma.product.upsert({
      where: { name: product.name },
      update: { salePrice: product.price },
      create: {
        name: product.name,
        salePrice: product.price,
        warehouseStock: 0,
        gymStock: 0,
        minStock: product.minStock,
        isActive: true,
      },
    });
  }
  console.log(`‚úÖ ${productosData.length} productos creados`);

  // ==================== INVENTARIO INICIAL ====================
  console.log("\nüìä Estableciendo inventario inicial...");

  const inventarioInicial = [
    { product: "AGUA 1L", warehouse: 30, gym: 20 },
    { product: "AGUA CIEL 1.5L", warehouse: 40, gym: 15 },
    { product: "AGUA CIEL 600ML", warehouse: 50, gym: 25 },
    { product: "GATORADE 500ML", warehouse: 24, gym: 12 },
    { product: "COCA COLA", warehouse: 30, gym: 15 },
    { product: "DELAWARE PUNCH 600", warehouse: 20, gym: 10 },
    { product: "POWERADE 600ML", warehouse: 24, gym: 12 },
    { product: "MONSTER ENERGY", warehouse: 12, gym: 6 },
    { product: "MONSTER BLANCO", warehouse: 8, gym: 4 },
    { product: "RED BULL", warehouse: 12, gym: 6 },
    { product: "ELECTROLIT COCO", warehouse: 16, gym: 8 },
    { product: "ELECTROLIT NARANJA MANDARINA", warehouse: 16, gym: 8 },
    { product: "H2O POWER", warehouse: 12, gym: 6 },
    { product: "HIDRO PLEX ROMPOPE", warehouse: 10, gym: 4 },
    { product: "BARRA PROTEINA", warehouse: 30, gym: 15 },
    { product: "GALLETAS PROTEINA", warehouse: 20, gym: 10 },
    { product: "CREATINA MONOHIDRATADA", warehouse: 6, gym: 2 },
    { product: "PROTEINA WHEY 1KG", warehouse: 4, gym: 2 },
  ];

  for (const inv of inventarioInicial) {
    const product = await prisma.product.findFirst({
      where: { name: inv.product },
    });

    if (product) {
      await prisma.product.update({
        where: { id: product.id },
        data: {
          warehouseStock: inv.warehouse,
          gymStock: inv.gym,
        },
      });

      // Entrada a bodega
      await prisma.inventoryMovement.create({
        data: {
          productId: product.id,
          type: "WAREHOUSE_ENTRY",
          location: "WAREHOUSE",
          quantity: inv.warehouse,
          userId: adminNacho.id,
          notes: "Inventario inicial bodega",
          date: new Date("2026-01-10T08:00:00"),
        },
      });

      // Entrada a gym
      await prisma.inventoryMovement.create({
        data: {
          productId: product.id,
          type: "GYM_ENTRY",
          location: "GYM",
          quantity: inv.gym,
          userId: adminNacho.id,
          notes: "Inventario inicial gym",
          date: new Date("2026-01-10T08:30:00"),
        },
      });
    }
  }
  console.log("‚úÖ Inventario inicial establecido");

  // ==================== SOCIOS ====================
  console.log("\nüë• Creando socios...");

  const sociosData = [
    {
      memberNumber: "FN643",
      name: "VANESSA CORTES ROMERO",
      phone: "311-555-0101",
      email: "vanessa.cortes@email.com",
      membershipType: "MONTH_GENERAL",
      membershipDescription: "EFECTIVO MENSUALIDAD GENERAL ENE 2026",
      startDate: new Date("2026-01-13"),
      endDate: new Date("2026-02-13"),
    },
    {
      memberNumber: "FN671",
      name: "TANIA NERINA JIMENEZ PE√ëA",
      phone: "311-555-0102",
      email: "tania.jimenez@email.com",
      membershipType: "MONTH_STUDENT",
      membershipDescription: "EFECTIVO MENSUALIDAD ESTUDIANTE ENE 2026",
      startDate: new Date("2026-01-13"),
      endDate: new Date("2026-02-13"),
    },
    {
      memberNumber: "FN687",
      name: "GOLIAT ORTIZ LOPEZ",
      phone: "311-555-0103",
      membershipType: "WEEK",
      membershipDescription: "EFECTIVO SEMANA ENE 2026",
      startDate: new Date("2026-01-13"),
      endDate: new Date("2026-01-20"),
    },
    {
      memberNumber: "FN389",
      name: "PAOLA VELAZQUEZ ORNELAS",
      phone: "311-555-0104",
      email: "paola.velazquez@email.com",
      membershipType: "MONTH_GENERAL",
      membershipDescription: "EFECTIVO MENSUALIDAD GENERAL ENE 2026",
      startDate: new Date("2026-01-13"),
      endDate: new Date("2026-02-13"),
    },
    {
      memberNumber: "FN512",
      name: "ROBERTO MARTINEZ CRUZ",
      phone: "311-555-0105",
      membershipType: "QUARTER_GENERAL",
      membershipDescription: "EFECTIVO TRIMESTRE GENERAL ENE 2026",
      startDate: new Date("2026-01-11"),
      endDate: new Date("2026-04-11"),
    },
    {
      memberNumber: "FN598",
      name: "MARIA FERNANDA LOPEZ",
      phone: "311-555-0106",
      email: "mafe.lopez@email.com",
      membershipType: "MONTH_STUDENT",
      membershipDescription: "EFECTIVO MENSUALIDAD ESTUDIANTE ENE 2026",
      startDate: new Date("2026-01-12"),
      endDate: new Date("2026-02-12"),
    },
    {
      memberNumber: "FN723",
      name: "JORGE ALBERTO RAMIREZ",
      phone: "311-555-0107",
      membershipType: "ANNUAL_GENERAL",
      membershipDescription: "EFECTIVO ANUAL GENERAL ENE 2026",
      startDate: new Date("2026-01-10"),
      endDate: new Date("2027-01-10"),
    },
    {
      memberNumber: "FN801",
      name: "DIANA PATRICIA MORALES",
      phone: "311-555-0108",
      email: "diana.morales@email.com",
      membershipType: "MONTH_GENERAL",
      membershipDescription: "EFECTIVO MENSUALIDAD GENERAL ENE 2026",
      startDate: new Date("2026-01-14"),
      endDate: new Date("2026-02-14"),
    },
  ];

  for (const socio of sociosData) {
    await prisma.member.upsert({
      where: { memberNumber: socio.memberNumber },
      update: {},
      create: socio,
    });
  }
  console.log(`‚úÖ ${sociosData.length} socios creados`);

  // ==================== CORTE 1 (11 de enero) ====================
  console.log("\nüí∞ Creando corte 1 (11 de enero)...");

  const shift1 = await prisma.shift.create({
    data: {
      folio: "FN-247",
      cashierId: adminNacho.id,
      openingDate: new Date("2026-01-11T09:00:00"),
      closingDate: new Date("2026-01-11T15:00:00"),
      initialCash: 500.0,
      ticketCount: 5,
      membershipSales: 6399.0,
      productSales0Tax: 175.0,
      productSales16Tax: 0,
      subtotal: 6574.0,
      tax: 0,
      totalSales: 6574.0,
      cashAmount: 6574.0,
      debitCardAmount: 0,
      creditCardAmount: 0,
      totalVoucher: 0,
      totalWithdrawals: 0,
      totalCash: 7074.0,
      difference: 0,
      notes: "Turno ma√±ana - S√°bado",
    },
  });

  // Ventas del corte 1
  const ventas1 = [
    {
      ticket: "5770",
      member: "FN512",
      product: "EFECTIVO TRIMESTRE GENERAL",
      user: adminNacho.id,
      time: "09:15:00",
    },
    {
      ticket: "5771",
      member: "FN723",
      product: "EFECTIVO ANUAL GENERAL",
      user: employeeCarlos.id,
      time: "09:45:00",
    },
    {
      ticket: "5772",
      member: "FN598",
      product: "EFECTIVO MENSUALIDAD ESTUDIANTE",
      user: employeeCarlos.id,
      time: "10:30:00",
    },
    {
      ticket: "5773",
      member: null,
      product: "VISITA",
      user: adminNacho.id,
      time: "11:15:00",
    },
  ];

  for (const venta of ventas1) {
    const product = await prisma.product.findFirst({
      where: { name: venta.product },
    });

    let memberData = null;
    if (venta.member) {
      memberData = await prisma.member.findFirst({
        where: { memberNumber: venta.member },
      });
    }

    if (product) {
      await prisma.inventoryMovement.create({
        data: {
          productId: product.id,
          type: "SALE",
          location: "GYM",
          quantity: -1,
          ticket: venta.ticket,
          memberId: memberData?.id,
          userId: venta.user,
          unitPrice: product.salePrice,
          subtotal: product.salePrice,
          discount: 0,
          surcharge: 0,
          total: product.salePrice,
          paymentMethod: "CASH",
          shiftId: shift1.id,
          date: new Date(`2026-01-11T${venta.time}`),
          notes: `Venta a ${memberData ? memberData.name : "PUBLICO GENERAL"}`,
        },
      });
    }
  }

  // Venta de productos f√≠sicos corte 1
  const agua = await prisma.product.findFirst({
    where: { name: "AGUA CIEL 1.5L" },
  });

  if (agua) {
    await prisma.inventoryMovement.create({
      data: {
        productId: agua.id,
        type: "SALE",
        location: "GYM",
        quantity: -3,
        ticket: "5774",
        userId: employeeAndrew.id,
        unitPrice: agua.salePrice,
        subtotal: agua.salePrice.toNumber() * 3,
        total: agua.salePrice.toNumber() * 3,
        paymentMethod: "CASH",
        shiftId: shift1.id,
        date: new Date("2026-01-11T14:00:00"),
        notes: "Venta de 3 aguas",
      },
    });

    await prisma.product.update({
      where: { id: agua.id },
      data: { gymStock: { decrement: 3 } },
    });
  }

  const gatorade = await prisma.product.findFirst({
    where: { name: "GATORADE 500ML" },
  });

  if (gatorade) {
    await prisma.inventoryMovement.create({
      data: {
        productId: gatorade.id,
        type: "SALE",
        location: "GYM",
        quantity: -2,
        ticket: "5774",
        userId: employeeAndrew.id,
        unitPrice: gatorade.salePrice,
        subtotal: gatorade.salePrice.toNumber() * 2,
        total: gatorade.salePrice.toNumber() * 2,
        paymentMethod: "CASH",
        shiftId: shift1.id,
        date: new Date("2026-01-11T14:00:00"),
        notes: "Venta de 2 gatorades",
      },
    });

    await prisma.product.update({
      where: { id: gatorade.id },
      data: { gymStock: { decrement: 2 } },
    });
  }

  console.log("‚úÖ Corte 1 completado");

  // ==================== CORTE 2 (12 de enero) ====================
  console.log("\nüí∞ Creando corte 2 (12 de enero)...");

  const shift2 = await prisma.shift.create({
    data: {
      folio: "FN-248",
      cashierId: employeeCarlos.id,
      openingDate: new Date("2026-01-12T09:00:00"),
      closingDate: new Date("2026-01-12T14:30:00"),
      initialCash: 500.0,
      ticketCount: 4,
      membershipSales: 450.0,
      productSales0Tax: 132.0,
      productSales16Tax: 0,
      subtotal: 582.0,
      tax: 0,
      totalSales: 582.0,
      cashAmount: 582.0,
      debitCardAmount: 0,
      creditCardAmount: 0,
      totalVoucher: 0,
      totalWithdrawals: 0,
      totalCash: 1082.0,
      difference: 0,
      notes: "Turno tarde - Domingo",
    },
  });

  const ventas2 = [
    {
      ticket: "5775",
      member: "FN598",
      product: "EFECTIVO MENSUALIDAD ESTUDIANTE",
      user: employeeCarlos.id,
      time: "09:30:00",
    },
  ];

  for (const venta of ventas2) {
    const product = await prisma.product.findFirst({
      where: { name: venta.product },
    });

    const memberData = await prisma.member.findFirst({
      where: { memberNumber: venta.member },
    });

    if (product && memberData) {
      await prisma.inventoryMovement.create({
        data: {
          productId: product.id,
          type: "SALE",
          location: "GYM",
          quantity: -1,
          ticket: venta.ticket,
          memberId: memberData.id,
          userId: venta.user,
          unitPrice: product.salePrice,
          subtotal: product.salePrice,
          discount: 0,
          surcharge: 0,
          total: product.salePrice,
          paymentMethod: "CASH",
          shiftId: shift2.id,
          date: new Date(`2026-01-12T${venta.time}`),
          notes: `Venta a ${memberData.name}`,
        },
      });
    }
  }

  // Ventas de productos varios
  const productosVenta2 = [
    { name: "BARRA PROTEINA", qty: 2, ticket: "5776" },
    { name: "ELECTROLIT COCO", qty: 2, ticket: "5777" },
    { name: "MONSTER ENERGY", qty: 1, ticket: "5778" },
  ];

  for (const pv of productosVenta2) {
    const product = await prisma.product.findFirst({
      where: { name: pv.name },
    });

    if (product) {
      await prisma.inventoryMovement.create({
        data: {
          productId: product.id,
          type: "SALE",
          location: "GYM",
          quantity: -pv.qty,
          ticket: pv.ticket,
          userId: employeeAndrew.id,
          unitPrice: product.salePrice,
          subtotal: product.salePrice.toNumber() * pv.qty,
          total: product.salePrice.toNumber() * pv.qty,
          paymentMethod: "CASH",
          shiftId: shift2.id,
          date: new Date("2026-01-12T11:00:00"),
          notes: `Venta de ${pv.qty} ${pv.name}`,
        },
      });

      await prisma.product.update({
        where: { id: product.id },
        data: { gymStock: { decrement: pv.qty } },
      });
    }
  }

  console.log("‚úÖ Corte 2 completado");

  // ==================== CORTE 3 (13 de enero) ====================
  console.log("\nüí∞ Creando corte 3 (13 de enero)...");

  const shift3 = await prisma.shift.create({
    data: {
      folio: "FN-249",
      cashierId: adminNacho.id,
      openingDate: new Date("2026-01-13T09:25:00"),
      closingDate: new Date("2026-01-13T14:08:00"),
      initialCash: 500.0,
      ticketCount: 6,
      membershipSales: 0,
      productSales0Tax: 1940.0,
      productSales16Tax: 0,
      subtotal: 1890.0,
      tax: 50.0,
      totalSales: 1940.0,
      cashAmount: 1940.0,
      debitCardAmount: 0,
      creditCardAmount: 0,
      totalVoucher: 0,
      totalWithdrawals: 0,
      totalCash: 2440.0,
      difference: 0,
      notes: "Turno ma√±ana",
    },
  });

  const ventas3 = [
    {
      ticket: "5780",
      member: "FN643",
      product: "EFECTIVO MENSUALIDAD GENERAL",
      user: employeeCarlos.id,
      time: "09:28:00",
    },
    {
      ticket: "5781",
      member: "FN671",
      product: "EFECTIVO MENSUALIDAD ESTUDIANTE",
      user: employeeCarlos.id,
      time: "09:32:00",
    },
    {
      ticket: "5782",
      member: null,
      product: "VISITA",
      user: employeeCarlos.id,
      time: "10:03:00",
    },
    {
      ticket: "5783",
      member: "FN687",
      product: "EFECTIVO SEMANA",
      user: employeeCarlos.id,
      time: "10:20:00",
    },
    {
      ticket: "5784",
      member: "FN389",
      product: "EFECTIVO MENSUALIDAD GENERAL",
      user: employeeCarlos.id,
      time: "13:29:00",
    },
  ];

  for (const venta of ventas3) {
    const product = await prisma.product.findFirst({
      where: { name: venta.product },
    });

    let memberData = null;
    if (venta.member) {
      memberData = await prisma.member.findFirst({
        where: { memberNumber: venta.member },
      });
    }

    if (product) {
      await prisma.inventoryMovement.create({
        data: {
          productId: product.id,
          type: "SALE",
          location: "GYM",
          quantity: -1,
          ticket: venta.ticket,
          memberId: memberData?.id,
          userId: venta.user,
          unitPrice: product.salePrice,
          subtotal: product.salePrice,
          discount: 0,
          surcharge: 0,
          total: product.salePrice,
          paymentMethod: "CASH",
          shiftId: shift3.id,
          date: new Date(`2026-01-13T${venta.time}`),
          notes: `Venta a ${memberData ? memberData.name : "PUBLICO GENERAL"}`,
        },
      });
    }
  }

  // Venta de producto f√≠sico
  const aguaCiel = await prisma.product.findFirst({
    where: { name: "AGUA CIEL 1.5L" },
  });

  if (aguaCiel) {
    await prisma.inventoryMovement.create({
      data: {
        productId: aguaCiel.id,
        type: "SALE",
        location: "GYM",
        quantity: -2,
        ticket: "5785",
        userId: employeeAndrew.id,
        unitPrice: aguaCiel.salePrice,
        subtotal: aguaCiel.salePrice.toNumber() * 2,
        total: aguaCiel.salePrice.toNumber() * 2,
        paymentMethod: "CASH",
        shiftId: shift3.id,
        date: new Date("2026-01-13T14:00:00"),
        notes: "Venta de 2 aguas",
      },
    });

    await prisma.product.update({
      where: { id: aguaCiel.id },
      data: { gymStock: { decrement: 2 } },
    });
  }

  console.log("‚úÖ Corte 3 completado");

  // ==================== CORTE 4 (14 de enero) ====================
  console.log("\nüí∞ Creando corte 4 (14 de enero)...");

  const shift4 = await prisma.shift.create({
    data: {
      folio: "FN-250",
      cashierId: employeeCarlos.id,
      openingDate: new Date("2026-01-14T09:00:00"),
      closingDate: new Date("2026-01-14T15:30:00"),
      initialCash: 500.0,
      ticketCount: 7,
      membershipSales: 540.0,
      productSales0Tax: 287.0,
      productSales16Tax: 0,
      subtotal: 827.0,
      tax: 0,
      totalSales: 827.0,
      cashAmount: 627.0,
      debitCardAmount: 200.0,
      creditCardAmount: 0,
      totalVoucher: 200.0,
      totalWithdrawals: 0,
      totalCash: 1127.0,
      difference: 0,
      notes: "Turno completo",
    },
  });

  const ventas4 = [
    {
      ticket: "5786",
      member: "FN801",
      product: "EFECTIVO MENSUALIDAD GENERAL",
      user: employeeCarlos.id,
      payment: "CASH",
      time: "09:30:00",
    },
    {
      ticket: "5787",
      member: null,
      product: "VISITA",
      user: employeeAndrew.id,
      payment: "CASH",
      time: "10:15:00",
    },
    {
      ticket: "5788",
      member: null,
      product: "VISITA",
      user: employeeCarlos.id,
      payment: "CASH",
      time: "11:00:00",
    },
  ];

  for (const venta of ventas4) {
    const product = await prisma.product.findFirst({
      where: { name: venta.product },
    });

    let memberData = null;
    if (venta.member) {
      memberData = await prisma.member.findFirst({
        where: { memberNumber: venta.member },
      });
    }

    if (product) {
      await prisma.inventoryMovement.create({
        data: {
          productId: product.id,
          type: "SALE",
          location: "GYM",
          quantity: -1,
          ticket: venta.ticket,
          memberId: memberData?.id,
          userId: venta.user,
          unitPrice: product.salePrice,
          subtotal: product.salePrice,
          discount: 0,
          surcharge: 0,
          total: product.salePrice,
          paymentMethod: venta.payment as any,
          shiftId: shift4.id,
          date: new Date(`2026-01-14T${venta.time}`),
          notes: `Venta a ${memberData ? memberData.name : "PUBLICO GENERAL"}`,
        },
      });
    }
  }

  // Ventas con tarjeta
  const productosVenta4 = [
    {
      name: "PROTEINA WHEY 1KG",
      qty: 1,
      ticket: "5789",
      payment: "DEBIT_CARD",
    },
    { name: "RED BULL", qty: 2, ticket: "5790", payment: "CASH" },
    { name: "BARRA PROTEINA", qty: 3, ticket: "5791", payment: "CASH" },
  ];

  for (const pv of productosVenta4) {
    const product = await prisma.product.findFirst({
      where: { name: pv.name },
    });

    if (product) {
      await prisma.inventoryMovement.create({
        data: {
          productId: product.id,
          type: "SALE",
          location: "GYM",
          quantity: -pv.qty,
          ticket: pv.ticket,
          userId: employeeAndrew.id,
          unitPrice: product.salePrice,
          subtotal: product.salePrice.toNumber() * pv.qty,
          total: product.salePrice.toNumber() * pv.qty,
          paymentMethod: pv.payment as any,
          shiftId: shift4.id,
          date: new Date("2026-01-14T13:00:00"),
          notes: `Venta de ${pv.qty} ${pv.name}`,
        },
      });

      await prisma.product.update({
        where: { id: product.id },
        data: { gymStock: { decrement: pv.qty } },
      });
    }
  }

  console.log("‚úÖ Corte 4 completado");

  // ==================== MOVIMIENTOS DE INVENTARIO ====================
  console.log("\nüì¶ Creando movimientos de inventario...");

  // Traspaso BODEGA ‚Üí GYM
  const cocaCola = await prisma.product.findFirst({
    where: { name: "COCA COLA" },
  });

  if (cocaCola) {
    const transferQty = 10;

    await prisma.inventoryMovement.create({
      data: {
        productId: cocaCola.id,
        type: "TRANSFER_TO_GYM",
        location: "GYM",
        quantity: transferQty,
        userId: adminNacho.id,
        date: new Date("2026-01-13T16:00:00"),
        notes: `Traspaso de ${transferQty} unidades de BODEGA a GYM`,
      },
    });

    await prisma.product.update({
      where: { id: cocaCola.id },
      data: {
        warehouseStock: { decrement: transferQty },
        gymStock: { increment: transferQty },
      },
    });
  }

  // Ajuste de inventario
  const agua1L = await prisma.product.findFirst({
    where: { name: "AGUA 1L" },
  });

  if (agua1L) {
    const adjustment = -3;

    await prisma.inventoryMovement.create({
      data: {
        productId: agua1L.id,
        type: "ADJUSTMENT",
        location: "GYM",
        quantity: adjustment,
        userId: adminNacho.id,
        date: new Date("2026-01-14T17:00:00"),
        notes: "Ajuste por rotura de envases",
      },
    });

    await prisma.product.update({
      where: { id: agua1L.id },
      data: { gymStock: { increment: adjustment } },
    });
  }

  // Entrada de producto
  const creatina = await prisma.product.findFirst({
    where: { name: "CREATINA MONOHIDRATADA" },
  });

  if (creatina) {
    const entryQty = 5;

    await prisma.inventoryMovement.create({
      data: {
        productId: creatina.id,
        type: "WAREHOUSE_ENTRY",
        location: "WAREHOUSE",
        quantity: entryQty,
        userId: adminNacho.id,
        date: new Date("2026-01-15T10:00:00"),
        notes: "Entrada de proveedor - Factura #12345",
      },
    });

    await prisma.product.update({
      where: { id: creatina.id },
      data: { warehouseStock: { increment: entryQty } },
    });
  }

  console.log("‚úÖ Movimientos de inventario creados");

  // ==================== RESUMEN ====================
  console.log("\n‚úÖ Seed completado exitosamente!");
  console.log("");
  console.log("üìä Resumen:");
  console.log("   üë§ 3 usuarios creados");
  console.log(`   üì¶ ${productosData.length} productos creados`);
  console.log(`   üë• ${sociosData.length} socios creados`);
  console.log("   üí∞ 4 cortes creados");
  console.log("   üîÑ M√∫ltiples movimientos de inventario");
  console.log("");
  console.log("üîë Credenciales:");
  console.log("   Nacho (admin): nacho@nachogym.com / 123");
  console.log("   Carlos: carlos@nachogym.com / 123");
  console.log("   Andrew: andrew@nachogym.com / 123");
}

main()
  .catch((e) => {
    console.error("‚ùå Error:", e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });




### LIB ###


=== lib/auth.ts ===

import { betterAuth } from "better-auth";
import { prismaAdapter } from "better-auth/adapters/prisma";
import { PrismaClient } from "@/app/generated/prisma/client";
import { nextCookies } from "better-auth/next-js";

const prisma = new PrismaClient();

export const auth = betterAuth({
  database: prismaAdapter(prisma, {
    provider: "postgresql",
  }),

  emailAndPassword: {
    enabled: true,
    minPasswordLength: 3, // ‚úÖ Permitir "123" (por defecto es 8)
  },

  plugins: [nextCookies()],

  secret: process.env.NEXTAUTH_SECRET,
  baseURL: process.env.NEXTAUTH_URL || "http://localhost:3000",
});



=== lib/auth-client.ts ===

import { createAuthClient } from "better-auth/react";
export const authClient = createAuthClient({
  /** The base URL of the server (optional if you're using the same domain) */
  baseURL: "http://localhost:3000",
});



=== lib/db.ts ===

// lib/db.ts
import { PrismaClient } from "@prisma/client";

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: ["error"],
  });

if (process.env.NODE_ENV !== "production") {
  globalForPrisma.prisma = prisma;
}



=== lib/utils.ts ===

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}




### ROOT ###


=== app/layout.tsx ===

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}



=== app/globals.css ===

@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --radius-2xl: calc(var(--radius) + 8px);
  --radius-3xl: calc(var(--radius) + 12px);
  --radius-4xl: calc(var(--radius) + 16px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}



=== app/login/page.tsx ===

/* eslint-disable @typescript-eslint/no-unused-vars */
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { authClient } from "@/lib/auth-client";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";

export default function LoginPage() {
  const router = useRouter();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      await authClient.signIn.email({
        email,
        password,
      });
      router.push("/");
    } catch (err) {
      setError("Credenciales incorrectas");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-100">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1">
          <CardTitle className="text-2xl font-bold">Nacho Gym</CardTitle>
          <CardDescription>
            Ingresa tus credenciales para acceder al sistema
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email">Correo electr√≥nico</Label>
              <Input
                id="email"
                type="email"
                placeholder="nacho@nachogym.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                autoComplete="email"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">Contrase√±a</Label>
              <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                autoComplete="current-password"
              />
            </div>
            {error && (
              <div className="rounded-lg bg-red-50 p-3 text-sm text-red-600">
                {error}
              </div>
            )}
            <Button type="submit" className="w-full" disabled={loading}>
              {loading ? "Iniciando sesi√≥n..." : "Iniciar Sesi√≥n"}
            </Button>
          </form>
          <div className="mt-4 text-center text-sm text-gray-500">
            <p>Usuarios de prueba:</p>
            <p className="mt-1">nacho@nachogym.com / 123</p>
            <p>carlos@nachogym.com / 123</p>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}




### DASHBOARD ###


=== app/(dashboard)/layout.tsx ===

import { redirect } from "next/navigation";
import { headers } from "next/headers";
import { auth } from "@/lib/auth";
import { Sidebar } from "@/components/layout/sidebar";
import { Header } from "@/components/layout/header";

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = await auth.api.getSession({
    headers: await headers(),
  });

  if (!session) {
    redirect("/login");
  }

  return (
    <div className="flex h-screen overflow-hidden">
      <Sidebar />
      <div className="flex flex-1 flex-col overflow-hidden">
        <Header user={session.user} />
        <main className="flex-1 overflow-y-auto bg-gray-50 p-6">
          {children}
        </main>
      </div>
    </div>
  );
}



=== app/(dashboard)/page.tsx ===

// app/(dashboard)/page.tsx
import {
  CortesService,
  InventarioService,
  SociosService,
  ReportesService,
} from "@/services";
import CorteAlert from "./corte-alert";
import DashboardStats from "./dashboard-stats";
import AlertasDashboard from "./alertas-dashboard";

async function getStatsDelDia() {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);

  const movimientos = await InventarioService.getMovimientosByFecha(
    today,
    tomorrow,
  );
  const ventas = movimientos.filter((m) => m.tipo === "VENTA" && !m.cancelada);
  const total = ventas.reduce((sum, v) => sum + Number(v.total || 0), 0);

  return { ventas: ventas.length, total };
}

export default async function DashboardPage() {
  const [corteActivo, stats, sociosVencidos, reporte] = await Promise.all([
    CortesService.getCorteActivo(),
    getStatsDelDia(),
    SociosService.getSociosVencidos(),
    ReportesService.getReporteStockActual(),
  ]);

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold">Dashboard</h1>
        <p className="text-gray-500">Resumen general del gimnasio</p>
      </div>

      <CorteAlert corteActivo={corteActivo} />

      <DashboardStats
        ventas={stats.ventas}
        total={stats.total}
        sociosVencidos={sociosVencidos.length}
        stockBajo={reporte.bajoStock.length}
      />

      <AlertasDashboard
        sociosVencidos={sociosVencidos}
        stockBajo={reporte.bajoStock}
      />
    </div>
  );
}



=== app/(dashboard)/dashboard-stats.tsx ===

// app/(dashboard)/dashboard-stats.tsx
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { DollarSign, ShoppingCart, Users, TrendingUp } from "lucide-react";

interface StatsProps {
  ventas: number;
  total: number;
  sociosVencidos: number;
  stockBajo: number;
}

export default function DashboardStats({
  ventas,
  total,
  sociosVencidos,
  stockBajo,
}: StatsProps) {
  return (
    <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between pb-2">
          <CardTitle className="text-sm font-medium">Ventas del D√≠a</CardTitle>
          <ShoppingCart className="h-4 w-4 text-gray-500" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{ventas}</div>
          <p className="text-xs text-gray-500">tickets registrados</p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between pb-2">
          <CardTitle className="text-sm font-medium">Total del D√≠a</CardTitle>
          <DollarSign className="h-4 w-4 text-gray-500" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">${total.toFixed(2)}</div>
          <p className="text-xs text-gray-500">en ventas</p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between pb-2">
          <CardTitle className="text-sm font-medium">Socios Vencidos</CardTitle>
          <Users className="h-4 w-4 text-gray-500" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{sociosVencidos}</div>
          <p className="text-xs text-gray-500">
            {sociosVencidos === 1 ? "socio" : "socios"}
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between pb-2">
          <CardTitle className="text-sm font-medium">Stock Bajo</CardTitle>
          <TrendingUp className="h-4 w-4 text-gray-500" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{stockBajo}</div>
          <p className="text-xs text-gray-500">
            {stockBajo === 1 ? "producto" : "productos"}
          </p>
        </CardContent>
      </Card>
    </div>
  );
}



=== app/(dashboard)/corte-alert.tsx ===

// app/(dashboard)/corte-alert.tsx
"use client";

import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { AlertCircle, CheckCircle } from "lucide-react";

interface CorteAlertProps {
  corteActivo: {
    folio: string;
    cajero: { name: string };
    fechaApertura: string;
    cantidadTickets: number;
  } | null;
}

export default function CorteAlert({ corteActivo }: CorteAlertProps) {
  if (corteActivo) {
    return (
      <Card className="border-green-200 bg-green-50">
        <CardContent className="flex items-center justify-between p-6">
          <div className="flex items-center gap-3">
            <CheckCircle className="h-6 w-6 text-green-600" />
            <div>
              <p className="font-semibold text-green-900">
                Corte Activo: {corteActivo.folio}
              </p>
              <p className="text-sm text-green-700">
                Cajero: {corteActivo.cajero.name} | Apertura:{" "}
                {new Date(corteActivo.fechaApertura).toLocaleTimeString()}
              </p>
            </div>
          </div>
          <Badge variant="outline" className="bg-white">
            Tickets: {corteActivo.cantidadTickets}
          </Badge>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="border-yellow-200 bg-yellow-50">
      <CardContent className="flex items-center gap-3 p-6">
        <AlertCircle className="h-6 w-6 text-yellow-600" />
        <p className="font-semibold text-yellow-900">
          No hay corte activo. Debe abrir uno para registrar ventas.
        </p>
      </CardContent>
    </Card>
  );
}



=== app/(dashboard)/alertas-dashboard.tsx ===

// app/(dashboard)/alertas-dashboard.tsx
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { AlertCircle } from "lucide-react";

interface Socio {
  id: number;
  nombre: string;
  numeroSocio: string;
}

interface Producto {
  id: number;
  nombre: string;
  existenciaGym: number;
  existenciaBodega: number;
  existenciaMin: number;
}

interface AlertasProps {
  sociosVencidos: Socio[];
  stockBajo: Producto[];
}

export default function AlertasDashboard({
  sociosVencidos,
  stockBajo,
}: AlertasProps) {
  return (
    <div className="grid gap-6 lg:grid-cols-2">
      {sociosVencidos.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <AlertCircle className="h-5 w-5 text-orange-500" />
              Socios con Membres√≠a Vencida
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              {sociosVencidos.slice(0, 5).map((socio) => (
                <div
                  key={socio.id}
                  className="flex items-center justify-between rounded-lg border p-3"
                >
                  <div>
                    <p className="font-medium">{socio.nombre}</p>
                    <p className="text-sm text-gray-500">{socio.numeroSocio}</p>
                  </div>
                  <Badge variant="destructive">Vencido</Badge>
                </div>
              ))}
              {sociosVencidos.length > 5 && (
                <p className="text-sm text-gray-500">
                  + {sociosVencidos.length - 5} m√°s
                </p>
              )}
            </div>
          </CardContent>
        </Card>
      )}

      {stockBajo.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <AlertCircle className="h-5 w-5 text-orange-500" />
              Productos con Stock Bajo
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              {stockBajo.slice(0, 5).map((producto) => (
                <div
                  key={producto.id}
                  className="flex items-center justify-between rounded-lg border p-3"
                >
                  <div>
                    <p className="font-medium">{producto.nombre}</p>
                    <p className="text-sm text-gray-500">
                      Gym: {producto.existenciaGym} | Bodega:{" "}
                      {producto.existenciaBodega}
                    </p>
                  </div>
                  <Badge variant="outline" className="bg-yellow-50">
                    Min: {producto.existenciaMin}
                  </Badge>
                </div>
              ))}
              {stockBajo.length > 5 && (
                <p className="text-sm text-gray-500">
                  + {stockBajo.length - 5} m√°s
                </p>
              )}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}




### COMPONENTS ###


=== components/layout/sidebar.tsx ===

"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";
import {
  LayoutDashboard,
  ShoppingCart,
  Users,
  Package,
  Archive,
  Calculator,
  History,
} from "lucide-react";

const navigation = [
  { name: "Dashboard", href: "/", icon: LayoutDashboard },
  { name: "Ventas", href: "/ventas", icon: ShoppingCart },
  { name: "Historial", href: "/ventas/historial", icon: History },
  { name: "Socios", href: "/socios", icon: Users },
  { name: "Productos", href: "/productos", icon: Package },
  { name: "Inventario", href: "/inventario", icon: Archive },
  { name: "Cortes", href: "/cortes", icon: Calculator },
];

export function Sidebar() {
  const pathname = usePathname();

  return (
    <div className="flex w-64 flex-col border-r bg-white">
      <div className="flex h-16 items-center border-b px-6">
        <h1 className="text-xl font-bold">Nacho Gym</h1>
      </div>
      <nav className="flex-1 space-y-1 p-4">
        {navigation.map((item) => {
          const isActive = pathname === item.href;
          return (
            <Link
              key={item.name}
              href={item.href}
              className={cn(
                "flex items-center gap-3 rounded-lg px-3 py-2 text-sm font-medium transition-colors",
                isActive
                  ? "bg-gray-100 text-gray-900"
                  : "text-gray-600 hover:bg-gray-50 hover:text-gray-900",
              )}
            >
              <item.icon className="h-5 w-5" />
              {item.name}
            </Link>
          );
        })}
      </nav>
    </div>
  );
}



=== components/layout/header.tsx ===

"use client";

import { authClient } from "@/lib/auth-client";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { LogOut } from "lucide-react";

interface HeaderProps {
  user: {
    name: string;
    email: string;
    role?: string;
  };
}

export function Header({ user }: HeaderProps) {
  const router = useRouter();

  const handleLogout = async () => {
    await authClient.signOut();
    router.push("/login");
  };

  return (
    <header className="flex h-16 items-center justify-between border-b bg-white px-6">
      <div className="flex items-center gap-4">
        <h2 className="text-lg font-semibold">Bienvenido, {user.name}</h2>
        {user.role && (
          <span className="rounded-full bg-blue-100 px-3 py-1 text-xs font-medium text-blue-700">
            {user.role}
          </span>
        )}
      </div>
      <Button
        variant="ghost"
        size="sm"
        onClick={handleLogout}
        className="gap-2"
      >
        <LogOut className="h-4 w-4" />
        Cerrar Sesi√≥n
      </Button>
    </header>
  );
}



=== components/ui/button.tsx ===

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant = "default",
  size = "default",
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      data-variant={variant}
      data-size={size}
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



=== components/ui/card.tsx ===

import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}



=== components/ui/input.tsx ===

import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }



=== components/ui/label.tsx ===

"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }



=== components/ui/select.tsx ===

"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "item-aligned",
  align = "center",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        align={align}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span
        data-slot="select-item-indicator"
        className="absolute right-2 flex size-3.5 items-center justify-center"
      >
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}



=== components/ui/badge.tsx ===

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-full border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }




### API ROUTES ###


=== app/api/auth/[...all]/route.ts ===

import { auth } from "@/lib/auth"; // path to your auth file
import { toNextJsHandler } from "better-auth/next-js";

export const { POST, GET } = toNextJsHandler(auth);



=== app/api/shifts/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { ShiftsService } from "@/services";

// GET /api/shifts - Lista todos los shifts
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const limit = searchParams.get("limit");

    const shifts = await ShiftsService.getAllShifts(
      limit ? parseInt(limit) : undefined
    );
    return NextResponse.json(shifts);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// POST /api/shifts - Abrir shift
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const shift = await ShiftsService.openShift(body);
    return NextResponse.json(shift, { status: 201 });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}



=== app/api/shifts/active/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { ShiftsService } from "@/services";

// GET /api/shifts/active
export async function GET() {
  try {
    const shift = await ShiftsService.getActiveShift();

    if (!shift) {
      return NextResponse.json(
        { message: "No hay corte activo" },
        { status: 404 }
      );
    }

    return NextResponse.json(shift);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}



=== app/api/shifts/close/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { ShiftsService } from "@/services";

// POST /api/shifts/close
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const shift = await ShiftsService.closeShift(body);
    return NextResponse.json(shift);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}



=== app/api/shifts/[id]/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { ShiftsService } from "@/services";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const shift = await ShiftsService.getShiftById(parseInt(id));
    return NextResponse.json(shift);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 404 });
  }
}



=== app/api/shifts/[id]/summary/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { ShiftsService } from "@/services";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const summary = await ShiftsService.getSalesSummaryByShift(parseInt(id));
    return NextResponse.json({ productos: summary });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}



=== app/api/inventory/sale/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { InventoryService } from "@/services";
import { headers } from "next/headers";
import { auth } from "@/lib/auth";

// POST /api/inventory/sale
export async function POST(request: NextRequest) {
  try {
    const session = await auth.api.getSession({ headers: await headers() });
    if (!session) {
      return NextResponse.json({ error: "No autorizado" }, { status: 401 });
    }

    const body = await request.json();

    const sale = await InventoryService.createSale({
      ...body,
      userId: session.user.id,
    });

    return NextResponse.json(sale, { status: 201 });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}



=== app/api/inventory/cancel/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { InventoryService } from "@/services";
import { headers } from "next/headers";
import { auth } from "@/lib/auth";

// POST /api/inventory/cancel
export async function POST(request: NextRequest) {
  try {
    const session = await auth.api.getSession({ headers: await headers() });
    if (!session) {
      return NextResponse.json({ error: "No autorizado" }, { status: 401 });
    }

    const body = await request.json();

    const cancelledSale = await InventoryService.cancelSale({
      ...body,
      userId: session.user.id,
    });

    return NextResponse.json(cancelledSale);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}



=== app/api/inventory/cancelled/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { InventoryService } from "@/services";

// GET /api/inventory/cancelled
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");

    let cancelledSales;

    if (startDate && endDate) {
      cancelledSales = await InventoryService.getCancelledSales(
        new Date(startDate),
        new Date(endDate)
      );
    } else {
      cancelledSales = await InventoryService.getCancelledSales();
    }

    return NextResponse.json(cancelledSales);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}



=== app/api/inventory/entry/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { InventoryService } from "@/services";
import { headers } from "next/headers";
import { auth } from "@/lib/auth";

export async function POST(request: NextRequest) {
  try {
    const session = await auth.api.getSession({ headers: await headers() });
    if (!session) {
      return NextResponse.json({ error: "No autorizado" }, { status: 401 });
    }

    const body = await request.json();
    const entry = await InventoryService.createEntry({
      ...body,
      userId: session.user.id,
    });
    return NextResponse.json(entry, { status: 201 });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}



=== app/api/inventory/adjustment/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { InventoryService } from "@/services";

// POST /api/inventory/adjustment
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const adjustment = await InventoryService.createAdjustment(body);
    return NextResponse.json(adjustment, { status: 201 });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}



=== app/api/inventory/transfer/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { InventoryService } from "@/services";

// POST /api/inventory/transfer
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const transfer = await InventoryService.createTransfer(body);
    return NextResponse.json(transfer, { status: 201 });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}



=== app/api/inventory/movements/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { InventoryService } from "@/services";

// GET /api/inventory/movements?startDate=...&endDate=...
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");

    if (!startDate || !endDate) {
      return NextResponse.json(
        { error: "Se requieren startDate y endDate" },
        { status: 400 }
      );
    }

    const movements = await InventoryService.getMovementsByDate(
      new Date(startDate),
      new Date(endDate)
    );

    return NextResponse.json(movements);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}



=== app/api/inventory/kardex/[id]/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { serializeDecimal } from "@/services/utils";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const productId = parseInt(id);

    const movements = await prisma.inventoryMovement.findMany({
      where: { productId },
      include: {
        user: {
          select: {
            name: true,
          },
        },
        member: {
          select: {
            memberNumber: true,
            name: true,
          },
        },
      },
      orderBy: { date: "desc" },
      take: 100,
    });

    return NextResponse.json(serializeDecimal(movements));
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}



=== app/api/inventory/report/stock/route.ts ===

import { NextResponse } from "next/server";
import { ReportsService } from "@/services";

// GET /api/inventory/report/stock
export async function GET() {
  try {
    const report = await ReportsService.getCurrentStockReport();
    return NextResponse.json(report);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}



=== app/api/inventory/ticket/[ticket]/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { InventoryService } from "@/services";

// GET /api/inventory/ticket/[ticket]
export async function GET(
  request: NextRequest,
  { params }: { params: { ticket: string } }
) {
  try {
    const ticket = params.ticket;
    const sales = await InventoryService.getSalesByTicket(ticket);
    return NextResponse.json(sales);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}



=== app/api/products/route.ts ===

/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextRequest, NextResponse } from "next/server";
import { ProductsService } from "@/services";

// GET /api/products - Lista todos los productos
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const search = searchParams.get("search") || undefined;
    const isActive = searchParams.get("isActive");
    const lowStock = searchParams.get("lowStock") === "true";

    const params = {
      search,
      isActive: isActive ? isActive === "true" : undefined,
      lowStock,
    };

    const products = await ProductsService.getAllProducts(params);
    return NextResponse.json(products);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// POST /api/products - Crear producto
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const product = await ProductsService.createProduct(body);
    return NextResponse.json(product, { status: 201 });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}



=== app/api/products/[id]/route.ts ===

/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextRequest, NextResponse } from "next/server";
import { ProductsService } from "@/services";

// GET /api/products/[id]
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const productId = parseInt(id);

    const product = await ProductsService.getProductById(productId);
    return NextResponse.json(product);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 404 });
  }
}

// PATCH /api/products/[id]
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const productId = parseInt(id);

    const body = await request.json();
    const product = await ProductsService.updateProduct(productId, body);

    return NextResponse.json(product);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}

// DELETE /api/products/[id]
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const productId = parseInt(id);

    const product = await ProductsService.toggleProductStatus(productId);
    return NextResponse.json(product);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}



=== app/api/members/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { MembersService } from "@/services";
import { headers } from "next/headers";
import { auth } from "@/lib/auth";

// GET /api/members
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const search = searchParams.get("search") || undefined;
    const isActive = searchParams.get("isActive");
    const membershipType = searchParams.get("membershipType") || undefined;

    const params = {
      search,
      isActive: isActive ? isActive === "true" : undefined,
      membershipType: membershipType as any,
    };

    const members = await MembersService.getAllMembers(params);
    return NextResponse.json(members);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// POST /api/members
export async function POST(request: NextRequest) {
  try {
    const session = await auth.api.getSession({ headers: await headers() });
    if (!session) {
      return NextResponse.json({ error: "No autorizado" }, { status: 401 });
    }

    const body = await request.json();

    const member = await MembersService.createMember({
      ...body,
      userId: session.user.id,
    });

    return NextResponse.json(member, { status: 201 });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}



=== app/api/members/[id]/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { MembersService } from "@/services";

// GET /api/members/[id]
export async function GET(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await context.params;
    const memberId = Number(id);

    if (isNaN(memberId)) {
      return NextResponse.json(
        { error: "ID de socio inv√°lido" },
        { status: 400 }
      );
    }

    const member = await MembersService.getMemberById(memberId);
    return NextResponse.json(member);
  } catch (error: any) {
    return NextResponse.json(
      { error: error.message ?? "Socio no encontrado" },
      { status: 404 }
    );
  }
}

// PATCH /api/members/[id]
export async function PATCH(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await context.params;
    const memberId = Number(id);

    if (isNaN(memberId)) {
      return NextResponse.json(
        { error: "ID de socio inv√°lido" },
        { status: 400 }
      );
    }

    const body = await request.json();
    const member = await MembersService.updateMember(memberId, body);

    return NextResponse.json(member);
  } catch (error: any) {
    return NextResponse.json(
      { error: error.message ?? "Error al actualizar socio" },
      { status: 400 }
    );
  }
}

// DELETE /api/members/[id]
export async function DELETE(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await context.params;
    const memberId = Number(id);

    if (isNaN(memberId)) {
      return NextResponse.json(
        { error: "ID de socio inv√°lido" },
        { status: 400 }
      );
    }

    const member = await MembersService.toggleMemberStatus(memberId);
    return NextResponse.json(member);
  } catch (error: any) {
    return NextResponse.json(
      { error: error.message ?? "Error al cambiar estado del socio" },
      { status: 400 }
    );
  }
}



=== app/api/members/[id]/validity/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { MembersService } from "@/services";

// GET /api/members/[id]/validity
export async function GET(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await context.params;
    const memberId = Number(id);

    if (isNaN(memberId)) {
      return NextResponse.json(
        { error: "ID de socio inv√°lido" },
        { status: 400 }
      );
    }

    const validity = await MembersService.verifyMembershipValidity(memberId);
    return NextResponse.json(validity);
  } catch (error: any) {
    return NextResponse.json(
      { error: error.message ?? "Error al verificar vigencia" },
      { status: 400 }
    );
  }
}



=== app/api/members/renew/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { MembersService } from "@/services";
import { headers } from "next/headers";
import { auth } from "@/lib/auth";

export async function POST(request: NextRequest) {
  try {
    const session = await auth.api.getSession({ headers: await headers() });
    if (!session) {
      return NextResponse.json({ error: "No autorizado" }, { status: 401 });
    }

    const body = await request.json();

    const member = await MembersService.renewMembership({
      ...body,
      userId: session.user.id,
    });

    return NextResponse.json(member);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}



=== app/api/members/expired/route.ts ===

import { NextResponse } from "next/server";
import { MembersService } from "@/services";

// GET /api/members/expired
export async function GET() {
  try {
    const members = await MembersService.getExpiredMembers();
    return NextResponse.json(members);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}



=== app/api/sales/history/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { serializeDecimal } from "@/services/utils";

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;

    // Construir filtros
    const where: any = {
      type: "SALE",
    };

    // Filtro de fechas
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");
    if (startDate && endDate) {
      where.date = {
        gte: new Date(startDate),
        lte: new Date(endDate + "T23:59:59"),
      };
    }

    // Filtro de cajero
    const cashier = searchParams.get("cashier");
    if (cashier && cashier !== "todos") {
      where.userId = cashier;
    }

    // Filtro de producto
    const product = searchParams.get("product");
    if (product && product !== "todos") {
      where.productId = parseInt(product);
    }

    // Filtro de socio
    const member = searchParams.get("member");
    if (member && member !== "todos") {
      where.memberId = parseInt(member);
    }

    // Filtro de forma de pago
    const paymentMethod = searchParams.get("paymentMethod");
    if (paymentMethod && paymentMethod !== "todos") {
      where.paymentMethod = paymentMethod;
    }

    // Filtro de tipo de producto (membres√≠as vs productos)
    const productType = searchParams.get("productType");
    if (productType && productType !== "todos") {
      // Obtener IDs de productos seg√∫n tipo
      const keywordsMemberships = [
        "EFECTIVO",
        "VISITA",
        "MENSUALIDAD",
        "SEMANA",
        "TRIMESTRE",
        "ANUAL",
        "PROMOCION",
        "RENACER",
      ];

      const products = await prisma.product.findMany({
        select: { id: true, name: true },
      });

      if (productType === "membresias") {
        const membershipIds = products
          .filter((p) =>
            keywordsMemberships.some((k) => p.name.toUpperCase().includes(k)),
          )
          .map((p) => p.id);
        where.productId = { in: membershipIds };
      } else if (productType === "productos") {
        const productIds = products
          .filter(
            (p) =>
              !keywordsMemberships.some((k) =>
                p.name.toUpperCase().includes(k),
              ),
          )
          .map((p) => p.id);
        where.productId = { in: productIds };
      }
    }

    // Filtro de solo activas
    const onlyActive = searchParams.get("onlyActive") === "true";
    if (onlyActive) {
      where.isCancelled = false;
    }

    // Ordenamiento
    const orderBy = searchParams.get("orderBy") || "date";
    const order = searchParams.get("order") || "desc";

    const orderByClause: any = {};
    switch (orderBy) {
      case "total":
        orderByClause.total = order;
        break;
      case "ticket":
        orderByClause.ticket = order;
        break;
      default:
        orderByClause.date = order;
    }

    // Paginaci√≥n
    const page = parseInt(searchParams.get("page") || "1");
    const perPage = parseInt(searchParams.get("perPage") || "10");
    const skip = (page - 1) * perPage;

    // Contar total antes de aplicar skip/take
    const total = await prisma.inventoryMovement.count({ where });

    const sales = await prisma.inventoryMovement.findMany({
      where,
      include: {
        product: {
          select: {
            name: true,
          },
        },
        member: {
          select: {
            memberNumber: true,
            name: true,
          },
        },
        user: {
          select: {
            name: true,
          },
        },
      },
      orderBy: orderByClause,
      skip,
      take: perPage,
    });

    return NextResponse.json({
      sales: serializeDecimal(sales),
      total,
      page,
      perPage,
      totalPages: Math.ceil(total / perPage),
    });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}



=== app/api/sales/products/route.ts ===

import { NextResponse } from "next/server";
import { headers } from "next/headers";
import { auth } from "@/lib/auth";
import { prisma } from "@/lib/db";

export async function GET() {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session?.user) {
    return NextResponse.json({ error: "No autorizado" }, { status: 401 });
  }

  const products = await prisma.product.findMany({
    where: {
      isActive: true,
      // Solo productos f√≠sicos con stock
      // Excluir membres√≠as basados en keywords
      NOT: {
        OR: [
          { name: { contains: "EFECTIVO", mode: "insensitive" } },
          { name: { contains: "VISITA", mode: "insensitive" } },
          { name: { contains: "MENSUALIDAD", mode: "insensitive" } },
          { name: { contains: "SEMANA", mode: "insensitive" } },
          { name: { contains: "TRIMESTRE", mode: "insensitive" } },
          { name: { contains: "ANUAL", mode: "insensitive" } },
        ],
      },
    },
    select: {
      id: true,
      name: true,
      salePrice: true,
      gymStock: true,
      warehouseStock: true,
    },
    orderBy: { name: "asc" },
  });

  // Agregar campo calculado de stock total
  const productsWithStock = products.map(p => ({
    ...p,
    totalStock: p.gymStock + p.warehouseStock,
  }));

  return NextResponse.json(productsWithStock);
}



=== app/api/sales/ticket/[ticket]/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { serializeDecimal } from "@/services/utils";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ ticket: string }> },
) {
  try {
    const { ticket } = await params;

    const sales = await prisma.inventoryMovement.findMany({
      where: {
        ticket,
        type: "SALE",
      },
      include: {
        product: {
          select: {
            name: true,
          },
        },
        member: {
          select: {
            memberNumber: true,
            name: true,
          },
        },
        user: {
          select: {
            name: true,
          },
        },
      },
      orderBy: { date: "asc" },
    });

    if (sales.length === 0) {
      return NextResponse.json(
        { error: "Ticket no encontrado" },
        { status: 404 },
      );
    }

    return NextResponse.json(serializeDecimal(sales));
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}




### SERVICES ###


=== services/index.ts ===

// Exportar todos los servicios
export * as UsersService from "./users.service";
export * as MembersService from "./members.service";
export * as ProductsService from "./products.service";
export * as InventoryService from "./inventory.service";
export * as ShiftsService from "./shifts.service";
export * as ReportsService from "./reports.service";



=== services/shifts.service.ts ===

// services/shifts.service.ts
import { prisma } from "@/lib/db";
import { PaymentMethod } from "@prisma/client";
import { Decimal } from "@prisma/client/runtime/library";
import { serializeDecimal } from "./utils";

// ==================== TYPES ====================

export interface OpenShiftInput {
  cashierId: string;
  initialCash: number;
  notes?: string;
}

export interface CloseShiftInput {
  shiftId: number;
  totalWithdrawals?: number;
  withdrawalsConcept?: string;
  totalCash: number;
  notes?: string;
}

// ==================== HELPERS ====================

/**
 * Convierte un n√∫mero o Decimal a tipo Decimal de Prisma
 */
function toDecimal(value: number | Decimal): Decimal {
  return new Decimal(value.toString());
}

/**
 * Suma m√∫ltiples valores Decimal
 */
function addDecimals(...values: (number | Decimal)[]): Decimal {
  return values.reduce((sum, val) => sum.plus(toDecimal(val)), new Decimal(0));
}

/**
 * Resta dos valores Decimal
 */
function subtractDecimals(a: number | Decimal, b: number | Decimal): Decimal {
  return toDecimal(a).minus(toDecimal(b));
}

// ==================== VALIDATIONS ====================

/**
 * Verifica que el cajero no tenga un corte abierto
 */
async function validateNoOpenShift(cashierId: string) {
  const openShift = await prisma.shift.findFirst({
    where: {
      cashierId,
      closingDate: null,
    },
  });

  if (openShift) {
    throw new Error("Ya tienes un corte abierto");
  }
}

/**
 * Verifica que no exista ning√∫n corte abierto en el sistema
 */
async function validateNoSystemOpenShift() {
  const openShift = await prisma.shift.findFirst({
    where: {
      closingDate: null,
    },
  });

  if (openShift) {
    throw new Error("Ya existe un corte abierto en el sistema");
  }
}

// ==================== PUBLIC SERVICES ====================

/**
 * Abre un nuevo corte de caja
 * Genera folio autom√°tico secuencial (FN-1, FN-2, etc.)
 */
export async function openShift(data: OpenShiftInput) {
  await validateNoOpenShift(data.cashierId);
  await validateNoSystemOpenShift();

  // Generar folio secuencial
  const lastShift = await prisma.shift.findFirst({
    orderBy: { createdAt: "desc" },
  });

  let newFolio = "FN-1";
  if (lastShift) {
    const currentNumber = parseInt(lastShift.folio.split("-")[1]) || 0;
    newFolio = `FN-${currentNumber + 1}`;
  }

  const shift = await prisma.shift.create({
    data: {
      folio: newFolio,
      cashierId: data.cashierId,
      openingDate: new Date(),
      initialCash: data.initialCash,
      notes: data.notes,
    },
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  return serializeDecimal(shift);
}

/**
 * Cierra un corte de caja
 * Calcula totales por forma de pago, tickets, diferencias, etc.
 */
export async function closeShift(data: CloseShiftInput) {
  const shift = await prisma.shift.findUnique({
    where: { id: data.shiftId },
    include: {
      inventoryMovements: {
        where: {
          type: "SALE",
          isCancelled: false,
        },
      },
    },
  });

  if (!shift) {
    throw new Error("Corte no encontrado");
  }

  if (shift.closingDate) {
    throw new Error("El corte ya est√° cerrado");
  }

  // Contar tickets √∫nicos
  const tickets = new Set(shift.inventoryMovements.map((i) => i.ticket)).size;

  // Inicializar totales
  let membershipSales = new Decimal(0);
  let productSales0Tax = new Decimal(0);
  let productSales16Tax = new Decimal(0);
  let cashAmount = new Decimal(0);
  let debitCardAmount = new Decimal(0);
  let creditCardAmount = new Decimal(0);

  // Obtener productos de membres√≠a
  const membershipProducts = await prisma.product.findMany({
    where: {
      OR: [
        { name: { contains: "EFECTIVO", mode: "insensitive" } },
        { name: { contains: "VISITA", mode: "insensitive" } },
      ],
    },
  });
  const membershipIds = membershipProducts.map((p) => p.id);

  // Calcular totales por tipo de producto y forma de pago
  for (const sale of shift.inventoryMovements) {
    const total = toDecimal(sale.total || 0);

    if (membershipIds.includes(sale.productId)) {
      membershipSales = membershipSales.plus(total);
    } else {
      productSales0Tax = productSales0Tax.plus(total);
    }

    switch (sale.paymentMethod) {
      case "CASH":
        cashAmount = cashAmount.plus(total);
        break;
      case "DEBIT_CARD":
        debitCardAmount = debitCardAmount.plus(total);
        break;
      case "CREDIT_CARD":
        creditCardAmount = creditCardAmount.plus(total);
        break;
    }
  }

  // Calcular subtotal, IVA, total
  const subtotal = addDecimals(
    membershipSales,
    productSales0Tax,
    productSales16Tax,
  );
  const tax = productSales16Tax.times(0.16);
  const totalSales = addDecimals(subtotal, tax);
  const totalVoucher = addDecimals(debitCardAmount, creditCardAmount);
  const totalWithdrawals = toDecimal(data.totalWithdrawals || 0);
  const totalCash = toDecimal(data.totalCash);
  const expectedCash = addDecimals(shift.initialCash, cashAmount).minus(
    totalWithdrawals,
  );
  const difference = subtractDecimals(totalCash, expectedCash);

  const updatedShift = await prisma.shift.update({
    where: { id: data.shiftId },
    data: {
      closingDate: new Date(),
      ticketCount: tickets,
      membershipSales,
      productSales0Tax,
      productSales16Tax,
      subtotal,
      tax,
      totalSales,
      cashAmount,
      debitCardAmount,
      creditCardAmount,
      totalVoucher,
      totalWithdrawals,
      withdrawalsConcept: data.withdrawalsConcept,
      totalCash,
      difference,
      notes: data.notes || shift.notes,
    },
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  return serializeDecimal(updatedShift);
}

/**
 * Obtiene el corte activo (sin cerrar)
 * Recalcula totales en tiempo real
 */
export async function getActiveShift() {
  const shift = await prisma.shift.findFirst({
    where: { closingDate: null },
    include: {
      cashier: {
        select: { id: true, name: true, email: true },
      },
      inventoryMovements: {
        where: { type: "SALE", isCancelled: false },
        include: {
          product: { select: { name: true } },
          member: { select: { memberNumber: true, name: true } },
        },
        orderBy: { date: "desc" },
      },
    },
  });

  if (!shift) return null;

  // Recalcular totales en tiempo real
  const tickets = new Set(shift.inventoryMovements.map((i) => i.ticket)).size;
  let cashAmount = 0;
  let debitCardAmount = 0;
  let creditCardAmount = 0;
  let totalSales = 0;

  shift.inventoryMovements.forEach((sale) => {
    const total = Number(sale.total || 0);
    totalSales += total;

    switch (sale.paymentMethod) {
      case "CASH":
        cashAmount += total;
        break;
      case "DEBIT_CARD":
        debitCardAmount += total;
        break;
      case "CREDIT_CARD":
        creditCardAmount += total;
        break;
    }
  });

  return serializeDecimal({
    ...shift,
    ticketCount: tickets,
    cashAmount,
    debitCardAmount,
    creditCardAmount,
    totalSales,
  });
}

/**
 * Obtiene un corte por ID con todas sus relaciones
 */
export async function getShiftById(id: number) {
  const shift = await prisma.shift.findUnique({
    where: { id },
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
      inventoryMovements: {
        where: {
          type: "SALE",
        },
        include: {
          product: {
            select: {
              name: true,
            },
          },
          member: {
            select: {
              memberNumber: true,
              name: true,
            },
          },
        },
        orderBy: { date: "asc" },
      },
    },
  });

  if (!shift) {
    throw new Error("Corte no encontrado");
  }

  return serializeDecimal(shift);
}

/**
 * Lista todos los cortes con opci√≥n de l√≠mite
 */
export async function getAllShifts(limit?: number) {
  const shifts = await prisma.shift.findMany({
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
    orderBy: { openingDate: "desc" },
    take: limit,
  });

  return serializeDecimal(shifts);
}

/**
 * Obtiene cortes dentro de un rango de fechas
 */
export async function getShiftsBetweenDates(startDate: Date, endDate: Date) {
  const shifts = await prisma.shift.findMany({
    where: {
      openingDate: {
        gte: startDate,
        lte: endDate,
      },
    },
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
    orderBy: { openingDate: "desc" },
  });

  return serializeDecimal(shifts);
}

/**
 * Obtiene cortes de un cajero espec√≠fico
 */
export async function getShiftsByCashier(cashierId: string, limit?: number) {
  const shifts = await prisma.shift.findMany({
    where: { cashierId },
    include: {
      cashier: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
    orderBy: { openingDate: "desc" },
    take: limit,
  });

  return serializeDecimal(shifts);
}

/**
 * Genera resumen de ventas por producto para un corte
 */
export async function getSalesSummaryByShift(shiftId: number) {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      shiftId,
      type: "SALE",
      isCancelled: false,
    },
    include: {
      product: {
        select: {
          name: true,
        },
      },
    },
  });

  const summaryByProduct = sales.reduce(
    (acc, sale) => {
      const name = sale.product.name;
      if (!acc[name]) {
        acc[name] = {
          product: name,
          quantity: 0,
          total: new Decimal(0),
        };
      }
      acc[name].quantity += Math.abs(sale.quantity);
      acc[name].total = acc[name].total.plus(toDecimal(sale.total || 0));
      return acc;
    },
    {} as Record<string, { product: string; quantity: number; total: Decimal }>,
  );

  return serializeDecimal(Object.values(summaryByProduct));
}

/**
 * Genera resumen por forma de pago para un corte
 */
export async function getPaymentMethodSummary(shiftId: number) {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      shiftId,
      type: "SALE",
      isCancelled: false,
    },
  });

  const summary = sales.reduce(
    (acc, sale) => {
      const total = toDecimal(sale.total || 0);
      const method = sale.paymentMethod || "CASH";
      acc[method] = acc[method].plus(total);
      return acc;
    },
    {
      CASH: new Decimal(0),
      DEBIT_CARD: new Decimal(0),
      CREDIT_CARD: new Decimal(0),
      TRANSFER: new Decimal(0),
    },
  );

  return serializeDecimal(summary);
}

/**
 * Genera estad√≠sticas generales de cortes en un per√≠odo
 */
export async function getShiftsStatistics(startDate?: Date, endDate?: Date) {
  const where: any = {};

  if (startDate && endDate) {
    where.openingDate = {
      gte: startDate,
      lte: endDate,
    };
  }

  const shifts = await prisma.shift.findMany({
    where,
  });

  const totalShifts = shifts.length;
  const totalSales = shifts.reduce(
    (sum, s) => sum.plus(toDecimal(s.totalSales)),
    new Decimal(0),
  );
  const averageSales =
    totalShifts > 0 ? totalSales.dividedBy(totalShifts) : new Decimal(0);
  const totalDifferences = shifts.reduce(
    (sum, s) => sum.plus(toDecimal(Math.abs(Number(s.difference)))),
    new Decimal(0),
  );

  return serializeDecimal({
    totalShifts,
    totalSales,
    averageSales,
    totalDifferences,
  });
}

/**
 * Cancela un corte (solo ADMIN)
 * Elimina el corte del sistema
 */
export async function cancelShift(shiftId: number, userRole: string) {
  if (userRole !== "ADMIN") {
    throw new Error("Solo un administrador puede cancelar un corte");
  }

  const shift = await prisma.shift.findUnique({
    where: { id: shiftId },
  });

  if (!shift) {
    throw new Error("Corte no encontrado");
  }

  if (!shift.closingDate) {
    throw new Error("No se puede cancelar un corte abierto");
  }

  await prisma.shift.delete({
    where: { id: shiftId },
  });

  return { success: true, message: "Corte cancelado exitosamente" };
}



=== services/members.service.ts ===

// services/members.service.ts
import { prisma } from "@/lib/db";
import { MembershipType } from "@prisma/client";
import { serializeDecimal } from "./utils";

// ==================== TYPES ====================

export interface CreateMemberInput {
  memberNumber: string;
  name?: string;
  phone?: string;
  email?: string;
  birthDate?: Date;
  membershipType?: MembershipType;
  membershipDescription?: string;
  startDate?: Date;
  endDate?: Date;
}

export interface CreateMemberWithSaleInput extends CreateMemberInput {
  userId?: string;
  paymentMethod?: "CASH" | "DEBIT_CARD" | "CREDIT_CARD" | "TRANSFER";
}

export interface UpdateMemberInput {
  name?: string;
  phone?: string;
  email?: string;
  birthDate?: Date;
  membershipType?: MembershipType;
  membershipDescription?: string;
  startDate?: Date;
  endDate?: Date;
  isActive?: boolean;
}

export interface RenewMembershipInput {
  memberId: number;
  membershipType: MembershipType;
  membershipDescription?: string;
  startDate?: Date;
}

export interface RenewMembershipWithSaleInput extends RenewMembershipInput {
  userId: string;
  paymentMethod?: "CASH" | "DEBIT_CARD" | "CREDIT_CARD" | "TRANSFER";
}

export interface SearchMembersParams {
  search?: string;
  isActive?: boolean;
  membershipType?: MembershipType;
}

// ==================== HELPERS ====================

/**
 * Calcula la fecha de fin seg√∫n el tipo de membres√≠a
 */
function calculateEndDate(
  startDate: Date,
  membershipType: MembershipType,
): Date {
  const date = new Date(startDate);

  switch (membershipType) {
    case "VISIT":
      return date;
    case "WEEK":
      date.setDate(date.getDate() + 7);
      break;
    case "MONTH_STUDENT":
    case "MONTH_GENERAL":
      date.setMonth(date.getMonth() + 1);
      break;
    case "QUARTER_STUDENT":
    case "QUARTER_GENERAL":
      date.setMonth(date.getMonth() + 3);
      break;
    case "ANNUAL_STUDENT":
    case "ANNUAL_GENERAL":
      date.setFullYear(date.getFullYear() + 1);
      break;
    case "PROMOTION":
    case "REBIRTH":
    case "NUTRITION_CONSULTATION":
      date.setMonth(date.getMonth() + 1);
      break;
  }

  return date;
}

/**
 * Calcula fechas de inicio y fin para una membres√≠a
 */
export function calculateMembershipDates(
  membershipType: MembershipType,
  startDate?: Date,
): { startDate: Date; endDate: Date } {
  const start = startDate || new Date();
  const end = calculateEndDate(start, membershipType);

  return {
    startDate: start,
    endDate: end,
  };
}

// ==================== PUBLIC SERVICES ====================

/**
 * Lista todos los socios con filtros opcionales
 */
export async function getAllMembers(params?: SearchMembersParams) {
  const where: any = {};

  if (params?.search) {
    where.OR = [
      { memberNumber: { contains: params.search, mode: "insensitive" } },
      { name: { contains: params.search, mode: "insensitive" } },
      { phone: { contains: params.search, mode: "insensitive" } },
      { email: { contains: params.search, mode: "insensitive" } },
    ];
  }

  if (params?.isActive !== undefined) {
    where.isActive = params.isActive;
  }

  if (params?.membershipType) {
    where.membershipType = params.membershipType;
  }

  const members = await prisma.member.findMany({
    where,
    orderBy: { createdAt: "desc" },
  });

  return serializeDecimal(members);
}

/**
 * Obtiene un socio por ID con su historial de compras
 */
export async function getMemberById(id: number) {
  const member = await prisma.member.findUnique({
    where: { id },
    include: {
      inventoryMovements: {
        where: { type: "SALE", isCancelled: false },
        orderBy: { date: "desc" },
        take: 20,
        include: {
          product: {
            select: {
              name: true,
              salePrice: true,
            },
          },
        },
      },
    },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  return serializeDecimal(member);
}

/**
 * Obtiene un socio por n√∫mero de socio
 */
export async function getMemberByNumber(memberNumber: string) {
  const member = await prisma.member.findUnique({
    where: { memberNumber },
    include: {
      inventoryMovements: {
        where: { type: "SALE", isCancelled: false },
        orderBy: { date: "desc" },
        take: 5,
        include: {
          product: {
            select: {
              name: true,
              salePrice: true,
            },
          },
        },
      },
    },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  return serializeDecimal(member);
}

/**
 * Crea un nuevo socio
 * Si tiene membres√≠a y userId, crea la venta autom√°ticamente
 */
export async function createMember(data: CreateMemberWithSaleInput) {
  const existingMember = await prisma.member.findUnique({
    where: { memberNumber: data.memberNumber },
  });

  if (existingMember) {
    throw new Error("El n√∫mero de socio ya existe");
  }

  const member = await prisma.member.create({
    data: {
      memberNumber: data.memberNumber,
      name: data.name,
      phone: data.phone,
      email: data.email,
      birthDate: data.birthDate ? new Date(data.birthDate) : undefined,
      membershipType: data.membershipType,
      membershipDescription: data.membershipDescription,
      startDate: data.startDate ? new Date(data.startDate) : undefined,
      endDate: data.endDate ? new Date(data.endDate) : undefined,
    },
  });

  // Si tiene membres√≠a y userId, crear venta
  if (data.membershipType && data.userId) {
    const keywordMap: Record<string, string> = {
      MONTH_STUDENT: "MENSUALIDAD ESTUDIANTE",
      MONTH_GENERAL: "MENSUALIDAD GENERAL",
      WEEK: "SEMANA",
      VISIT: "VISITA",
      QUARTER_STUDENT: "TRIMESTRE ESTUDIANTE",
      QUARTER_GENERAL: "TRIMESTRE GENERAL",
      ANNUAL_STUDENT: "ANUAL ESTUDIANTE",
      ANNUAL_GENERAL: "ANUAL GENERAL",
      PROMOTION: "PROMOCION",
      REBIRTH: "RENACER",
    };

    const keyword = keywordMap[data.membershipType] || data.membershipType;

    const product = await prisma.product.findFirst({
      where: {
        name: { contains: keyword, mode: "insensitive" },
        isActive: true,
      },
    });

    if (product) {
      const activeShift = await prisma.shift.findFirst({
        where: { closingDate: null },
      });

      const timestamp = Date.now().toString().slice(-6);
      const random = Math.floor(Math.random() * 100)
        .toString()
        .padStart(2, "0");
      const ticket = `NEW${timestamp}${random}`;

      await prisma.inventoryMovement.create({
        data: {
          productId: product.id,
          type: "SALE",
          location: "GYM",
          quantity: -1,
          ticket,
          memberId: member.id,
          userId: data.userId,
          unitPrice: product.salePrice,
          subtotal: product.salePrice,
          discount: 0,
          surcharge: 0,
          total: product.salePrice,
          paymentMethod: data.paymentMethod || "CASH",
          shiftId: activeShift?.id,
          notes: `Alta de socio: ${data.membershipDescription || data.membershipType}`,
        },
      });
    }
  }

  return serializeDecimal(member);
}

/**
 * Actualiza un socio existente
 */
export async function updateMember(id: number, data: UpdateMemberInput) {
  const member = await prisma.member.findUnique({
    where: { id },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  const updatedMember = await prisma.member.update({
    where: { id },
    data: {
      ...data,
      birthDate: data.birthDate ? new Date(data.birthDate) : undefined,
      startDate: data.startDate ? new Date(data.startDate) : undefined,
      endDate: data.endDate ? new Date(data.endDate) : undefined,
    },
  });

  return serializeDecimal(updatedMember);
}

/**
 * Activa/desactiva un socio
 */
export async function toggleMemberStatus(id: number) {
  const member = await prisma.member.findUnique({
    where: { id },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  const updatedMember = await prisma.member.update({
    where: { id },
    data: { isActive: !member.isActive },
  });

  return serializeDecimal(updatedMember);
}

/**
 * Registra una visita de un socio
 */
export async function registerVisit(memberId: number) {
  const member = await prisma.member.findUnique({
    where: { id: memberId },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  if (!member.isActive) {
    throw new Error("El socio no est√° activo");
  }

  const updatedMember = await prisma.member.update({
    where: { id: memberId },
    data: {
      totalVisits: { increment: 1 },
      lastVisit: new Date(),
    },
  });

  return serializeDecimal(updatedMember);
}

/**
 * Lista solo socios activos
 */
export async function getActiveMembers() {
  const members = await prisma.member.findMany({
    where: { isActive: true },
    orderBy: { name: "asc" },
  });

  return serializeDecimal(members);
}

/**
 * Lista socios con membres√≠a pr√≥xima a vencer
 */
export async function getMembersExpiringSoon(days: number = 7) {
  const today = new Date();
  const limitDate = new Date();
  limitDate.setDate(limitDate.getDate() + days);

  const members = await prisma.member.findMany({
    where: {
      isActive: true,
      endDate: {
        gte: today,
        lte: limitDate,
      },
      membershipType: {
        not: "VISIT",
      },
    },
    orderBy: { endDate: "asc" },
  });

  return serializeDecimal(members);
}

/**
 * Genera estad√≠sticas de socios
 */
export async function getMembersStatistics() {
  const total = await prisma.member.count();
  const active = await prisma.member.count({ where: { isActive: true } });
  const inactive = await prisma.member.count({ where: { isActive: false } });

  const byType = await prisma.member.groupBy({
    by: ["membershipType"],
    where: { isActive: true },
    _count: true,
  });

  return {
    total,
    active,
    inactive,
    byType,
  };
}

/**
 * Renueva la membres√≠a de un socio
 * Crea la venta autom√°ticamente
 */
export async function renewMembership(data: RenewMembershipWithSaleInput) {
  const member = await prisma.member.findUnique({
    where: { id: data.memberId },
  });

  if (!member) {
    throw new Error("Socio no encontrado");
  }

  const dates = calculateMembershipDates(data.membershipType, data.startDate);

  // Buscar producto de membres√≠a
  const keywordMap: Record<string, string> = {
    MONTH_STUDENT: "MENSUALIDAD ESTUDIANTE",
    MONTH_GENERAL: "MENSUALIDAD GENERAL",
    WEEK: "SEMANA",
    VISIT: "VISITA",
    QUARTER_STUDENT: "TRIMESTRE ESTUDIANTE",
    QUARTER_GENERAL: "TRIMESTRE GENERAL",
    ANNUAL_STUDENT: "ANUAL ESTUDIANTE",
    ANNUAL_GENERAL: "ANUAL GENERAL",
    PROMOTION: "PROMOCION",
    REBIRTH: "RENACER",
  };

  const keyword = keywordMap[data.membershipType] || data.membershipType;

  const product = await prisma.product.findFirst({
    where: {
      name: { contains: keyword, mode: "insensitive" },
      isActive: true,
    },
  });

  if (!product) {
    throw new Error(
      `No se encontr√≥ producto para membres√≠a: ${data.membershipType}`,
    );
  }

  const activeShift = await prisma.shift.findFirst({
    where: { closingDate: null },
  });

  const timestamp = Date.now().toString().slice(-6);
  const random = Math.floor(Math.random() * 100)
    .toString()
    .padStart(2, "0");
  const ticket = `REN${timestamp}${random}`;

  const [updatedMember] = await prisma.$transaction([
    prisma.member.update({
      where: { id: data.memberId },
      data: {
        membershipType: data.membershipType,
        membershipDescription: data.membershipDescription,
        startDate: dates.startDate,
        endDate: dates.endDate,
        isActive: true,
        totalVisits: { increment: 1 },
        lastVisit: new Date(),
      },
    }),
    prisma.inventoryMovement.create({
      data: {
        productId: product.id,
        type: "SALE",
        location: "GYM",
        quantity: -1,
        ticket,
        memberId: data.memberId,
        userId: data.userId,
        unitPrice: product.salePrice,
        subtotal: product.salePrice,
        discount: 0,
        surcharge: 0,
        total: product.salePrice,
        paymentMethod: data.paymentMethod || "CASH",
        shiftId: activeShift?.id,
        notes: `Renovaci√≥n: ${data.membershipDescription || data.membershipType}`,
      },
    }),
  ]);

  return serializeDecimal(updatedMember);
}

/**
 * Lista socios con membres√≠a vencida
 */
export async function getExpiredMembers() {
  const today = new Date();

  const members = await prisma.member.findMany({
    where: {
      isActive: true,
      endDate: {
        lt: today,
      },
      membershipType: {
        not: "VISIT",
      },
    },
    orderBy: { endDate: "desc" },
  });

  return serializeDecimal(members);
}

/**
 * Verifica la vigencia de una membres√≠a
 */
export async function verifyMembershipValidity(memberId: number): Promise<{
  isValid: boolean;
  daysRemaining: number;
  endDate: Date | null;
}> {
  const member = await prisma.member.findUnique({
    where: { id: memberId },
  });

  if (!member || !member.endDate || member.membershipType === "VISIT") {
    return {
      isValid: false,
      daysRemaining: 0,
      endDate: null,
    };
  }

  const today = new Date();
  const endDate = new Date(member.endDate);
  const difference = endDate.getTime() - today.getTime();
  const daysRemaining = Math.ceil(difference / (1000 * 60 * 60 * 24));

  return {
    isValid: daysRemaining > 0,
    daysRemaining: Math.max(0, daysRemaining),
    endDate,
  };
}



=== services/products.service.ts ===

// services/products.service.ts
import { prisma } from "@/lib/db";
import { Location } from "@prisma/client";
import { serializeDecimal } from "./utils";

// ==================== TYPES ====================

export interface CreateProductInput {
  name: string;
  salePrice: number;
  minStock?: number;
}

export interface UpdateProductInput {
  name?: string;
  salePrice?: number;
  minStock?: number;
  isActive?: boolean;
}

export interface SearchProductsParams {
  search?: string;
  isActive?: boolean;
  lowStock?: boolean;
}

// ==================== PUBLIC SERVICES ====================

/**
 * Lista todos los productos con filtros opcionales
 * - B√∫squeda por nombre
 * - Filtro por activo/inactivo
 * - Filtro por stock bajo
 */
export async function getAllProducts(params?: SearchProductsParams) {
  const where: any = {};

  if (params?.search) {
    where.name = {
      contains: params.search,
      mode: "insensitive",
    };
  }

  if (params?.isActive !== undefined) {
    where.isActive = params.isActive;
  }

  const products = await prisma.product.findMany({
    where,
    orderBy: { name: "asc" },
  });

  let result = products;

  // Filtro de stock bajo se aplica despu√©s del query
  if (params?.lowStock) {
    result = products.filter(
      (p) => p.gymStock < p.minStock || p.warehouseStock < p.minStock,
    );
  }

  return serializeDecimal(result);
}

/**
 * Obtiene un producto por ID con sus √∫ltimos movimientos
 */
export async function getProductById(id: number) {
  const product = await prisma.product.findUnique({
    where: { id },
    include: {
      inventoryMovements: {
        orderBy: { date: "desc" },
        take: 20,
        include: {
          user: {
            select: {
              name: true,
            },
          },
          member: {
            select: {
              memberNumber: true,
              name: true,
            },
          },
        },
      },
    },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  return serializeDecimal(product);
}

/**
 * Crea un nuevo producto
 * Valida que el nombre sea √∫nico
 */
export async function createProduct(data: CreateProductInput) {
  const existingProduct = await prisma.product.findUnique({
    where: { name: data.name },
  });

  if (existingProduct) {
    throw new Error("Ya existe un producto con ese nombre");
  }

  const product = await prisma.product.create({
    data: {
      name: data.name,
      salePrice: data.salePrice,
      minStock: data.minStock || 0,
    },
  });

  return serializeDecimal(product);
}

/**
 * Actualiza un producto existente
 * Valida unicidad de nombre si se cambia
 */
export async function updateProduct(id: number, data: UpdateProductInput) {
  const product = await prisma.product.findUnique({
    where: { id },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  if (data.name && data.name !== product.name) {
    const existingProduct = await prisma.product.findUnique({
      where: { name: data.name },
    });

    if (existingProduct) {
      throw new Error("Ya existe un producto con ese nombre");
    }
  }

  const updatedProduct = await prisma.product.update({
    where: { id },
    data,
  });

  return serializeDecimal(updatedProduct);
}

/**
 * Activa/desactiva un producto
 */
export async function toggleProductStatus(id: number) {
  const product = await prisma.product.findUnique({
    where: { id },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  const updatedProduct = await prisma.product.update({
    where: { id },
    data: { isActive: !product.isActive },
  });

  return serializeDecimal(updatedProduct);
}

/**
 * Lista solo productos activos
 */
export async function getActiveProducts() {
  const products = await prisma.product.findMany({
    where: { isActive: true },
    orderBy: { name: "asc" },
  });

  return serializeDecimal(products);
}

/**
 * Lista productos con stock bajo en cualquier ubicaci√≥n
 */
export async function getLowStockProducts() {
  const products = await prisma.product.findMany({
    where: { isActive: true },
  });

  const result = products.filter(
    (p) => p.gymStock < p.minStock || p.warehouseStock < p.minStock,
  );

  return serializeDecimal(result);
}

/**
 * Obtiene el stock de un producto
 * - Si se especifica ubicaci√≥n, retorna solo ese stock
 * - Si no, retorna bodega, gym y total
 */
export async function getProductStock(productId: number, location?: Location) {
  const product = await prisma.product.findUnique({
    where: { id: productId },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  if (location === "WAREHOUSE") {
    return product.warehouseStock;
  } else if (location === "GYM") {
    return product.gymStock;
  }

  return serializeDecimal({
    warehouse: product.warehouseStock,
    gym: product.gymStock,
    total: product.warehouseStock + product.gymStock,
  });
}

/**
 * Lista productos de membres√≠a
 * Identifica por keywords en el nombre
 */
export async function getMembershipProducts() {
  const keywords = ["EFECTIVO", "VISITA", "MENSUALIDAD", "SEMANA"];

  const products = await prisma.product.findMany({
    where: {
      isActive: true,
      OR: keywords.map((keyword) => ({
        name: { contains: keyword, mode: "insensitive" },
      })),
    },
    orderBy: { name: "asc" },
  });

  return serializeDecimal(products);
}

/**
 * Lista productos de venta (f√≠sicos)
 * Excluye productos de membres√≠a
 */
export async function getSaleProducts() {
  const keywords = ["EFECTIVO", "VISITA", "MENSUALIDAD", "SEMANA"];

  const products = await prisma.product.findMany({
    where: {
      isActive: true,
      NOT: {
        OR: keywords.map((keyword) => ({
          name: { contains: keyword, mode: "insensitive" },
        })),
      },
    },
    orderBy: { name: "asc" },
  });

  return serializeDecimal(products);
}

/**
 * Genera estad√≠sticas generales de productos
 */
export async function getProductsStatistics() {
  const total = await prisma.product.count();
  const active = await prisma.product.count({ where: { isActive: true } });

  const products = await prisma.product.findMany({
    where: { isActive: true },
  });

  const lowStockGym = products.filter((p) => p.gymStock < p.minStock).length;
  const lowStockWarehouse = products.filter(
    (p) => p.warehouseStock < p.minStock,
  ).length;

  const inventoryValue = products.reduce((sum, p) => {
    const totalStock = p.warehouseStock + p.gymStock;
    return sum + Number(p.salePrice) * totalStock;
  }, 0);

  return {
    total,
    active,
    lowStockGym,
    lowStockWarehouse,
    inventoryValue,
  };
}



=== services/inventory.service.ts ===

// services/inventory.service.ts
import { prisma } from "@/lib/db";
import { InventoryType, Location, PaymentMethod } from "@prisma/client";
import { Decimal } from "@prisma/client/runtime/library";
import { calculateMembershipDates } from "./members.service";
import { serializeDecimal } from "./utils";

// ==================== TYPES ====================

export interface CreateSaleInput {
  productId: number;
  quantity: number;
  memberId?: number;
  userId: string;
  unitPrice?: number;
  discount?: number;
  surcharge?: number;
  paymentMethod: PaymentMethod;
  ticket: string;
  shiftId?: number;
  notes?: string;
}

export interface CreateEntryInput {
  productId: number;
  quantity: number;
  location: Location;
  userId: string;
  notes?: string;
}

export interface CreateTransferInput {
  productId: number;
  quantity: number;
  destination: Location;
  userId: string;
  notes?: string;
}

export interface CreateAdjustmentInput {
  productId: number;
  quantity: number;
  location: Location;
  userId: string;
  notes: string;
}

export interface CancelSaleInput {
  inventoryId: number;
  userId: string;
  cancellationReason: string;
}

// ==================== VALIDATIONS ====================

/**
 * Valida que existe stock suficiente para una operaci√≥n
 * Retorna el producto si pasa la validaci√≥n
 */
async function validateStock(
  productId: number,
  quantity: number,
  location: Location,
) {
  const product = await prisma.product.findUnique({
    where: { id: productId },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  // Verificar si es producto de membres√≠a (no requiere stock)
  const isMembership =
    product.name.includes("EFECTIVO") ||
    product.name.includes("VISITA") ||
    product.name.includes("MENSUALIDAD") ||
    product.name.includes("SEMANA") ||
    product.name.includes("TRIMESTRE") ||
    product.name.includes("ANUAL");

  if (!isMembership) {
    const currentStock =
      location === "WAREHOUSE" ? product.warehouseStock : product.gymStock;

    if (currentStock < quantity) {
      throw new Error(
        `Stock insuficiente en ${location}. Disponible: ${currentStock}, Solicitado: ${quantity}`,
      );
    }
  }

  return product;
}

// ==================== SALE SERVICES ====================

/**
 * Crea una venta de producto
 * - Descuenta del stock de GYM
 * - Actualiza visitas del socio si aplica
 * - Renueva membres√≠a si es producto de membres√≠a
 */
export async function createSale(data: CreateSaleInput) {
  const product = await validateStock(data.productId, data.quantity, "GYM");

  const unitPrice = data.unitPrice || product.salePrice;
  const subtotal = Number(unitPrice) * data.quantity;
  const discount = data.discount || 0;
  const surcharge = data.surcharge || 0;
  const total = subtotal - Number(discount) + Number(surcharge);

  const isMembership =
    product.name.includes("EFECTIVO") ||
    product.name.includes("VISITA") ||
    product.name.includes("MENSUALIDAD") ||
    product.name.includes("SEMANA") ||
    product.name.includes("TRIMESTRE") ||
    product.name.includes("ANUAL");

  const operations: any[] = [
    prisma.inventoryMovement.create({
      data: {
        productId: data.productId,
        type: "SALE",
        location: "GYM",
        quantity: -data.quantity,
        ticket: data.ticket,
        memberId: data.memberId,
        userId: data.userId,
        unitPrice,
        subtotal,
        discount,
        surcharge,
        total,
        paymentMethod: data.paymentMethod,
        shiftId: data.shiftId,
        notes: data.notes,
      },
      include: {
        product: true,
        member: true,
        user: {
          select: {
            name: true,
          },
        },
      },
    }),
  ];

  // Solo descontar stock si NO es membres√≠a
  if (!isMembership) {
    operations.push(
      prisma.product.update({
        where: { id: data.productId },
        data: {
          gymStock: product.gymStock - data.quantity,
        },
      }),
    );
  }

  const [inventoryMovement] = await prisma.$transaction(operations);

  // Actualizar socio si aplica
  if (data.memberId && isMembership) {
    const member = await prisma.member.findUnique({
      where: { id: data.memberId },
    });

    if (member && member.membershipType) {
      const dates = calculateMembershipDates(member.membershipType);

      await prisma.member.update({
        where: { id: data.memberId },
        data: {
          startDate: dates.startDate,
          endDate: dates.endDate,
          totalVisits: { increment: 1 },
          lastVisit: new Date(),
        },
      });
    }
  } else if (data.memberId) {
    await prisma.member.update({
      where: { id: data.memberId },
      data: {
        totalVisits: { increment: 1 },
        lastVisit: new Date(),
      },
    });
  }

  return serializeDecimal(inventoryMovement);
}

/**
 * Cancela una venta
 * - Marca como cancelada
 * - Devuelve stock a GYM
 * - No afecta membres√≠as ya renovadas
 */
export async function cancelSale(data: CancelSaleInput) {
  const sale = await prisma.inventoryMovement.findUnique({
    where: { id: data.inventoryId },
    include: { product: true },
  });

  if (!sale) {
    throw new Error("Venta no encontrada");
  }

  if (sale.type !== "SALE") {
    throw new Error("Solo se pueden cancelar ventas");
  }

  if (sale.isCancelled) {
    throw new Error("La venta ya fue cancelada");
  }

  const quantityToReturn = Math.abs(sale.quantity);

  const [cancelledInventory] = await prisma.$transaction([
    prisma.inventoryMovement.update({
      where: { id: data.inventoryId },
      data: {
        isCancelled: true,
        cancellationReason: data.cancellationReason,
        cancellationDate: new Date(),
      },
      include: {
        product: true,
        member: true,
      },
    }),
    prisma.product.update({
      where: { id: sale.productId },
      data: {
        gymStock: sale.product.gymStock + quantityToReturn,
      },
    }),
  ]);

  return serializeDecimal(cancelledInventory);
}

// ==================== ENTRY SERVICES ====================

/**
 * Crea una entrada de producto a bodega o gym
 * Incrementa el stock correspondiente
 */
export async function createEntry(data: CreateEntryInput) {
  const product = await prisma.product.findUnique({
    where: { id: data.productId },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  const type: InventoryType =
    data.location === "WAREHOUSE" ? "WAREHOUSE_ENTRY" : "GYM_ENTRY";

  const [inventoryMovement] = await prisma.$transaction([
    prisma.inventoryMovement.create({
      data: {
        productId: data.productId,
        type,
        location: data.location,
        quantity: data.quantity,
        userId: data.userId,
        notes: data.notes,
      },
      include: {
        product: true,
        user: {
          select: {
            name: true,
          },
        },
      },
    }),
    prisma.product.update({
      where: { id: data.productId },
      data: {
        [data.location === "WAREHOUSE" ? "warehouseStock" : "gymStock"]: {
          increment: data.quantity,
        },
      },
    }),
  ]);

  return serializeDecimal(inventoryMovement);
}

// ==================== TRANSFER SERVICES ====================

/**
 * Crea un traspaso entre bodega y gym
 * - Valida stock en origen
 * - Descuenta de origen, suma a destino
 */
export async function createTransfer(data: CreateTransferInput) {
  const origin: Location = data.destination === "GYM" ? "WAREHOUSE" : "GYM";

  const product = await validateStock(data.productId, data.quantity, origin);

  const type: InventoryType =
    data.destination === "GYM" ? "TRANSFER_TO_GYM" : "TRANSFER_TO_WAREHOUSE";

  const [inventoryMovement] = await prisma.$transaction([
    prisma.inventoryMovement.create({
      data: {
        productId: data.productId,
        type,
        location: data.destination,
        quantity: data.quantity,
        userId: data.userId,
        notes:
          data.notes ||
          `Traspaso de ${data.quantity} unidades de ${origin} a ${data.destination}`,
      },
      include: {
        product: true,
        user: {
          select: {
            name: true,
          },
        },
      },
    }),
    prisma.product.update({
      where: { id: data.productId },
      data: {
        warehouseStock:
          origin === "WAREHOUSE"
            ? product.warehouseStock - data.quantity
            : product.warehouseStock + data.quantity,
        gymStock:
          origin === "GYM"
            ? product.gymStock - data.quantity
            : product.gymStock + data.quantity,
      },
    }),
  ]);

  return serializeDecimal(inventoryMovement);
}

// ==================== ADJUSTMENT SERVICES ====================

/**
 * Crea un ajuste de inventario
 * - Puede ser positivo (incrementa) o negativo (decrementa)
 * - Requiere observaciones obligatorias
 * - Valida que no resulte en stock negativo
 */
export async function createAdjustment(data: CreateAdjustmentInput) {
  const product = await prisma.product.findUnique({
    where: { id: data.productId },
  });

  if (!product) {
    throw new Error("Producto no encontrado");
  }

  const currentStock =
    data.location === "WAREHOUSE" ? product.warehouseStock : product.gymStock;
  const newStock = currentStock + data.quantity;

  if (newStock < 0) {
    throw new Error(
      `El ajuste resultar√≠a en existencia negativa. Existencia actual: ${currentStock}`,
    );
  }

  const [inventoryMovement] = await prisma.$transaction([
    prisma.inventoryMovement.create({
      data: {
        productId: data.productId,
        type: "ADJUSTMENT",
        location: data.location,
        quantity: data.quantity,
        userId: data.userId,
        notes: data.notes,
      },
      include: {
        product: true,
        user: {
          select: {
            name: true,
          },
        },
      },
    }),
    prisma.product.update({
      where: { id: data.productId },
      data: {
        [data.location === "WAREHOUSE" ? "warehouseStock" : "gymStock"]:
          newStock,
      },
    }),
  ]);

  return serializeDecimal(inventoryMovement);
}

// ==================== QUERY SERVICES ====================

/**
 * Obtiene movimientos de un producto espec√≠fico
 */
export async function getMovementsByProduct(productId: number, limit?: number) {
  const movements = await prisma.inventoryMovement.findMany({
    where: { productId },
    include: {
      product: {
        select: {
          name: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { date: "desc" },
    take: limit,
  });

  return serializeDecimal(movements);
}

/**
 * Obtiene movimientos dentro de un rango de fechas
 */
export async function getMovementsByDate(startDate: Date, endDate: Date) {
  const movements = await prisma.inventoryMovement.findMany({
    where: {
      date: {
        gte: startDate,
        lte: endDate,
      },
    },
    include: {
      product: {
        select: {
          name: true,
          salePrice: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { date: "desc" },
  });

  return serializeDecimal(movements);
}

/**
 * Obtiene todas las ventas de un ticket espec√≠fico
 */
export async function getSalesByTicket(ticket: string) {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      ticket,
      type: "SALE",
    },
    include: {
      product: {
        select: {
          name: true,
          salePrice: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { date: "asc" },
  });

  return serializeDecimal(sales);
}

/**
 * Obtiene ventas de un corte espec√≠fico
 */
export async function getSalesByShift(shiftId: number) {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      shiftId,
      type: "SALE",
    },
    include: {
      product: {
        select: {
          name: true,
          salePrice: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
    },
    orderBy: { date: "asc" },
  });

  return serializeDecimal(sales);
}

/**
 * Obtiene ventas canceladas en un per√≠odo
 */
export async function getCancelledSales(startDate?: Date, endDate?: Date) {
  const where: any = {
    type: "SALE",
    isCancelled: true,
  };

  if (startDate && endDate) {
    where.cancellationDate = {
      gte: startDate,
      lte: endDate,
    };
  }

  const sales = await prisma.inventoryMovement.findMany({
    where,
    include: {
      product: {
        select: {
          name: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { cancellationDate: "desc" },
  });

  return serializeDecimal(sales);
}



=== services/reports.service.ts ===

// services/reports.service.ts
import { prisma } from "@/lib/db";
import { Decimal } from "@prisma/client/runtime/library";
import { serializeDecimal } from "./utils";

// ==================== TYPES ====================

export interface ReportPeriodParams {
  startDate: Date;
  endDate: Date;
}

export interface SalesReportByProduct {
  productId: number;
  productName: string;
  quantitySold: number;
  totalSales: Decimal;
  quantityCancelled: number;
  totalCancelled: Decimal;
}

export interface DailySalesReport {
  date: string;
  ticketCount: number;
  totalSales: Decimal;
  totalCancelled: Decimal;
}

// ==================== HELPERS ====================

function toDecimal(value: number | Decimal): Decimal {
  return new Decimal(value.toString());
}

function formatDate(date: Date): string {
  return date.toISOString().split("T")[0];
}

// ==================== SALES REPORTS ====================

/**
 * Reporte de ventas por producto en un per√≠odo
 */
export async function getSalesReportByProduct(
  params: ReportPeriodParams,
): Promise<SalesReportByProduct[]> {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      type: "SALE",
      date: {
        gte: params.startDate,
        lte: params.endDate,
      },
    },
    include: {
      product: {
        select: {
          id: true,
          name: true,
        },
      },
    },
  });

  const reportByProduct = sales.reduce(
    (acc, sale) => {
      const id = sale.product.id;
      if (!acc[id]) {
        acc[id] = {
          productId: id,
          productName: sale.product.name,
          quantitySold: 0,
          totalSales: new Decimal(0),
          quantityCancelled: 0,
          totalCancelled: new Decimal(0),
        };
      }

      const quantity = Math.abs(sale.quantity);
      const total = toDecimal(sale.total || 0);

      if (sale.isCancelled) {
        acc[id].quantityCancelled += quantity;
        acc[id].totalCancelled = acc[id].totalCancelled.plus(total);
      } else {
        acc[id].quantitySold += quantity;
        acc[id].totalSales = acc[id].totalSales.plus(total);
      }

      return acc;
    },
    {} as Record<number, SalesReportByProduct>,
  );

  return Object.values(reportByProduct).sort(
    (a, b) => Number(b.totalSales) - Number(a.totalSales),
  );
}

/**
 * Reporte de ventas diarias
 */
export async function getDailySalesReport(
  params: ReportPeriodParams,
): Promise<DailySalesReport[]> {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      type: "SALE",
      date: {
        gte: params.startDate,
        lte: params.endDate,
      },
    },
  });

  const salesByDay = sales.reduce(
    (acc, sale) => {
      const date = formatDate(sale.date);
      if (!acc[date]) {
        acc[date] = {
          date,
          tickets: new Set<string>(),
          totalSales: new Decimal(0),
          totalCancelled: new Decimal(0),
        };
      }

      if (sale.ticket) {
        acc[date].tickets.add(sale.ticket);
      }

      const total = toDecimal(sale.total || 0);

      if (sale.isCancelled) {
        acc[date].totalCancelled = acc[date].totalCancelled.plus(total);
      } else {
        acc[date].totalSales = acc[date].totalSales.plus(total);
      }

      return acc;
    },
    {} as Record
      string,
      {
        date: string;
        tickets: Set<string>;
        totalSales: Decimal;
        totalCancelled: Decimal;
      }
    >,
  );

  return Object.values(salesByDay)
    .map((day) => ({
      date: day.date,
      ticketCount: day.tickets.size,
      totalSales: day.totalSales,
      totalCancelled: day.totalCancelled,
    }))
    .sort((a, b) => a.date.localeCompare(b.date));
}

/**
 * Reporte de ventas por forma de pago
 */
export async function getSalesByPaymentMethod(params: ReportPeriodParams) {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      type: "SALE",
      isCancelled: false,
      date: {
        gte: params.startDate,
        lte: params.endDate,
      },
    },
  });

  const report = sales.reduce(
    (acc, sale) => {
      const method = sale.paymentMethod || "CASH";
      const total = toDecimal(sale.total || 0);

      acc[method].quantity += 1;
      acc[method].total = acc[method].total.plus(total);

      return acc;
    },
    {
      CASH: { paymentMethod: "CASH", quantity: 0, total: new Decimal(0) },
      DEBIT_CARD: {
        paymentMethod: "DEBIT_CARD",
        quantity: 0,
        total: new Decimal(0),
      },
      CREDIT_CARD: {
        paymentMethod: "CREDIT_CARD",
        quantity: 0,
        total: new Decimal(0),
      },
      TRANSFER: {
        paymentMethod: "TRANSFER",
        quantity: 0,
        total: new Decimal(0),
      },
    },
  );

  return Object.values(report);
}

/**
 * Reporte de ventas canceladas
 */
export async function getCancelledSalesReport(params: ReportPeriodParams) {
  const sales = await prisma.inventoryMovement.findMany({
    where: {
      type: "SALE",
      isCancelled: true,
      cancellationDate: {
        gte: params.startDate,
        lte: params.endDate,
      },
    },
    include: {
      product: {
        select: {
          name: true,
        },
      },
      member: {
        select: {
          memberNumber: true,
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { cancellationDate: "desc" },
  });

  const totalCancelled = sales.reduce(
    (sum, v) => sum.plus(toDecimal(v.total || 0)),
    new Decimal(0),
  );

  return {
    sales,
    totalCancelled,
    cancellationCount: sales.length,
  };
}

// ==================== INVENTORY REPORTS ====================

/**
 * Reporte de movimientos de inventario
 */
export async function getInventoryMovementsReport(params: ReportPeriodParams) {
  const movements = await prisma.inventoryMovement.findMany({
    where: {
      date: {
        gte: params.startDate,
        lte: params.endDate,
      },
    },
    include: {
      product: {
        select: {
          name: true,
        },
      },
      user: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { date: "desc" },
  });

  const summaryByType = movements.reduce(
    (acc, mov) => {
      const type = mov.type;
      if (!acc[type]) {
        acc[type] = {
          type,
          quantity: 0,
        };
      }
      acc[type].quantity += 1;
      return acc;
    },
    {} as Record<string, { type: string; quantity: number }>,
  );

  return {
    movements,
    summaryByType: Object.values(summaryByType),
  };
}

/**
 * Reporte de stock actual
 */
export async function getCurrentStockReport() {
  const products = await prisma.product.findMany({
    where: { isActive: true },
    orderBy: { name: "asc" },
  });

  const stockSummary = products.reduce(
    (acc, p) => {
      acc.warehouse += p.warehouseStock;
      acc.gym += p.gymStock;
      acc.total += p.warehouseStock + p.gymStock;
      acc.totalValue +=
        Number(p.salePrice) * (p.warehouseStock + p.gymStock);
      return acc;
    },
    { warehouse: 0, gym: 0, total: 0, totalValue: 0 },
  );

  const lowStock = products.filter(
    (p) => p.gymStock < p.minStock || p.warehouseStock < p.minStock,
  );

  return serializeDecimal({
    products,
    stockSummary,
    lowStock,
  });
}

// ==================== MEMBER REPORTS ====================

/**
 * Reporte de socios por tipo de membres√≠a
 */
export async function getMembersByMembershipReport() {
  const members = await prisma.member.groupBy({
    by: ["membershipType", "isActive"],
    _count: true,
  });

  return members.map((m) => ({
    membershipType: m.membershipType || "NO_MEMBERSHIP",
    isActive: m.isActive,
    quantity: m._count,
  }));
}

/**
 * Reporte de nuevos socios
 */
export async function getNewMembersReport(params: ReportPeriodParams) {
  const members = await prisma.member.findMany({
    where: {
      createdAt: {
        gte: params.startDate,
        lte: params.endDate,
      },
    },
    orderBy: { createdAt: "desc" },
  });

  const byDay = members.reduce(
    (acc, member) => {
      const date = formatDate(member.createdAt);
      if (!acc[date]) {
        acc[date] = {
          date,
          quantity: 0,
        };
      }
      acc[date].quantity += 1;
      return acc;
    },
    {} as Record<string, { date: string; quantity: number }>,
  );

  return {
    members,
    byDay: Object.values(byDay).sort((a, b) => a.date.localeCompare(b.date)),
    total: members.length,
  };
}

/**
 * Reporte de visitas de socios
 */
export async function getMemberVisitsReport(params: ReportPeriodParams) {
  const visits = await prisma.inventoryMovement.findMany({
    where: {
      type: "SALE",
      isCancelled: false,
      memberId: { not: null },
      date: {
        gte: params.startDate,
        lte: params.endDate,
      },
    },
    include: {
      member: {
        select: {
          memberNumber: true,
          name: true,
          membershipType: true,
        },
      },
    },
  });

  const visitsByMember = visits.reduce(
    (acc, visit) => {
      const memberId = visit.memberId!;
      if (!acc[memberId]) {
        acc[memberId] = {
          member: visit.member!,
          visitCount: 0,
        };
      }
      acc[memberId].visitCount += 1;
      return acc;
    },
    {} as Record<number, { member: any; visitCount: number }>,
  );

  return Object.values(visitsByMember).sort(
    (a, b) => b.visitCount - a.visitCount,
  );
}

// ==================== DASHBOARD ====================

/**
 * Resumen para dashboard
 */
export async function getDashboardSummary(params?: ReportPeriodParams) {
  const startDate =
    params?.startDate || new Date(new Date().setHours(0, 0, 0, 0));
  const endDate =
    params?.endDate || new Date(new Date().setHours(23, 59, 59, 999));

  const [salesToday, activeMembers, activeProducts, activeShift] =
    await Promise.all([
      prisma.inventoryMovement.findMany({
        where: {
          type: "SALE",
          isCancelled: false,
          date: {
            gte: startDate,
            lte: endDate,
          },
        },
      }),
      prisma.member.count({ where: { isActive: true } }),
      prisma.product.count({ where: { isActive: true } }),
      prisma.shift.findFirst({
        where: { closingDate: null },
        include: {
          cashier: {
            select: {
              name: true,
            },
          },
        },
      }),
    ]);

  const totalSalesToday = salesToday.reduce(
    (sum, v) => sum.plus(toDecimal(v.total || 0)),
    new Decimal(0),
  );

  const ticketsToday = new Set(salesToday.map((v) => v.ticket)).size;

  const productsLowStock = await prisma.product.count({
    where: {
      isActive: true,
      OR: [
        {
          gymStock: {
            lt: prisma.product.fields.minStock,
          },
        },
        {
          warehouseStock: {
            lt: prisma.product.fields.minStock,
          },
        },
      ],
    },
  });

  return {
    salesToday: {
      total: totalSalesToday,
      tickets: ticketsToday,
      quantity: salesToday.length,
    },
    members: {
      active: activeMembers,
    },
    products: {
      active: activeProducts,
      lowStock: productsLowStock,
    },
    activeShift,
  };
}

// ==================== SHIFT REPORTS ====================

/**
 * Reporte de cortes
 */
export async function getShiftsReport(params: ReportPeriodParams) {
  const shifts = await prisma.shift.findMany({
    where: {
      openingDate: {
        gte: params.startDate,
        lte: params.endDate,
      },
    },
    include: {
      cashier: {
        select: {
          name: true,
        },
      },
    },
    orderBy: { openingDate: "desc" },
  });

  const totalSales = shifts.reduce(
    (sum, s) => sum.plus(toDecimal(s.totalSales)),
    new Decimal(0),
  );

  const totalDifferences = shifts.reduce(
    (sum, s) => sum.plus(toDecimal(Math.abs(Number(s.difference)))),
    new Decimal(0),
  );

  const averageSales =
    shifts.length > 0 ? totalSales.dividedBy(shifts.length) : new Decimal(0);

  return {
    shifts,
    summary: {
      totalShifts: shifts.length,
      totalSales,
      totalDifferences,
      averageSales,
    },
  };
}


=== services/users.service.ts ===

// services/users.service.ts
import { prisma } from "@/lib/db";
import { Role } from "@prisma/client";

// ==================== TYPES ====================

export interface CreateUserInput {
  name: string;
  email: string;
  role?: Role;
  password: string;
}

export interface UpdateUserInput {
  name?: string;
  email?: string;
  role?: Role;
  isActive?: boolean;
}

// ==================== VALIDATIONS ====================

function validateAdminRole(userRole: Role) {
  if (userRole !== "ADMIN") {
    throw new Error("No tienes permisos para realizar esta operaci√≥n");
  }
}

// ==================== PUBLIC SERVICES ====================

/**
 * Lista todos los usuarios
 */
export async function getAllUsers() {
  return await prisma.user.findMany({
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      isActive: true,
      createdAt: true,
      updatedAt: true,
    },
    orderBy: { createdAt: "desc" },
  });
}

/**
 * Obtiene un usuario por ID
 */
export async function getUserById(userId: string) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      isActive: true,
      createdAt: true,
      updatedAt: true,
    },
  });

  if (!user) {
    throw new Error("Usuario no encontrado");
  }

  return user;
}

/**
 * Crea un nuevo usuario (solo ADMIN)
 */
export async function createUser(data: CreateUserInput, currentUserRole: Role) {
  validateAdminRole(currentUserRole);

  const existingUser = await prisma.user.findUnique({
    where: { email: data.email },
  });

  if (existingUser) {
    throw new Error("El correo electr√≥nico ya est√° registrado");
  }

  const { password, ...userData } = data;

  const user = await prisma.user.create({
    data: {
      ...userData,
      role: data.role || "EMPLEADO",
      emailVerified: true,
    },
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      isActive: true,
    },
  });

  return user;
}

/**
 * Actualiza un usuario (solo ADMIN)
 */
export async function updateUser(
  userId: string,
  data: UpdateUserInput,
  currentUserRole: Role,
) {
  validateAdminRole(currentUserRole);

  const user = await prisma.user.findUnique({
    where: { id: userId },
  });

  if (!user) {
    throw new Error("Usuario no encontrado");
  }

  if (data.email && data.email !== user.email) {
    const existingUser = await prisma.user.findUnique({
      where: { email: data.email },
    });

    if (existingUser) {
      throw new Error("El correo electr√≥nico ya est√° registrado");
    }
  }

  const updatedUser = await prisma.user.update({
    where: { id: userId },
    data,
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      isActive: true,
      updatedAt: true,
    },
  });

  return updatedUser;
}

/**
 * Activa/desactiva un usuario (solo ADMIN)
 */
export async function toggleUserStatus(userId: string, currentUserRole: Role) {
  validateAdminRole(currentUserRole);

  const user = await prisma.user.findUnique({
    where: { id: userId },
  });

  if (!user) {
    throw new Error("Usuario no encontrado");
  }

  const updatedUser = await prisma.user.update({
    where: { id: userId },
    data: { isActive: !user.isActive },
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      isActive: true,
    },
  });

  return updatedUser;
}

/**
 * Lista solo usuarios activos
 */
export async function getActiveUsers() {
  return await prisma.user.findMany({
    where: { isActive: true },
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
    },
    orderBy: { name: "asc" },
  });
}



=== services/utils.ts ===

import { Decimal } from "@prisma/client/runtime/library";

export function serializeDecimal(value: any): any {
  // Convertir a JSON y volver a parsear elimina todos los m√©todos y propiedades no serializables
  return JSON.parse(
    JSON.stringify(value, (key, val) => {
      // Convertir Decimals a n√∫meros
      if (val instanceof Decimal) {
        return Number(val.toString());
      }
      // Convertir Dates a ISO strings
      if (val instanceof Date) {
        return val.toISOString();
      }
      return val;
    }),
  );
}




### TYPES ###


=== types/validator.ts ===

// This file is generated automatically by Next.js
// Do not edit this file manually
// This file validates that all pages and layouts export the correct types

import type { AppRoutes, LayoutRoutes, ParamMap } from "./routes.js"
import type { ResolvingMetadata, ResolvingViewport } from "next/types.js"

type AppPageConfig<Route extends AppRoutes = AppRoutes> = {
  default: React.ComponentType<{ params: Promise<ParamMap[Route]> } & any> | ((props: { params: Promise<ParamMap[Route]> } & any) => React.ReactNode | Promise<React.ReactNode> | never | void | Promise<void>)
  generateStaticParams?: (props: { params: ParamMap[Route] }) => Promise<any[]> | any[]
  generateMetadata?: (
    props: { params: Promise<ParamMap[Route]> } & any,
    parent: ResolvingMetadata
  ) => Promise<any> | any
  generateViewport?: (
    props: { params: Promise<ParamMap[Route]> } & any,
    parent: ResolvingViewport
  ) => Promise<any> | any
  metadata?: any
  viewport?: any
}

type LayoutConfig<Route extends LayoutRoutes = LayoutRoutes> = {
  default: React.ComponentType<LayoutProps<Route>> | ((props: LayoutProps<Route>) => React.ReactNode | Promise<React.ReactNode> | never | void | Promise<void>)
  generateStaticParams?: (props: { params: ParamMap[Route] }) => Promise<any[]> | any[]
  generateMetadata?: (
    props: { params: Promise<ParamMap[Route]> } & any,
    parent: ResolvingMetadata
  ) => Promise<any> | any
  generateViewport?: (
    props: { params: Promise<ParamMap[Route]> } & any,
    parent: ResolvingViewport
  ) => Promise<any> | any
  metadata?: any
  viewport?: any
}


// Validate ../../app/page.tsx
{
  type __IsExpected<Specific extends AppPageConfig<"/">> = Specific
  const handler = {} as typeof import("../../app/page.js")
  type __Check = __IsExpected<typeof handler>
  // @ts-ignore
  type __Unused = __Check
}







// Validate ../../app/layout.tsx
{
  type __IsExpected<Specific extends LayoutConfig<"/">> = Specific
  const handler = {} as typeof import("../../app/layout.js")
  type __Check = __IsExpected<typeof handler>
  // @ts-ignore
  type __Unused = __Check
}



=== types/routes.d.ts ===

// This file is generated automatically by Next.js
// Do not edit this file manually

type AppRoutes = "/"
type PageRoutes = never
type LayoutRoutes = "/"
type RedirectRoutes = never
type RewriteRoutes = never
type Routes = AppRoutes | PageRoutes | LayoutRoutes | RedirectRoutes | RewriteRoutes


interface ParamMap {
  "/": {}
}


export type ParamsOf<Route extends Routes> = ParamMap[Route]

interface LayoutSlotMap {
  "/": never
}


export type { AppRoutes, PageRoutes, LayoutRoutes, RedirectRoutes, RewriteRoutes, ParamMap }

declare global {
  /**
   * Props for Next.js App Router page components
   * @example
   * ```tsx
   * export default function Page(props: PageProps<'/blog/[slug]'>) {
   *   const { slug } = await props.params
   *   return <div>Blog post: {slug}</div>
   * }
   * ```
   */
  interface PageProps<AppRoute extends AppRoutes> {
    params: Promise<ParamMap[AppRoute]>
    searchParams: Promise<Record<string, string | string[] | undefined>>
  }

  /**
   * Props for Next.js App Router layout components
   * @example
   * ```tsx
   * export default function Layout(props: LayoutProps<'/dashboard'>) {
   *   return <div>{props.children}</div>
   * }
   * ```
   */
  type LayoutProps<LayoutRoute extends LayoutRoutes> = {
    params: Promise<ParamMap[LayoutRoute]>
    children: React.ReactNode
  } & {
    [K in LayoutSlotMap[LayoutRoute]]: React.ReactNode
  }
}


